#ifndef NXOpen_CALLBACKTEST_HXX_INCLUDED
#define NXOpen_CALLBACKTEST_HXX_INCLUDED
//--------------------------------------------------------------------------
//  Header for C++ interface to JA API
//--------------------------------------------------------------------------
//
//  Source File:
//     CallbackTest.ja
//
//  Generated by:
//     apiwrap
//
//  WARNING:
//    This file is automatically generated - do not edit by hand
//
#include <vector>
#include <NXOpen/NXString.hxx>
#include <NXOpen/Callback.hxx>
#include <NXOpen/TransientObject.hxx>
#include <NXOpen/libnxopendebugsessioncpp_exports.hxx>
namespace NXOpen
{
    class CallbackTest;
    namespace CallbackTestNamespace
    {
        namespace Subspace
        {
            class CallbackTransientObj;
        }
    }
    class NXObject;
    /** Test class with callback methods involving various different parameter types to test the callback code */
    class NXOPENDEBUGSESSIONCPPEXPORT CallbackTest : public TransientObject
    {
        /** simple test enum */
        public: enum Enum1
        {
            Enum1FirstValue/** first value */ ,
            Enum1SecondValue/** second value */ ,
            Enum1ThirdValue/** third value */ 
        };

        /** simple test enum with special first value */
        public: enum Enum2
        {
            Enum2FirstValue = 1/** first value */ ,
            Enum2SecondValue/** second value */ ,
            Enum2ThirdValue/** third value */ 
        };

        /** simple test enum with gap in member values */
        public: enum Enum3
        {
            Enum3FirstValue/** first value */ ,
            Enum3SecondValue = 2/** second value */ ,
            Enum3ThirdValue/** third value */ ,
            Enum3FourthValue = 6/** fourth value */ ,
            Enum3FifthValue/** fifth value */ 
        };

        /** test enum for enumerated return types */
        public: enum EnumReturn
        {
            EnumReturnDialogOk/** dialog ok */ ,
            EnumReturnCanceled/** canceled */ ,
            EnumReturnApply/** apply */ 
        };

         /** simple test struct - containing a string */
        public:
        struct Struct1
        {
            public: /** int value */ int IntValue;
            public: /** double value */ double DoubleValue;
            public: /** string value */ NXString StringValue;
            public: /** text value */ NXString TextValue;
            public: Struct1() :
                IntValue(),
                DoubleValue(),
                StringValue(),
                TextValue()
            {
            }
            /** Constructor for the Struct1 struct. */ 
            public: Struct1(int INIT_int_value /** int value */ , double INIT_double_value /** double value */ , NXString INIT_string_value /** string value */ , NXString INIT_text_value /** text value */ ) :
                IntValue(INIT_int_value),
                DoubleValue(INIT_double_value),
                StringValue(INIT_string_value),
                TextValue(INIT_text_value)
            {
            }
        };

         /** test struct */
        public:
        struct Struct2
        {
            public: /** x value */ double XValue;
            public: /** y value */ double YValue;
            public: Struct2() :
                XValue(),
                YValue()
            {
            }
            /** Constructor for the Struct2 struct. */ 
            public: Struct2(double INIT_x_value /** x value */ , double INIT_y_value /** y value */ ) :
                XValue(INIT_x_value),
                YValue(INIT_y_value)
            {
            }
        };

         /** test struct - contains nested struct and logical and enum fields */
        public:
        struct Struct3
        {
            public: /** boolean flag */ bool BooleanFlag;
            public: /** int value */ int IntValue;
            public: /** first struct */ NXOpen::CallbackTest::Struct1 FirstStruct;
            public: /** second struct */ NXOpen::CallbackTest::Struct2 SecondStruct;
            public: /** enum value */ NXOpen::CallbackTest::Enum3 EnumValue;
            public: Struct3() :
                BooleanFlag(),
                IntValue(),
                FirstStruct(),
                SecondStruct(),
                EnumValue((NXOpen::CallbackTest::Enum3)0)
            {
            }
            /** Constructor for the Struct3 struct. */ 
            public: Struct3(bool INIT_boolean_flag /** boolean flag */ , int INIT_int_value /** int value */ , NXOpen::CallbackTest::Struct1 INIT_first_struct /** first struct */ , NXOpen::CallbackTest::Struct2 INIT_second_struct /** second struct */ , NXOpen::CallbackTest::Enum3 INIT_enum_value /** enum value */ ) :
                BooleanFlag(INIT_boolean_flag),
                IntValue(INIT_int_value),
                FirstStruct(INIT_first_struct),
                SecondStruct(INIT_second_struct),
                EnumValue(INIT_enum_value)
            {
            }
        };

         /** test struct - contains multiply nested structs with logical, int, and double fields */
        public:
        struct Struct4
        {
            public: /** status string */ NXString StatusString;
            public: /** third struct */ NXOpen::CallbackTest::Struct3 ThirdStruct;
            public: /** first struct */ NXOpen::CallbackTest::Struct1 FirstStruct;
            public: Struct4() :
                StatusString(),
                ThirdStruct(),
                FirstStruct()
            {
            }
            /** Constructor for the Struct4 struct. */ 
            public: Struct4(NXString INIT_status_string /** status string */ , NXOpen::CallbackTest::Struct3 INIT_third_struct /** third struct */ , NXOpen::CallbackTest::Struct1 INIT_first_struct /** first struct */ ) :
                StatusString(INIT_status_string),
                ThirdStruct(INIT_third_struct),
                FirstStruct(INIT_first_struct)
            {
            }
        };

         /** mask triple - test for selection types */
        public:
        struct MaskTriple
        {
            public: /** Object type. This can be one of the object types that are listed in 
                                  uf_object_types.h. For example, for point, 
                                  use UF_point_type in C++ and
                                  NXOpen.UF.UFConstants.UF_point_type in .NET. */int Type;
            public: /** Object subtype. This can either be 0 (UF_all_subtype) for any subtype, or a
                                    subtype of the selected type.
                                    The subtypes are listed in uf_object_types.h.
                                    */int Subtype;
            public: /** Solid body subtype. This is only meaningful when the type is 
                                   UF_solid_type.  In that case, this should be set to
                                   one of the solid type constants listed in uf_ui_types.h 
                                   under "Constants for selection solid_type". For example,
                                   to select any face, use UF_UI_SEL_FEATURE_ANY_FACE in C++ and 
                                   NXOpen.UF.UFConstants.UF_UI_SEL_FEATURE_ANY_FACE in .NET */int SolidBodySubtype;
            public: MaskTriple() :
                Type(),
                Subtype(),
                SolidBodySubtype()
            {
            }
            /** Constructor for the MaskTriple struct. */ 
            public: MaskTriple(int INIT_type /** Object type. This can be one of the object types that are listed in 
                                  uf_object_types.h. For example, for point, 
                                  use UF_point_type in C++ and
                                  NXOpen.UF.UFConstants.UF_point_type in .NET. */, int INIT_subtype /** Object subtype. This can either be 0 (UF_all_subtype) for any subtype, or a
                                    subtype of the selected type.
                                    The subtypes are listed in uf_object_types.h.
                                    */, int INIT_solid_body_subtype /** Solid body subtype. This is only meaningful when the type is 
                                   UF_solid_type.  In that case, this should be set to
                                   one of the solid type constants listed in uf_ui_types.h 
                                   under "Constants for selection solid_type". For example,
                                   to select any face, use UF_UI_SEL_FEATURE_ANY_FACE in C++ and 
                                   NXOpen.UF.UFConstants.UF_UI_SEL_FEATURE_ANY_FACE in .NET */) :
                Type(INIT_type),
                Subtype(INIT_subtype),
                SolidBodySubtype(INIT_solid_body_subtype)
            {
            }
        };

        public: typedef NXOpen::Callback1<int, int> TestCallback;
        public: typedef NXOpen::Callback0<void> TestCallback1;
        public: typedef NXOpen::Callback2<double, NXString, NXOpen::TaggedObject *> TestCallback2;
        public: typedef NXOpen::Callback3<bool, bool, double, NXOpen::CallbackTest::Enum1> TestCallback3;
        public: typedef NXOpen::Callback0<NXOpen::CallbackTest::Enum1> TestCallback4;
        public: typedef NXOpen::Callback1<NXString, NXString> TestCallback5;
        public: typedef NXOpen::Callback1<NXOpen::CallbackTest::Enum1, NXOpen::CallbackTest::Enum2> TestCallbackEnum;
        public: typedef NXOpen::Callback1<double, NXOpen::CallbackTest::Struct1 *> TestCallbackStruct;
        public: typedef NXOpen::Callback1<NXOpen::CallbackTest::Struct2, NXOpen::CallbackTest::Struct1 *> TestCallback6;
        public: typedef NXOpen::Callback3<double, std::vector<NXOpen::NXObject *>, std::vector<NXOpen::NXObject *>, NXOpen::CallbackTestNamespace::Subspace::CallbackTransientObj *> TestCallbackArray;
        public: typedef NXOpen::Callback3<double, std::vector<NXOpen::CallbackTest::Struct4 *>, std::vector<NXOpen::NXObject *>, NXOpen::CallbackTestNamespace::Subspace::CallbackTransientObj *> TestCallbackArrayStructure;
        public: typedef NXOpen::Callback3<bool, NXOpen::NXObject *, NXOpen::CallbackTest::MaskTriple *, NXOpen::CallbackTestNamespace::Subspace::CallbackTransientObj *> TestSelectionFilterCallback;
        public: typedef NXOpen::Callback1<int, NXOpen::CallbackTestNamespace::Subspace::CallbackTransientObj *> TestCallbackTransient;
        public: enum { Constant = 42 };
        public: explicit CallbackTest(void *ptr);
        /**  <br> License requirements : None */
        public: virtual ~CallbackTest();
        /** Prints a tagged object  <br> License requirements : None */
        public: void PrintObject
        (
            NXOpen::TaggedObject * object /** object */ 
        );
        /** Tests using a simple callback function.  <br> License requirements : None */
        public: void InCallback
        (
            const NXOpen::CallbackTest::TestCallback&  cb /** cb */ 
        );
        /** Tests using a simple callback function with a member function.  <br> License requirements : None */
        public: void InMemberCallback
        (
            const NXOpen::CallbackTest::TestCallback&  cb /** cb */ 
        );
        /** Tests using multiple callback functions in a single function.  <br> License requirements : None */
        public: void InCallback2
        (
            const NXOpen::CallbackTest::TestCallback1&  my_cb1 /** my cb1 */ ,
            const NXOpen::CallbackTest::TestCallback2&  my_cb2 /** my cb2 */ 
        );
        /** Tests using multiple callback functions in a single function.  <br> License requirements : None */
        public: void InCallback3
        (
            const NXOpen::CallbackTest::TestCallback3&  cb3 /** cb3 */ ,
            const NXOpen::CallbackTest::TestCallback4&  cb4 /** cb4 */ ,
            const NXOpen::CallbackTest::TestCallback5&  cb5 /** cb5 */ 
        );
        /** Simpler tests using multiple callback functions in a single function 
                to test enum support.  <br> License requirements : None */
        public: void InCallbackEnum
        (
            const NXOpen::CallbackTest::TestCallback4&  cb4 /** cb4 */ ,
            const NXOpen::CallbackTest::TestCallbackEnum&  enum_cb /** enum cb */ 
        );
        /** Tests using structures as input for callbacks.  <br> License requirements : None */
        public: void InCallbackStruct
        (
            const NXOpen::CallbackTest::TestCallbackStruct&  cb_struct /** cb struct */ 
        );
        /** Tests complex callback functions with complex types for arguments.  <br> License requirements : None */
        public: void InCallback4
        (
            const NXOpen::CallbackTest::TestCallback6&  cb6 /** cb6 */ 
        );
        /** Tests using arrays as input for callbacks.  <br> License requirements : None */
        public: void InCallbackArray
        (
            const NXOpen::CallbackTest::TestCallbackArray&  cb_array /** cb array */ 
        );
        /** Tests using arrays of structures as input for callbacks.  <br> License requirements : None */
        public: void InCallbackArrayOfStructures
        (
            const NXOpen::CallbackTest::TestCallbackArrayStructure&  cb_array_structure /** cb array structure */ 
        );
        /** Tests the selection filter callbacks.  <br> License requirements : None */
        public: void InSelectionFilterCallback
        (
            const NXOpen::CallbackTest::TestSelectionFilterCallback&  filter_cb /** filter cb */ 
        );
        /** Tests a callback function and generates an error for negative testing.  <br> License requirements : None */
        public: void InCallbackError
        (
            const NXOpen::CallbackTest::TestCallback1&  cb /** cb */ 
        );
        /** Tests using a transient object callback function.  <br> License requirements : None */
        public: void InCallbackTransient
        (
            const NXOpen::CallbackTest::TestCallbackTransient&  cb /** cb */ 
        );
    };
}
#undef EXPORTLIBRARY
#endif
