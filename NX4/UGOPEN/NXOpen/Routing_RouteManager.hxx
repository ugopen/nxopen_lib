#ifndef NXOpen_ROUTING_ROUTEMANAGER_HXX_INCLUDED
#define NXOpen_ROUTING_ROUTEMANAGER_HXX_INCLUDED
//--------------------------------------------------------------------------
//  Header for C++ interface to JA API
//--------------------------------------------------------------------------
//
//  Source File:
//     Routing_RouteManager.ja
//
//  Generated by:
//     apiwrap
//
//  WARNING:
//    This file is automatically generated - do not edit by hand
//
#include <vector>
#include <NXOpen/NXString.hxx>
#include <NXOpen/Routing_CharacteristicList.hxx>
#include <NXOpen/libnxopencpp_exports.hxx>
namespace NXOpen
{
    namespace Routing
    {
        class RouteManager;
    }
    class Part;
    namespace Assemblies
    {
        class Component;
    }
    class Direction;
    class NXObject;
    namespace Routing
    {
        class AnchorCollection;
    }
    namespace Routing
    {
        class BendCornerCollection;
    }
    namespace Routing
    {
        class BuiltInPathCollection;
    }
    namespace Routing
    {
        class CharacteristicList;
    }
    namespace Routing
    {
        class ControlPointCollection;
    }
    namespace Routing
    {
        class CopeCornerCollection;
    }
    namespace Routing
    {
        class CornerCollection;
    }
    namespace Routing
    {
        class CrossSectionCollection;
    }
    namespace Routing
    {
        class DesignRuleViolationCollection;
    }
    namespace Routing
    {
        class DiscontinuityCornerCollection;
    }
    namespace Routing
    {
        class FillerCollection;
    }
    namespace Routing
    {
        class FittingPortCollection;
    }
    namespace Routing
    {
        class FixturePortCollection;
    }
    namespace Routing
    {
        class FormboardFrameCollection;
    }
    namespace Routing
    {
        class MiterCornerCollection;
    }
    namespace Routing
    {
        class MultiPortCollection;
    }
    namespace Routing
    {
        class OffsetPathCollection;
    }
    namespace Routing
    {
        class OverstockApplicationCollection;
    }
    namespace Routing
    {
        class PortCollection;
    }
    namespace Routing
    {
        class PortConnectionCollection;
    }
    namespace Routing
    {
        class RouteLogicalAssociationCollection;
    }
    namespace Routing
    {
        class RoutePartDescriptorCollection;
    }
    namespace Routing
    {
        class RoutingSystemCollection;
    }
    namespace Routing
    {
        class RunCollection;
    }
    namespace Routing
    {
        class SBendCornerCollection;
    }
    namespace Routing
    {
        class StockCollection;
    }
    namespace Routing
    {
        class StockDataCollection;
    }
    namespace Routing
    {
        class TerminalPortCollection;
    }
    namespace Routing
    {
        class WireCollection;
    }
    namespace Routing
    {
        /** Contains the type of the routing part as well as the Collection objects for creating/iterating
                over routing objects.
             <br> To obtain an instance of this class, refer to @link Part Part@endlink  <br> */
        class NXOPENCPPEXPORT RouteManager
        {
            /** Type for a @link RouteManager RouteManager@endlink . */
            public: enum PartType
            {
                PartTypePart/**  */,
                PartTypeStock/**  */,
                PartTypeFabrication/**  */,
                PartTypeStockComponent/**  */,
                PartTypeWireComponent/**  */,
                PartTypeOverstock/**  */,
                PartTypeLogical/**  */,
                PartTypeTemplateAssy/**  */,
                PartTypeConnector/**  */,
                PartTypeSplice/**  */,
                PartTypeDevice/**  */,
                PartTypeFiller/**  */,
                PartTypeUnknown = -1/**  */
            };

            private: NXOpen::Part* m_owner;
            public: explicit RouteManager(NXOpen::Part *owner): m_owner(owner)
            {
            }
            public: tag_t Tag() const;
            /** Returns the default length tolerance for the current root part.  @return  Length tolerance value used by Routing in units
                                                            of the current root part.  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: double GetLengthTolerance
            (
            );
            /**Returns  the down direction for the part used by Routing.  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: NXOpen::Direction * DownDirection
            (
            );
            /**Sets  the down direction for the part used by Routing.  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void SetDownDirection
            (
                NXOpen::Direction * down_direction /** Global down direction preference for the given part */
            );
            /**Returns  the type for the part used by Routing.  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: NXOpen::Routing::RouteManager::PartType PartTypeFlag
            (
            );
            /**Sets  the type for the part used by Routing.  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void SetPartTypeFlag
            (
                NXOpen::Routing::RouteManager::PartType type /** The type of the given part */
            );
            /** Connects the input component to the stocks and other components in the work part.  
                         <br> 
                            Subdivides segments intersected by ports of the part
                            and marked interior if the segment is "inside" of the part.  Segments are considered
                            inside if all of the end @link Routing::ControlPoint Routing::ControlPoint@endlink  objects of the
                            segments are inside the bounding box of the component.  Interior segments are
                            not displayable.
                         <br> 
                         <br> 
                            All stocks are split at the new interior segments.  The interior stocks are
                            hidden and do not show up in the bill of materials.
                         <br> 
                         <br> 
                            In addition this routine adds fixture ports of the input component to fixed
                            length splines that are intersected by the ports.
                         <br> 
                      <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void InsertIntoStock
            (
                NXOpen::Assemblies::Component * component /** Must be in the same
                                                                                                part as the @link Routing::RouteManager Routing::RouteManager@endlink  object.*/
            );
            /** Disconnects the input component from stocks and components in the work part.
                         <br> 
                            This the opposite of @link Routing::RouteManager::InsertIntoStock Routing::RouteManager::InsertIntoStock@endlink . 
                            Interior segments are marked as non-interior, and any subdivisions performed by
                            @link Routing::RouteManager::InsertIntoStock Routing::RouteManager::InsertIntoStock@endlink  are reversed to
                            the previous state. 
                         <br> 
                         <br> 
                            Interior stocks are marked as non-interior and merge with the existing stocks
                            that were connected to the component.
                         <br> 
                      <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void LiftFromStock
            (
                NXOpen::Assemblies::Component * component /** Must be in the same
                                                                                                part as the @link Routing::RouteManager Routing::RouteManager@endlink  object.*/
            );
            /** Loads a part based on the input @link Routing::CharacteristicList Routing::CharacteristicList@endlink .  
                        This object can be created on the fly, or returned from a search through the part library using
                       the @link Preferences::RoutingPartLibrary::MatchCriteria Preferences::RoutingPartLibrary::MatchCriteria@endlink  or 
                       @link Preferences::RoutingPartLibrary::MatchCriteriaWithFilter Preferences::RoutingPartLibrary::MatchCriteriaWithFilter@endlink  methods.
                        <br> 
                            The input @link Routing::CharacteristicList Routing::CharacteristicList@endlink  must contain a PART_NAME for
                            a regular part, or a MEMBER_NAME and PART_NAME for part family parts.
                        <br> 
                       @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: NXOpen::Part * LoadPart
            (
                NXOpen::Routing::CharacteristicList * part_entry /** */
            );
            /** Logs objects to be checked during the next concurrent design rule check  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void LogConcurrent
            (
                const std::vector<NXOpen::NXObject *> & objects /** Must be in the same
                                                                                                           part as the @link Routing::RouteManager Routing::RouteManager@endlink  object.*/
            );
            /** Gets objects logged for concurrent design rule check  @return  Must be in the same
                                                                                                       part as the @link Routing::RouteManager Routing::RouteManager@endlink  object. <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: std::vector<NXOpen::NXObject *> GetConcurrent
            (
            );
            /** 
                    This method allows you to export all of the NX Routing
                    information from the currently open part to the given file.
                    
                    This method will throw an exception if it could not write to the
                    PLM XML file, if there is no routing data in the part, or if there is
                    no part file open.
                     <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void ExportPlmxml
            (
                const NXString & plmxml_filename /** The name of the file into which this method will write 
                                the NX Routing PLM XML data. 
                              <br>  NOTE: The full Unicode character set is not supported for this parameter.  <br> */
            );
            /** 
                    This method allows you to import NX Routing
                    information from the given PLM XML file into the current work part.
                    
                    This method will throw an exception if it could not read the
                    PLM XML file or if there is no part file open.
                     <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void ImportPlmxml
            (
                const NXString & plmxml_filename /** The name of the file from which this method will read 
                                the NX Routing PLM XML data. 
                              <br>  NOTE: The full Unicode character set is not supported for this parameter.  <br> */
            );


            private: NXOpen::Routing::BuiltInPathCollection *builtInPaths;
            /** BuiltInPath collection */
            public: NXOpen::Routing::BuiltInPathCollection *BuiltInPaths()
            {
                return builtInPaths;
            }
            private: NXOpen::Routing::ControlPointCollection *controlPoints;
            /** ControlPoint collection */
            public: NXOpen::Routing::ControlPointCollection *ControlPoints()
            {
                return controlPoints;
            }
            private: NXOpen::Routing::PortCollection *ports;
            /** Port Collection */
            public: NXOpen::Routing::PortCollection *Ports()
            {
                return ports;
            }
            private: NXOpen::Routing::PortConnectionCollection *portConnection;
            /** Port Connection Collection */
            public: NXOpen::Routing::PortConnectionCollection *PortConnection()
            {
                return portConnection;
            }
            private: NXOpen::Routing::FixturePortCollection *fixturePorts;
            /** FixturePort Collection */
            public: NXOpen::Routing::FixturePortCollection *FixturePorts()
            {
                return fixturePorts;
            }
            private: NXOpen::Routing::FittingPortCollection *fittingPorts;
            /** FittingPort Collection */
            public: NXOpen::Routing::FittingPortCollection *FittingPorts()
            {
                return fittingPorts;
            }
            private: NXOpen::Routing::MultiPortCollection *multiPorts;
            /** MultiPort Collection */
            public: NXOpen::Routing::MultiPortCollection *MultiPorts()
            {
                return multiPorts;
            }
            private: NXOpen::Routing::TerminalPortCollection *terminalPorts;
            /** TerminalPort Collection */
            public: NXOpen::Routing::TerminalPortCollection *TerminalPorts()
            {
                return terminalPorts;
            }
            private: NXOpen::Routing::OffsetPathCollection *offsetPaths;
            /** Offset Path Collection */
            public: NXOpen::Routing::OffsetPathCollection *OffsetPaths()
            {
                return offsetPaths;
            }
            private: NXOpen::Routing::RunCollection *runs;
            /** Run Collection */
            public: NXOpen::Routing::RunCollection *Runs()
            {
                return runs;
            }
            private: NXOpen::Routing::RoutingSystemCollection *routingSystems;
            /** RoutingSystem Collection */
            public: NXOpen::Routing::RoutingSystemCollection *RoutingSystems()
            {
                return routingSystems;
            }
            private: NXOpen::Routing::RouteLogicalAssociationCollection *routeLogicalAssociations;
            /** RouteLogicalAssociation Collection */
            public: NXOpen::Routing::RouteLogicalAssociationCollection *RouteLogicalAssociations()
            {
                return routeLogicalAssociations;
            }
            private: NXOpen::Routing::CornerCollection *corner;
            /** Corner collection */
            public: NXOpen::Routing::CornerCollection *Corner()
            {
                return corner;
            }
            private: NXOpen::Routing::BendCornerCollection *bendCorner;
            /** BendCorner collection */
            public: NXOpen::Routing::BendCornerCollection *BendCorner()
            {
                return bendCorner;
            }
            private: NXOpen::Routing::CopeCornerCollection *copeCorner;
            /** CopeCorner collection */
            public: NXOpen::Routing::CopeCornerCollection *CopeCorner()
            {
                return copeCorner;
            }
            private: NXOpen::Routing::DiscontinuityCornerCollection *discontinuityCorner;
            /** DiscontinuityCorner collection */
            public: NXOpen::Routing::DiscontinuityCornerCollection *DiscontinuityCorner()
            {
                return discontinuityCorner;
            }
            private: NXOpen::Routing::MiterCornerCollection *miterCorner;
            /** MiterCorner collection */
            public: NXOpen::Routing::MiterCornerCollection *MiterCorner()
            {
                return miterCorner;
            }
            private: NXOpen::Routing::SBendCornerCollection *sBendCorner;
            /** SBendCorner collection */
            public: NXOpen::Routing::SBendCornerCollection *SBendCorner()
            {
                return sBendCorner;
            }
            private: NXOpen::Routing::RoutePartDescriptorCollection *routePartDescriptor;
            /** RoutePartDescriptor collection */
            public: NXOpen::Routing::RoutePartDescriptorCollection *RoutePartDescriptor()
            {
                return routePartDescriptor;
            }
            private: NXOpen::Routing::AnchorCollection *anchors;
            /** Anchor collection */
            public: NXOpen::Routing::AnchorCollection *Anchors()
            {
                return anchors;
            }
            private: NXOpen::Routing::StockCollection *stocks;
            /** Stock collection */
            public: NXOpen::Routing::StockCollection *Stocks()
            {
                return stocks;
            }
            private: NXOpen::Routing::StockDataCollection *stockDatas;
            /** Stock Data collection */
            public: NXOpen::Routing::StockDataCollection *StockDatas()
            {
                return stockDatas;
            }
            private: NXOpen::Routing::CrossSectionCollection *crossSections;
            /** Cross Section collection */
            public: NXOpen::Routing::CrossSectionCollection *CrossSections()
            {
                return crossSections;
            }
            private: NXOpen::Routing::DesignRuleViolationCollection *designRuleViolations;
            /** Design Rule Violation collection */
            public: NXOpen::Routing::DesignRuleViolationCollection *DesignRuleViolations()
            {
                return designRuleViolations;
            }
            private: NXOpen::Routing::WireCollection *wires;
            /** Wire Collection */
            public: NXOpen::Routing::WireCollection *Wires()
            {
                return wires;
            }
            private: NXOpen::Routing::OverstockApplicationCollection *overstockApplications;
            /** Overstock Application collection */
            public: NXOpen::Routing::OverstockApplicationCollection *OverstockApplications()
            {
                return overstockApplications;
            }
            private: NXOpen::Routing::FillerCollection *fillers;
            /** Filler stock Application collection */
            public: NXOpen::Routing::FillerCollection *Fillers()
            {
                return fillers;
            }
            private: NXOpen::Routing::FormboardFrameCollection *formboardFrames;
            /** Formboard Frame collection */
            public: NXOpen::Routing::FormboardFrameCollection *FormboardFrames()
            {
                return formboardFrames;
            }
            public: virtual void initialize();
        };
    }
}
#undef EXPORTLIBRARY
#endif
