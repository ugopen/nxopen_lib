/*******************************************************************************

   Copyright (c) 1998-2001 Unigraphics Solutions Inc.
                 Unpublished - All rights reserved
________________________________________________________________________________





File description:

   Internal type definitions for UF_SF_UGS_MESH (Scenario UGS Mesher)
   module.

*******************************************************************************/


#ifndef UF_SF_UGS_MESH_H_INCLUDED
#define UF_SF_UGS_MESH_H_INCLUDED

#include <uf_sf_types.h>

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************
 *   Enumeration:-UF_SF_ugs_mesher_midnode_option_t
 *
 *   This enumeration allows the specification of how midnodes should be
 *   placed during meshing.
 *************************************************************************** */
enum UF_SF_ugs_mesher_midnode_option_e
{
    UF_SF_UGS_MESHER_straight_midnodes = 2,   /* All midnodes will be placed
                                                 at straight line linear
                                                 location between corner
                                                 nodes. */
    UF_SF_UGS_MESHER_curved_midnodes = 1,     /* All midnodes will be project
                                                 to underlying geometry. */
    UF_SF_UGS_MESHER_mixed_midnodes = 0      /* All midnodes will be projected
                                                 to underlying geometry, unless
                                                 doing so would input Jacobian
                                                 error threshold. */
};
typedef enum UF_SF_ugs_mesher_midnode_option_e UF_SF_ugs_mesher_midnode_option_t;

enum UF_SF_ugs_tet_mesh_fillet_type_option_e
{
    UF_SF_UGS_TET_MESH_FILLET__all = 0,      /* Both concave as well as convex fillets */
    UF_SF_UGS_TET_MESH_FILLET__inside = 1,   /* Inside radius fillets. */
    UF_SF_UGS_TET_MESH_FILLET__outside = 2   /* Outside radius fillets */
};
typedef enum UF_SF_ugs_tet_mesh_fillet_type_option_e UF_SF_ugs_tet_mesh_fillet_type_option_t;
/***************************************************************************
 *   Enumeration:-UF_SF_ugs_2d_mesher_elem_type_t
 *
 *   This enumeration allows the specification of what 2d shell element type
 *   should be generated by a shell mesher.
 *************************************************************************** */
enum UF_SF_ugs_2d_mesher_elem_type_e
{
    UF_SF_UGS_MESHER_tri3 = 0,
    UF_SF_UGS_MESHER_tri6 = 1,
    UF_SF_UGS_MESHER_quad4 = 2,
    UF_SF_UGS_MESHER_quad8 = 3
};
typedef enum UF_SF_ugs_2d_mesher_elem_type_e UF_SF_ugs_2d_mesher_elem_type_t;

/***************************************************************************
 *   Structure :- UF_SF_ugs_tet_mesh_parms_s
 *
 *   This structure allows specification of tetrahedral meshing parameters.
 *
 *   Initialization :- This structure can be initialized with the
 *   UF_SF_ugs_tet_mesh_parms_INIT macro.
 *************************************************************************** */
struct UF_SF_ugs_tet_mesh_parms_s
{
    UF_SF_element_type_t element_type;       /* Desired element type. */
    int midnodes;                            /* TRUE for tet10s,
                                                FALSE for tet4s. */
    double element_size;                     /* Desired element size.  If
                                                zero or negative, then mesher
                                                will choose element size
                                                internally. */
    UF_SF_ugs_mesher_midnode_option_t midnode_option; /* Whether to project midnodes or not. */
    int geometry_tolerance_toggle;           /*Geometry Tolerance for midnode straightening*/
    double geometry_tolerance_value;         /*Geometry Tolerance value for midnode straightening*/
    double maximum_midnode_jacobian;         /* If midnode_option =
                                                UF_SF_UGS_MESHER_mixed_midnodes,
                                                any element with a jacobian
                                                value higher than
                                                maximum_midnode_jacobian will
                                                have its midnodes
                                                straightened. */
    double minimum_face_angle;               /* Minimum angle at corner of a
                                                face that can support element.
                                                corners smaller than this will
                                                be pinched out.  This angle is
                                                measured in degrees. */
    int surf_mesh_size_variation;           /* This controls how much variation
                                                in element size is
                                                desired/permitted in the mesh on
                                                the surface of the bodies being
                                                meshed. Valid values go from 0
                                                to 100.  This number does not
                                                coorespond directly to any
                                                actual meshing parameter, but
                                                rather is a relative scale that
                                                the user can use to indicate
                                                their tolerance for mesh
                                                variation.  It is used
                                                internally in the mesher to
                                                calculate expansion factors and
                                                a minimum element size. 0
                                                means that there will be
                                                minimumal element size
                                                variation.  100 means that there
                                                will be maximum element size
                                                variation. */
    int tet_mesh_size_variation;             /* This controls whether the tets
                                                are permitted to expand as you
                                                progress into the interior of
                                                the body.  Valid values go from
                                                0 to 100.  0 means that
                                                element sizes must remain
                                                relatively constant.  100 means
                                                that the elements can expand
                                                very rapidly. */
    int multi_block_decomposition;           /* Attempt MultiBlock Decomposition 0=OFF,1=ON  */
    int mesh_transition;                     /* Mesh transition 0=OFF,1=ON  */
    int remesh_toggle;                       /* Avoid failing elements by reducing element size
                                                0=OFF,1=ON  */
    int create_pyramids;                     /* Create pyramid transition elements. Only for ANSYS 
                                                0=OFF,1=ON  */
    double                small_feature;                       /* % of element length for abstraction */
    int                   attempt_mapped_meshing;
    int                   two_element_through_thickness_toggle;
    int                   auto_fix_failed_elements_toggle;
    int                   edge_merge_toggle;                   /* Edge merge toggle 0 or 1 */
    double                edge_angle;                          /* Edge merge angle */
    int                   fillet_toggle;                       /* true => Filler detection ON
                                                                  false=> Fillet detection OFF */
    UF_SF_ugs_tet_mesh_fillet_type_option_t fillet_type;  /* Used only if fillet_toggle == true
                                                                  Fillet type */
    int                   fillet_num_elem;                     /* No of elements on a quarter arc of fillet */
    double                fillet_min_rad;                      /* Min radius */
    double                fillet_max_rad;  
};
typedef struct UF_SF_ugs_tet_mesh_parms_s UF_SF_ugs_tet_mesh_parms_t, *UF_SF_ugs_tet_mesh_parms_p_t;

#define UF_SF_ugs_tet_mesh_parms_INIT( mesh_parms )                            \
   {                                                                           \
    (mesh_parms)->element_type               = UF_SF_TET4;                     \
    (mesh_parms)->midnodes                   = TRUE;                           \
    (mesh_parms)->element_size               = -1.0;                          \
    (mesh_parms)->midnode_option             = UF_SF_UGS_MESHER_mixed_midnodes;\
    (mesh_parms)->maximum_midnode_jacobian   = 20.0;                           \
    (mesh_parms)->minimum_face_angle         = 20.0;                           \
    (mesh_parms)->surf_mesh_size_variation   = 0;                              \
    (mesh_parms)->tet_mesh_size_variation    = 0;                              \
    (mesh_parms)->mesh_transition            = 0;                              \
    (mesh_parms)->remesh_toggle              = 0;                              \
    (mesh_parms)->create_pyramids            = 0;                              \
    (mesh_parms)->small_feature              = 50.0;                           \
    (mesh_parms)->attempt_mapped_meshing     = true;                           \
    (mesh_parms)->two_element_through_thickness_toggle     = false;            \
    (mesh_parms)->auto_fix_failed_elements_toggle     = false;            \
    (mesh_parms)->edge_merge_toggle          = 0;                              \
    (mesh_parms)->edge_angle                 = 15.0;                           \
    (mesh_parms)->fillet_toggle              = false;                          \
    (mesh_parms)->fillet_type                = UF_SF_UGS_TET_MESH_FILLET__all; \
    (mesh_parms)->fillet_num_elem            = 4;                              \
    (mesh_parms)->fillet_min_rad             = 0.0;                            \
    (mesh_parms)->fillet_max_rad             = 0.0;                            \
   }

/***************************************************************************
 *   Enumeration:-UF_SF_ugs_abstraction_fillet_type_option_t
 *
 *   This enumeration allows the specification of fillet types to be
 *   considered during abstraction.
 *************************************************************************** */
enum UF_SF_ugs_abstraction_fillet_type_option_e
{
    UF_SF_UGS_ABSTRACTION_FILLET__all = 0,      /* Both concave as well as convex fillets */
    UF_SF_UGS_ABSTRACTION_FILLET__inside = 1,   /* Inside radius fillets. */
    UF_SF_UGS_ABSTRACTION_FILLET__outside = 2   /* Outside radius fillets */
};
typedef enum UF_SF_ugs_abstraction_fillet_type_option_e UF_SF_ugs_abstraction_fillet_type_option_t;

/* ================================================================
      Parameter settings for tet mesh with abstraction control
   ================================================================ */
struct UF_SF_ugs_mesh_abstraction_params_s
{
    double                small_feature;                       /* % of element length for abstraction */
    int                   edge_merge_toggle;                   /* Edge merge toggle 0 or 1 */
    double                edge_angle;                          /* Edge merge angle */
    int                   fillet_toggle;                       /* true => Filler detection ON
                                                                  false=> Fillet detection OFF */
    UF_SF_ugs_abstraction_fillet_type_option_t   fillet_type;  /* Used only if fillet_toggle == true
                                                                  Fillet type */
    int                   fillet_num_elem;                     /* No of elements on a quarter arc of fillet */
    double                fillet_min_rad;                      /* Min radius */
    double                fillet_max_rad;                      /* Max radius */
};
typedef struct UF_SF_ugs_mesh_abstraction_params_s UF_SF_ugs_mesh_abstraction_params_t, *UF_SF_ugs_mesh_abstraction_params_p_t;

/* Macro to initialize the parameters */
#define UF_SF_ugs_mesh_abstraction_parms_INIT( abs_parms )               \
   {                                                                     \
    (abs_parms)->small_feature     = 50.0;                               \
    (abs_parms)->edge_merge_toggle = 0;                                  \
    (abs_parms)->edge_angle        = 15.0;                               \
    (abs_parms)->fillet_toggle     = false;                              \
    (abs_parms)->fillet_type       = UF_SF_UGS_ABSTRACTION_FILLET__all;  \
    (abs_parms)->fillet_num_elem   = 4;                                  \
    (abs_parms)->fillet_min_rad    = 0.0;                                \
    (abs_parms)->fillet_max_rad    = 0.0;                                \
   }


/***************************************************************************
 *   Structure :- UF_SF_ugs_2d_mesh_parms_s
 *
 *   This structure allows specification of 2d shell meshing parameters.
 *
 *   Initialization :- This structure can be initialized with the
 *   UF_SF_ugs_2d_mesh_parms_INIT macro.
 *************************************************************************** */
struct UF_SF_ugs_2d_mesh_parms_s
{
    UF_SF_ugs_2d_mesher_elem_type_t element_type;
                                             /* Desired element type. */
    double element_size;                     /* Desired element size.  If
                                                zero or negative, then mesher
                                                will choose element size
                                                internally. */
    int edge_match_toggle;                    /* Edge merge toggle 0 or 1 */
    double edge_match_tolerance;             /* edge matching tolerance. */
    int suppress_hole_toggle;                /* Suppress Hole toggle 0 or 1 */
    double suppress_hole_diameter_value;     /* Suppress Hole Diameter value. */
    int suppress_hole_point_type;            /* 0- NONE, 1-POINT, 2-MESHPOINT */
    int target_minimum_element_edge_length;   /* Target Minimum Element Edge Length toggle 0 or 1 */
    int format_mesh;                         /* TRUE if 2d mesh is a shell
                                                mesh that should be formatted
                                                to the solver.  FALSE if 2d
                                                mesh is a seed mesh and not to
                                                be formated out to solver.  */
    int attempt_quad_mapping;                /* TRUE if map mesher should be
                                                tried on faces for quad meshes
                                                or if free mesher should be
                                                called regardless of face
                                                shape. */
    int quad_only_option;                     /* Applies only when attempt_quad_mapping=FALSE
                                                Values are:
                                                0 => Allow triangles OFF.
                                                1 => Allow triangles ON & 0 Triangle
                                                2 => Allow triangles ON & 1 Triangle 
                                                
                                                If attempt_quad_mapping==TRUE does not
                                                apply.*/

    int split_poor_quads;                    /* TRUE if poorly shaped quads
                                                should be split into
                                                triangles.
                                                FALSE if quads should be kept
                                                regardless of quality. */
    double maximum_quad_warp;                /* if split_poor_quads == TRUE,
                                                this is the warp quality
                                                threshold.  Any quad with
                                                greater warp than this will
                                                be split. */
    UF_SF_ugs_mesher_midnode_option_t midnode_option; /* Whether to project midnodes
                                                or not. */
    int geometry_tolerance_toggle;           /*Geometry Tolerance for midnode straightening*/
    double geometry_tolerance_value;         /*Geometry Tolerance value for midnode straightening*/

    double maximum_midnode_jacobian;         /* If midnode_option =
                                                UF_SF_UGS_MESHER_mixed_midnodes,
                                                any element with a jacobian
                                                value higher than
                                                maximum_midnode_jacobian will
                                                have its midnodes
                                                straightened. */
    double minimum_face_angle;               /* Minimum angle at corner of a
                                                face that can support element.
                                                corners smaller than this will
                                                be pinched out.  This angle is
                                                measured in degrees. */
    int surf_mesh_size_variation;           /* This controls how much variation
                                                in element size is
                                                desired/permitted in the mesh on
                                                the surface of the bodies being
                                                meshed. Valid values go from 0
                                                to 100.  This number does not
                                                coorespond directly to any
                                                actual meshing parameter, but
                                                rather is a relative scale that
                                                the user can use to indicate
                                                their tolerance for mesh
                                                variation.  It is used
                                                internally in the mesher to
                                                calculate expansion factors and
                                                a minimum element size.  0
                                                means that there will be
                                                minimumal element size
                                                variation.  100 means that there
                                                will be maximum element size
                                                variation. */
    double small_feature;                    /* % of element length for abstraction */   
    int edge_merge_toggle;                   /* Edge merge toggle 0 or 1 */
    double edge_angle;                       /* Edge merge angle */
    int mesh_transition;                     /* Mesh transition 0=OFF,1=ON  */
    int multi_block_decomposition;           /* Attempt MultiBlock Decomposition 0=OFF,1=ON  */
    int mesh_individual_faces;               /* Mesh Individual Faces 0=OFF,1=ON */
    int CAD_curvature_abstraction;           /* CAD Curvature Abstraction 0=OFF,1=ON */
    double minimum_feature_length;      /* Desired element size.  If
                                                zero or negative, then mesher
                                                will choose element size
                                                internally. */
    int mesh_method;                         /* 0 - Automatic, 1 - Paver */
    int                   fillet_toggle;                       /* true => Filler detection ON
                                                                  false=> Fillet detection OFF */
    UF_SF_ugs_abstraction_fillet_type_option_t   fillet_type;  /* Used only if fillet_toggle == true
                                                                  Fillet type */
    int                   fillet_num_elem;                     /* No of elements on a quarter arc of fillet */
    double                fillet_min_rad;                      /* Min radius */
    double                fillet_max_rad;                      /* Max radius */

    int       max_included_angle_quad_toggle;       /* Max Angle for quad Toggle state */

    int       min_included_angle_quad_toggle;       /* Min Angle for quad Toggle state */

    int       max_included_angle_tria_toggle;       /* Max Angle for tria Toggle state */

    int       min_included_angle_tria_toggle;       /* Min Angle for tria Toggle state */

    double    max_included_angle_quad_value;       /* Max Angle for quad value */

    double    min_included_angle_quad_value;       /* Min Angle for quad value */

    double    max_included_angle_tria_value;       /* Max Angle for tria value */

    double     min_included_angle_tria_value;       /* Min Angle for tria value */

    int        move_nodes_off_geometry;            /*Move Nodes Off Geometry*/

    int        max_warp_toggle;
};
typedef struct UF_SF_ugs_2d_mesh_parms_s UF_SF_ugs_2d_mesh_parms_t, *UF_SF_ugs_2d_mesh_parms_p_t;

#define UF_SF_ugs_2d_mesh_parms_INIT( mesh_parms )                             \
{                                                                              \
    (mesh_parms)->element_type               = UF_SF_UGS_MESHER_quad4;         \
    (mesh_parms)->element_size               = -1.0;                           \
    (mesh_parms)->edge_match_toggle          = 0;                              \
    (mesh_parms)->edge_match_tolerance       = 0.508;                          \
    (mesh_parms)->format_mesh                = TRUE;                           \
    (mesh_parms)->attempt_quad_mapping       = TRUE;                           \
    (mesh_parms)->split_poor_quads           = TRUE;                           \
    (mesh_parms)->maximum_quad_warp          = 10.0;                           \
    (mesh_parms)->midnode_option             = UF_SF_UGS_MESHER_mixed_midnodes;\
    (mesh_parms)->maximum_midnode_jacobian   = 5.0;                            \
    (mesh_parms)->minimum_face_angle         = 20.0;                           \
    (mesh_parms)->surf_mesh_size_variation   = 0;                              \
    (mesh_parms)->mesh_transition            = 0;                              \
    (mesh_parms)->mesh_method                = 0;                              \
    (mesh_parms)->quad_only_option           = 0;                              \
    (mesh_parms)->edge_merge_toggle          = 0;                              \
    (mesh_parms)->edge_angle                 = 15.0;                           \
    (mesh_parms)->small_feature              = 50.0;                           \
    (mesh_parms)->fillet_toggle     = false;                                   \
    (mesh_parms)->fillet_type       = UF_SF_UGS_ABSTRACTION_FILLET__all;       \
    (mesh_parms)->fillet_num_elem   = 4;                                       \
    (mesh_parms)->fillet_min_rad    = 0.0;                                     \
    (mesh_parms)->fillet_max_rad    = 0.0;                                     \
    (mesh_parms)->max_included_angle_quad_toggle = false;                      \
    (mesh_parms)->min_included_angle_quad_toggle = false;                      \
    (mesh_parms)->max_included_angle_tria_toggle = false;                      \
    (mesh_parms)->min_included_angle_tria_toggle = false;                      \
    (mesh_parms)->max_included_angle_quad_value = 150.0;                       \
    (mesh_parms)->min_included_angle_quad_value = 30.0;                        \
    (mesh_parms)->max_included_angle_tria_value = 140.0;                       \
    (mesh_parms)->min_included_angle_tria_value = 20.0;                        \
}


/***************************************************************************
 *   Structure :- UF_SF_ugs_solid_from_shell_mesh_parms_s
 *
 *   This structure allows specification of solid from shell meshing parameters.
 *
 *   Initialization :- This structure can be initialized with the
 *   UF_SF_ugs_solid_from_shell_mesh_parms_INIT macro.
 *************************************************************************** */
struct UF_SF_ugs_solid_from_shell_mesh_parms_s
{
    int midnodes;                            /* TRUE for tet10s,
                                                FALSE for tet4s. */
    int tet_mesh_size_variation;             /* This controls whether the tets
                                                are permitted to expand as you
                                                progress into the interior of
                                                the body.  Valid values go from
                                                0 to 100.  0 means that
                                                element sizes must remain
                                                relatively constant.  100 means
                                                that the elements can expand
                                                very rapidly. */
    int fill_holes;                           /* TRUE if the interior holes
                                                should be filled */
};
typedef struct UF_SF_ugs_solid_from_shell_mesh_parms_s UF_SF_ugs_solid_from_shell_mesh_parms_t, *UF_SF_ugs_solid_from_shell_mesh_parms_p_t;

#define UF_SF_ugs_solid_from_shell_mesh_parms_INIT( mesh_parms )                \
   {                                                                            \
    (mesh_parms)->midnodes                   = FALSE;                           \
    (mesh_parms)->tet_mesh_size_variation    = 0;                               \
    (mesh_parms)->fill_holes                 = FALSE;                           \
   }


#ifdef __cplusplus
}
#endif

#endif  /* UF_SF_COMPOSITE_H_INCLUDED  */
