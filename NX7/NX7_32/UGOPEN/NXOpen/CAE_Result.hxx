#ifndef NXOpen_CAE_RESULT_HXX_INCLUDED
#define NXOpen_CAE_RESULT_HXX_INCLUDED
//--------------------------------------------------------------------------
//  Header for C++ interface to JA API
//--------------------------------------------------------------------------
//
//  Source File:
//     CAE_Result.ja
//
//  Generated by:
//     apiwrap
//
//  WARNING:
//    This file is automatically generated - do not edit by hand
//
#include <vector>
#include <NXOpen/NXString.hxx>
#include <NXOpen/Callback.hxx>
#include <NXOpen/CAE_ElementTypes.hxx>
#include <NXOpen/TaggedObject.hxx>
#include <NXOpen/ugmath.hxx>
#include <NXOpen/libnxopencpp_exports.hxx>
namespace NXOpen
{
    namespace CAE
    {
        class Result;
    }
    class Unit;
    namespace CAE
    {
        class _ResultBuilder;
        /** 
             <br>   
            This class provides interfaces to query analysis results.  
            <br/>To query results you must first understand how the results are structured.  The basic structure is as follows
            <ul>
                <li>Load case</li>
                <ul>
                    <li>Iteration</li>
                    <ul>
                        <li>Result Type</li>
                    </ul>
                </ul>  
            </ul>
            
            
            <br/>Results are divided into Load Cases(loadcase). Loadcase is a general term which could representand of the follow based on solution type
            <ul>
            <li>Solution Steps</li>
            <li>Modes</li>
            <li>Frequencies</li>
            <li>etc</li>
            </ul>

            The number of Loadcases can be obtained by using @link CAE::Result::AskNumLoadcases CAE::Result::AskNumLoadcases@endlink . When querying information for a loadcase you will use the loadcase index ( 0 to n-1 ), where n is the number of loadcases.
            Each Loadcase is divided into multiple iterations, although for many results there will be only 1 iteration.  Based on solution type, these iterations could represent
            <ul>
            <li>Time Steps</li>
            <li>Cycles</li>
            <li>Solver iterations</li>
            <li>etc</li>
            </ul>   
            The number of iterations for a given loadcase can be obtained by using @link CAE::Result::AskNumIterations CAE::Result::AskNumIterations@endlink  and specify the loadcase index.
            When querying information for a specific iteration, you will use both the loadcase and iteration index.  
            Within an iteration query all the available Result types using  @link CAE::Result::AskResultTypes CAE::Result::AskResultTypes@endlink  
             <br>   
            
             <br>   
            A Result type is defined by three parameters
            <ol>
                <li>@link CAE::Result::Quantity CAE::Result::Quantity@endlink  - It specifies physical quantity of the result like Displacement, Stress etc. </li>
                <li>@link CAE::Result::Location CAE::Result::Location@endlink  - It specifies where the result is defined like Nodal, Elemental, or Element Nodal </li>
                <li>@link CAE::Result::Section  CAE::Result::Section @endlink  - It specifies on which section or gauss point the result is calculated  </li>
            </ol>
             <br>   
            
             <br> 
            The Results object also contains information on the finite element model for which results may be accessed.   The number of nodes in this results model can be obtained by using  @link CAE::Result::AskNumNodes CAE::Result::AskNumNodes@endlink . The number of elements in this results model can be obtained by using @link CAE::Result::AskNumElements CAE::Result::AskNumElements@endlink .  Elements are also organized in several groups (of type @link CAE::Result::GroupContainer  CAE::Result::GroupContainer @endlink ) based
            on the element type, material and physical property. One can query the number of each group type and its content.
             <br>   
             <br>   
            Nodes and Elements in result the file are addressed by their index which varies from 1 to number of nodes/elements.
            Node and Element can have a user label associated with it. User labels are unique and have one to one mapping with its index.
             <br>   

             <br> An instance of this class can not be obtained <br> */
        class NXOPENCPPEXPORT Result : public TaggedObject
        {
            /** Group Containers */
            public: enum GroupContainer
            {
                GroupContainerZeroDimensional/** zero dimensional */ ,
                GroupContainerOneDimensional/** one dimensional */ ,
                GroupContainerTwoDimensional/** two dimensional */ ,
                GroupContainerThreeDimensional/** three dimensional */ ,
                GroupContainerConnector/** connector */ ,
                GroupContainerOther/** other */ 
            };

            /** Result quantities */
            public: enum Quantity
            {
                QuantityDisplacement/** displacement */ ,
                QuantityRotation/** rotation */ ,
                QuantityContactDisplacement/** contact displacement */ ,
                QuantityVelocity/** velocity */ ,
                QuantityAngularVelocity/** angular velocity */ ,
                QuantityAcceleration/** acceleration */ ,
                QuantityAngularAcceleration/** angular acceleration */ ,
                QuantityVonMisesStress/** von mises stress */ ,
                QuantityVonMisesStrain/** von mises strain */ ,
                QuantityStress/** stress */ ,
                QuantityStrain/** strain */ ,
                QuantityStrainEnergy/** strain energy */ ,
                QuantityStrainEnergyDensity/** strain energy density */ ,
                QuantityStrainEnergyError/** strain energy error */ ,
                QuantityEquivalentPlasticStrain/** equivalent plastic strain */ ,
                QuantityEquivalentCreepStrain/** equivalent creep strain */ ,
                QuantityKineticEnergy/** kinetic energy */ ,
                QuantityKineticEnergyDensity/** kinetic energy density */ ,
                QuantityKineticEnergyPercent/** kinetic energy percent */ ,
                QuantityThickness/** thickness */ ,
                QuantityTemperature/** temperature */ ,
                QuantityTemperatureGradient/** temperature gradient */ ,
                QuantityHeatFlux/** heat flux */ ,
                QuantityThermalEnergy/** thermal energy */ ,
                QuantityHeatFlow/** heat flow */ ,
                QuantityAppliedForce/** applied force */ ,
                QuantityAppliedMoment/** applied moment */ ,
                QuantityReactionForce/** reaction force */ ,
                QuantityReactionMoment/** reaction moment */ ,
                QuantityReactionForceMPC/** reaction force mpc */ ,
                QuantityReactionMomentMPC/** reaction moment mpc */ ,
                QuantityContactTraction/** contact traction */ ,
                QuantityContactForce/** contact force */ ,
                QuantityElementForce/** element force */ ,
                QuantityElementMoment/** element moment */ ,
                QuantityContactPressure/** contact pressure */ ,
                QuantityFatigueLife/** fatigue life */ ,
                QuantityFatigueDamage/** fatigue damage */ ,
                QuantityFatigueSafetyFactor/** fatigue safety factor */ ,
                QuantityStrengthSafetyFactor/** strength safety factor */ ,
                QuantityElementError/** element error */ ,
                QuantityElementResultants/** element resultants */ ,
                QuantityElementStrainResultants/** element strain resultants */ ,
                QuantityMaximumTemperature/** maximum temperature */ ,
                QuantityMinimumTemperature/** minimum temperature */ ,
                QuantityTimeAtMaximumTemperature/** time at maximum temperature */ ,
                QuantityTimeAtMinimumTemperature/** time at minimum temperature */ ,
                QuantityConductiveFlux/** conductive flux */ ,
                QuantityTotalHeatLoad/** total heat load */ ,
                QuantityTotalHeatFlux/** total heat flux */ ,
                QuantityHeatResidual/** heat residual */ ,
                QuantityConvectionCoefficient/** convection coefficient */ ,
                QuantityViewFactorsSum/** view factors sum */ ,
                QuantityAdjustedVelocity/** adjusted velocity */ ,
                QuantityPressureOnPositiveSide/** pressure on positive side */ ,
                QuantityPressureOnNegativeSide/** pressure on negative side */ ,
                QuantityStaticPressure/** static pressure */ ,
                QuantityTotalPressure/** total pressure */ ,
                QuantityTurbulenceEnergy/** turbulence energy */ ,
                QuantityTurbulenceDissipation/** turbulence dissipation */ ,
                QuantityFluidDensity/** fluid density */ ,
                QuantityShearStressOnPositiveSide/** shear stress on positive side */ ,
                QuantityShearStressOnNegativeSide/** shear stress on negative side */ ,
                QuantityRoughnessOnPositiveSide/** roughness on positive side */ ,
                QuantityRoughnessOnNegativeSide/** roughness on negative side */ ,
                QuantityYPlusOnPositiveSide/** yplus on positive side */ ,
                QuantityYPlusOnNegativeSide/** yplus on negative side */ ,
                QuantityMassFlux/** mass flux */ ,
                QuantityFluidTemperature/** fluid temperature */ ,
                QuantityConvectiveFlux/** convective flux */ ,
                QuantityLocalConvectionCoefficient/** local convection coefficient */ ,
                QuantityBulkConvectionCoefficient/** bulk convection coefficient */ ,
                QuantityPressure/** pressure */ ,
                QuantityVelocityComponent/** velocity component */ ,
                QuantityMassFlow/** mass flow */ ,
                QuantityElementHeatLoad/** element heat load */ ,
                QuantitySafetyFactor/** safety factor */ ,
                QuantityShellResultants/** shell resultants */ ,
                QuantityBeamResultants/** beam resultants */ ,
                QuantitySpringDashpotResultant/** spring dashpot resultant */ ,
                QuantityShellStrainResultants/** shell strain resultants */ ,
                QuantityBeamStrainResultants/** beam strain resultants */ ,
                QuantitySpringDashpotStrainResultant/** spring dashpot strain resultant */ ,
                QuantityPlyFailureIndex/** ply failure index */ ,
                QuantityBondFailureIndex/** bond failure index */ ,
                QuantityPlyStress/** ply stress */ ,
                QuantityPlyStrain/** ply strain */ ,
                QuantityBondSafetyMargin/** bond safety margin */ ,
                QuantityPlySafetyMargin/** ply safety margin */ ,
                QuantityTorsionStress/** torsion stress */ ,
                QuantityGridPointForce/** grid point force */ ,
                QuantityGridPointMoment/** grid point moment */ ,
                QuantityRadiativeSourceHeatFlux/** radiative source heat flux */ ,
                QuantityRadiance/** radiance */ ,
                QuantityApparentTemperature/** apparent temperature */ ,
                QuantityFluence/** fluence */ ,
                QuantityRCProduct/** rcproduct */ ,
                QuantityVoltage/** voltage */ ,
                QuantityPowerDensity/** power density */ ,
                QuantityRelativeVelocity/** relative velocity */ ,
                QuantityWaterCumulation/** water cumulation */ ,
                QuantityTurbulentSpecificDissipation/** turbulent specific dissipation */ ,
                QuantityRadiativeHeatFlux/** radiative heat flux */ ,
                QuantityCollimatedHeatFlux/** collimated heat flux */ ,
                QuantityDiffuseHeatFlux/** diffuse heat flux */ ,
                QuantityInfraredHeatFlux/** infrared heat flux */ ,
                QuantityViewFactor/** view factor */ ,
                QuantityUnknown/** unknown */ ,
                QuantityMappedTemperature/** mapped temperature */ ,
                QuantityMappedTemperatureGradient/** mapped temperature gradient */ ,
                QuantityRadiativeAbsorbedHeatFlux/** radiative absorbed heat flux */ ,
                QuantityRadiativeIncidentHeatFlux/** radiative incident heat flux */ ,
                QuantityRadiativeReflectedHeatFlux/** radiative reflected heat flux */ ,
                QuantityRadiativeTransmittedHeatFlux/** radiative transmitted heat flux */ ,
                QuantityCollimatedAbsorbedHeatFlux/** collimated absorbed heat flux */ ,
                QuantityCollimatedIncidentHeatFlux/** collimated incident heat flux */ ,
                QuantityCollimatedReflectedHeatFlux/** collimated reflected heat flux */ ,
                QuantityCollimatedTransmittedHeatFlux/** collimated transmitted heat flux */ ,
                QuantityDiffuseAbsorbedHeatFlux/** diffuse absorbed heat flux */ ,
                QuantityDiffuseIncidentHeatFlux/** diffuse incident heat flux */ ,
                QuantityDiffuseReflectedHeatFlux/** diffuse reflected heat flux */ ,
                QuantityDiffuseTransmittedHeatFlux/** diffuse transmitted heat flux */ ,
                QuantityInfraredAbsorbedHeatFlux/** infrared absorbed heat flux */ ,
                QuantityInfraredIncidentHeatFlux/** infrared incident heat flux */ ,
                QuantityInfraredReflectedHeatFlux/** infrared reflected heat flux */ ,
                QuantityInfraredTransmittedHeatFlux/** infrared transmitted heat flux */ ,
                QuantityAlbedoViewFactor/** albedo view factor */ ,
                QuantityEarthViewFactor/** earth view factor */ ,
                QuantitySolarViewFactor/** solar view factor */ ,
                QuantitySpaceViewFactor/** space view factor */ ,
                QuantityQuality/** quality */ ,
                QuantityRadiationPatch/** radiation patch */ ,
                QuantityAbsorbedRadiation/** absorbed radiation */ ,
                QuantityIncidentRadiation/** incident radiation */ ,
                QuantityReflectedRadiation/** reflected radiation */ ,
                QuantityTransmittedRadiation/** transmitted radiation */ ,
                QuantityRefractiveIndex/** refractive index */ ,
                QuantityRefractiveIndexGradient/** refractive index gradient */ ,
                QuantityOpticalPathLength/** optical path length */ ,
                QuantityLaserPower/** laser power */ ,
                QuantityPumpingPower/** pumping power */ ,
                QuantityRadiativeFluxinSolid/** radiative fluxin solid */ ,
                QuantityFluidScalar/** fluid scalar */ ,
                QuantityWallDistance/** wall distance */ ,
                QuantityRelativeHumidity/** relative humidity */ ,
                QuantitySpecificHumidity/** specific humidity */ ,
                QuantityMachNumber/** mach number */ ,
                QuantityPredictedPercentDissatisfied/** predicted percent dissatisfied */ ,
                QuantityPercentMeanVote/** percent mean vote */ ,
                QuantityVorticity/** vorticity */ ,
                QuantityRelativePressure/** relative pressure */ ,
                QuantityAbsolutePressure/** absolute pressure */ ,
                QuantityElementAspectRatio/** element aspect ratio */ ,
                QuantityElementDistortion/** element distortion */ ,
                QuantityElementTaper/** element taper */ ,
                QuantityElementSize/** element size */ ,
                QuantityElementJacobian/** element jacobian */ ,
                QuantityElementSkew/** element skew */ ,
                QuantityElementStretch/** element stretch */ ,
                QuantityElementTwist/** element twist */ ,
                QuantityElementWarp/** element warp */ ,
                QuantityFluidMesh/** fluid mesh */ ,
                QuantityNetRadiativeLoad/** net radiative load */ ,
                QuantityNetRadiativeFlux/** net radiative flux */ ,
                QuantityRadiosityLoad/** radiosity load */ ,
                QuantityRadiosityFlux/** radiosity flux */ ,
                QuantityIrradianceLoad/** irradiance load */ ,
                QuantityIrradianceFlux/** irradiance flux */ ,
                QuantityParticleDensity/** particle density */ ,
                QuantityParticleMassDensity/** particle mass density */ ,
                QuantityAcousticPowerDensity/** acoustic power density */ ,
                QuantityReynoldsNumber/** reynolds number */ ,
                QuantityBondStrengthRatio/** bond strength ratio */ ,
                QuantityPlyStrengthRatio/** ply strength ratio */ ,
                QuantityFailureIndex/** failure index */ ,
                QuantityContactInitialSeparation/** contact initial separation */ ,
                QuantityContactFinalSeparation/** contact final separation */ ,
                QuantityGasketPressue/** gasket pressue */ ,
                QuantityGasketClosure/** gasket closure */ ,
                QuantityGasketPlasticClosure/** gasket plastic closure */ ,
                QuantityGasketStressYield/** gasket stress yield */ ,
                QuantityGasketStatus/** gasket status */ ,
                QuantityContactPenetration/** contact penetration */ ,
                QuantityContactStatus/** contact status */ ,
                QuantityContactGapDistance/** contact gap distance */ ,
                QuantityStressLevelCrossingRate/** stress level crossing rate */ ,
                QuantityVonMisesStressLevelCrossingRate/** von mises stress level crossing rate */ ,
                QuantityVonMisesStrainLevelCrossingRate/** von mises strain level crossing rate */ ,
                QuantityDisplacementLevelCrossingRate/** displacement level crossing rate */ ,
                QuantityRotationLevelCrossingRate/** rotation level crossing rate */ ,
                QuantityVelocityLevelCrossingRate/** velocity level crossing rate */ ,
                QuantityAngularVelocityLevelCrossingRate/** angular velocity level crossing rate */ ,
                QuantityAccelerationLevelCrossingRate/** acceleration level crossing rate */ ,
                QuantityAngularAccelerationLevelCrossingRate/** angular acceleration level crossing rate */ ,
                QuantityElementForceLevelCrossingRate/** element force level crossing rate */ ,
                QuantityElementMomentLevelCrossingRate/** element moment level crossing rate */ ,
                QuantityElementResultantsLevelCrossingRate/** element resultants level crossing rate */ ,
                QuantityShellResultantsLevelCrossingRate/** shell resultants level crossing rate */ ,
                QuantityBeamResultantsLevelCrossingRate/** beam resultants level crossing rate */ ,
                QuantitySpringDashpotResultantsLevelCrossingRate/** spring dashpot resultants level crossing rate */ ,
                QuantityElementStrainResultantsLevelCrossingRate/** element strain resultants level crossing rate */ ,
                QuantityShellStrainResultantsLevelCrossingRate/** shell strain resultants level crossing rate */ ,
                QuantityBeamStrainResultantsLevelCrossingRate/** beam strain resultants level crossing rate */ ,
                QuantitySpringDashpotStrainResultantsLevelCrossingRate/** spring dashpot strain resultants level crossing rate */ ,
                QuantityXDisplacement/** xdisplacement */ ,
                QuantityYDisplacement/** ydisplacement */ ,
                QuantityZDisplacement/** zdisplacement */ ,
                QuantityLevelCrossingRateXDisplacement/** level crossing rate xdisplacement */ ,
                QuantityLevelCrossingRateYDisplacement/** level crossing rate ydisplacement */ ,
                QuantityLevelCrossingRateZDisplacement/** level crossing rate zdisplacement */ ,
                QuantityXRotation/** xrotation */ ,
                QuantityYRotation/** yrotation */ ,
                QuantityZRotation/** zrotation */ ,
                QuantityLevelCrossingRateXRotation/** level crossing rate xrotation */ ,
                QuantityLevelCrossingRateYRotation/** level crossing rate yrotation */ ,
                QuantityLevelCrossingRateZRotation/** level crossing rate zrotation */ ,
                QuantityXAcceleration/** xacceleration */ ,
                QuantityYAcceleration/** yacceleration */ ,
                QuantityZAcceleration/** zacceleration */ ,
                QuantityLevelCrossingRateXAcceleration/** level crossing rate xacceleration */ ,
                QuantityLevelCrossingRateYAcceleration/** level crossing rate yacceleration */ ,
                QuantityLevelCrossingRateZAcceleration/** level crossing rate zacceleration */ ,
                QuantityXAngularAcceleration/** xangular acceleration */ ,
                QuantityYAngularAcceleration/** yangular acceleration */ ,
                QuantityZAngularAcceleration/** zangular acceleration */ ,
                QuantityLevelCrossingRateXAngularAcceleration/** level crossing rate xangular acceleration */ ,
                QuantityLevelCrossingRateYAngularAcceleration/** level crossing rate yangular acceleration */ ,
                QuantityLevelCrossingRateZAngularAcceleration/** level crossing rate zangular acceleration */ ,
                QuantityXXStress/** xxstress */ ,
                QuantityYYStress/** yystress */ ,
                QuantityZZStress/** zzstress */ ,
                QuantityXYStress/** xystress */ ,
                QuantityYZStress/** yzstress */ ,
                QuantityZXStress/** zxstress */ ,
                QuantityLevelCrossingRateXXStress/** level crossing rate xxstress */ ,
                QuantityLevelCrossingRateYYStress/** level crossing rate yystress */ ,
                QuantityLevelCrossingRateZZStress/** level crossing rate zzstress */ ,
                QuantityLevelCrossingRateXYStress/** level crossing rate xystress */ ,
                QuantityLevelCrossingRateYZStress/** level crossing rate yzstress */ ,
                QuantityLevelCrossingRateZXStress/** level crossing rate zxstress */ ,
                QuantityXElementForce/** xelement force */ ,
                QuantityYElementForce/** yelement force */ ,
                QuantityZElementForce/** zelement force */ ,
                QuantityLevelCrossingRateXElementForce/** level crossing rate xelement force */ ,
                QuantityLevelCrossingRateYElementForce/** level crossing rate yelement force */ ,
                QuantityLevelCrossingRateZElementForce/** level crossing rate zelement force */ ,
                QuantityNXXShellResultant/** nxxshell resultant */ ,
                QuantityNYYShellResultant/** nyyshell resultant */ ,
                QuantityNXYShellResultant/** nxyshell resultant */ ,
                QuantityMXXShellResultant/** mxxshell resultant */ ,
                QuantityMYYShellResultant/** myyshell resultant */ ,
                QuantityMXYShellResultant/** mxyshell resultant */ ,
                QuantityQXZShellResultant/** qxzshell resultant */ ,
                QuantityQYZShellResultant/** qyzshell resultant */ ,
                QuantityLevelCrossingRateNXXShellResultant/** level crossing rate nxxshell resultant */ ,
                QuantityLevelCrossingRateNYYShellResultant/** level crossing rate nyyshell resultant */ ,
                QuantityLevelCrossingRateNXYShellResultant/** level crossing rate nxyshell resultant */ ,
                QuantityLevelCrossingRateMXXShellResultant/** level crossing rate mxxshell resultant */ ,
                QuantityLevelCrossingRateMYYShellResultant/** level crossing rate myyshell resultant */ ,
                QuantityLevelCrossingRateMXYShellResultant/** level crossing rate mxyshell resultant */ ,
                QuantityLevelCrossingRateQXZShellResultant/** level crossing rate qxzshell resultant */ ,
                QuantityLevelCrossingRateQYZShellResultant/** level crossing rate qyzshell resultant */ ,
                QuantityRXElementForce/** rxelement force */ ,
                QuantityRYElementForce/** ryelement force */ ,
                QuantityRZElementForce/** rzelement force */ ,
                QuantityLevelCrossingRateRXElementForce/** level crossing rate rxelement force */ ,
                QuantityLevelCrossingRateRYElementForce/** level crossing rate ryelement force */ ,
                QuantityLevelCrossingRateRZElementForce/** level crossing rate rzelement force */ 
            };

            /** Result locations */
            public: enum Location
            {
                LocationNodal/** nodal */ ,
                LocationElement/** element */ ,
                LocationElementNodal/** element nodal */ 
            };

            /** Result sections */
            public: enum Section
            {
                SectionNotApplicable/** not applicable */ ,
                SectionTop/** top */ ,
                SectionMiddle/** middle */ ,
                SectionBottom/** bottom */ ,
                SectionMinimum/** minimum */ ,
                SectionMaximum/** maximum */ ,
                SectionStressRecoveryPointC/** stress recovery point c */ ,
                SectionStressRecoveryPointD/** stress recovery point d */ ,
                SectionStressRecoveryPointE/** stress recovery point e */ ,
                SectionStressRecoveryPointF/** stress recovery point f */ ,
                SectionAll/** all */ 
            };

            /** Result data types */
            public: enum DataType
            {
                DataTypeScalar/** scalar */ ,
                DataTypeVector/** vector */ ,
                DataTypeSixVector/** six vector */ ,
                DataTypeTensor/** tensor */ ,
                DataTypeElementResultantShell/** element resultant shell */ ,
                DataTypeElementResultantBeam/** element resultant beam */ ,
                DataTypeElementResultantSpringDashpot/** element resultant spring dashpot */ 
            };

            /** Result components */
            public: enum Component
            {
                ComponentScalar/** scalar */ ,
                ComponentX/** x */ ,
                ComponentY/** y */ ,
                ComponentZ/** z */ ,
                ComponentMagnitude/** magnitude */ ,
                ComponentXx/** xx */ ,
                ComponentYy/** yy */ ,
                ComponentZz/** zz */ ,
                ComponentXy/** xy */ ,
                ComponentYz/** yz */ ,
                ComponentZx/** zx */ ,
                ComponentDeterminant/** determinant */ ,
                ComponentMean/** mean */ ,
                ComponentMaximumShear/** maximum shear */ ,
                ComponentMinimumPrincipal/** minimum principal */ ,
                ComponentMiddlePrincipal/** middle principal */ ,
                ComponentMaximumPrincipal/** maximum principal */ ,
                ComponentOctahedral/** octahedral */ ,
                ComponentVonMises/** von mises */ ,
                ComponentMembraneXX/** membrane xx */ ,
                ComponentMembraneYY/** membrane yy */ ,
                ComponentMembraneXY/** membrane xy */ ,
                ComponentBendingXX/** bending xx */ ,
                ComponentBendingYY/** bending yy */ ,
                ComponentBendingXY/** bending xy */ ,
                ComponentShearYZ/** shear yz */ ,
                ComponentShearXZ/** shear xz */ ,
                ComponentAxial/** axial */ ,
                ComponentBendingS/** bending s */ ,
                ComponentBendingT/** bending t */ ,
                ComponentTorsion/** torsion */ ,
                ComponentShearS/** shear s */ ,
                ComponentShearT/** shear t */ ,
                ComponentSpringDashpotForce/** spring dashpot force */ 
            };

            /** Complex options */
            public: enum Complex
            {
                ComplexReal/** real */ ,
                ComplexImaginary/** imaginary */ ,
                ComplexAmplitude/** amplitude */ ,
                ComplexSignedAmplitude/** signed amplitude */ ,
                ComplexPhaseAngle/** phase angle */ 
            };

            /** Coordinate systems */
            public: enum CoordinateSystem
            {
                CoordinateSystemAbsoluteRectangular/** absolute rectangular */ ,
                CoordinateSystemAbsoluteCylindrical/** absolute cylindrical */ ,
                CoordinateSystemAbsoluteSpherical/** absolute spherical */ ,
                CoordinateSystemWorkRectangular/** work rectangular */ ,
                CoordinateSystemWorkCylindrical/** work cylindrical */ ,
                CoordinateSystemWorkSpherical/** work spherical */ ,
                CoordinateSystemLocal/** local */ 
            };

            /** Element-value criterions */
            public: enum ElementValueCriterion
            {
                ElementValueCriterionAverage/** average */ ,
                ElementValueCriterionCentroid/** centroid */ ,
                ElementValueCriterionMaximum/** maximum */ ,
                ElementValueCriterionMinimum/** minimum */ 
            };

            /** Deformation scales */
            public: enum DeformationScale
            {
                DeformationScaleModel/** model */ ,
                DeformationScaleAbsolute/** absolute */ 
            };

             /** Result type structure to specify a result dataset */
            public:
            struct Type
            {
                public: /** quantity */ NXOpen::CAE::Result::Quantity Quantity;
                public: /** location */ NXOpen::CAE::Result::Location Location;
                public: /** section */ NXOpen::CAE::Result::Section Section;
                public: Type() :
                    Quantity((NXOpen::CAE::Result::Quantity)0),
                    Location((NXOpen::CAE::Result::Location)0),
                    Section((NXOpen::CAE::Result::Section)0)
                {
                }
                /** Constructor for the Type struct. */ 
                public: Type(NXOpen::CAE::Result::Quantity INIT_quantity /** quantity */ , 
                        NXOpen::CAE::Result::Location INIT_location /** location */ , 
                        NXOpen::CAE::Result::Section INIT_section /** section */ ) :
                    Quantity(INIT_quantity),
                    Location(INIT_location),
                    Section(INIT_section)
                {
                }
            };

            /** Value type for result load case */
            public: enum LoadcaseValueType
            {
                LoadcaseValueTypeUnknown = -1/**Unknown Value type */,
                LoadcaseValueTypeFrequency/**Value type - Frequency */,
                LoadcaseValueTypeLoadFactor/**Value type - Load Factor */,
                LoadcaseValueTypeNodeDOF/**Value type - Node DOF */,
                LoadcaseValueTypeLoadCase/**Value type - Load Case */,
                LoadcaseValueTypeTime/**Value type - Time */
            };

             /** Averaging structure to specify averaging options */
            public:
            struct Averaging
            {
                public: /** do averaging */ bool DoAveraging;
                public: /** average across property ids */ bool AverageAcrossPropertyIds;
                public: /** average across material ids */ bool AverageAcrossMaterialIds;
                public: /** average across element types */ bool AverageAcrossElementTypes;
                public: /** average across featangle */ bool AverageAcrossFeatangle;
                public: /** average across anglevalue */ double AverageAcrossAnglevalue;
                public: /** include internal element contributions */ bool IncludeInternalElementContributions;
                public: Averaging() :
                    DoAveraging(),
                    AverageAcrossPropertyIds(),
                    AverageAcrossMaterialIds(),
                    AverageAcrossElementTypes(),
                    AverageAcrossFeatangle(),
                    AverageAcrossAnglevalue(),
                    IncludeInternalElementContributions()
                {
                }
                /** Constructor for the Averaging struct. */ 
                public: Averaging(bool INIT_do_averaging /** do averaging */ , 
                        bool INIT_average_across_property_ids /** average across property ids */ , 
                        bool INIT_average_across_material_ids /** average across material ids */ , 
                        bool INIT_average_across_element_types /** average across element types */ , 
                        bool INIT_average_across_featangle /** average across featangle */ , 
                        double INIT_average_across_anglevalue /** average across anglevalue */ , 
                        bool INIT_include_internal_element_contributions /** include internal element contributions */ ) :
                    DoAveraging(INIT_do_averaging),
                    AverageAcrossPropertyIds(INIT_average_across_property_ids),
                    AverageAcrossMaterialIds(INIT_average_across_material_ids),
                    AverageAcrossElementTypes(INIT_average_across_element_types),
                    AverageAcrossFeatangle(INIT_average_across_featangle),
                    AverageAcrossAnglevalue(INIT_average_across_anglevalue),
                    IncludeInternalElementContributions(INIT_include_internal_element_contributions)
                {
                }
            };

             /** Element-value structure to specify element value options */
            public:
            struct ElementValue
            {
                public: /** do element value */ bool DoElementValue;
                public: /** criterion */ NXOpen::CAE::Result::ElementValueCriterion Criterion;
                public: ElementValue() :
                    DoElementValue(),
                    Criterion((NXOpen::CAE::Result::ElementValueCriterion)0)
                {
                }
                /** Constructor for the ElementValue struct. */ 
                public: ElementValue(bool INIT_do_element_value /** do element value */ , 
                        NXOpen::CAE::Result::ElementValueCriterion INIT_criterion /** criterion */ ) :
                    DoElementValue(INIT_do_element_value),
                    Criterion(INIT_criterion)
                {
                }
            };

             /** Result parameter structure to specify complete result state for the color display */
            public:
            struct ResultParameters
            {
                public: /** load case number starting from 0 */int LoadCaseIndex;
                public: /** iteration number starting from 0 */int IterationIndex;
                public: /** type */ NXOpen::CAE::Result::Type Type;
                public: /** component */ NXOpen::CAE::Result::Component Component;
                public: /** section */ int Section;
                public: /** plynumber */ int Plynumber;
                public: /** layer */ int Layer;
                public: /** averaging */ NXOpen::CAE::Result::Averaging Averaging;
                public: /** include midnode */ bool IncludeMidnode;
                public: /** coordinate system */ NXOpen::CAE::Result::CoordinateSystem CoordinateSystem;
                public: /** element value */ NXOpen::CAE::Result::ElementValue ElementValue;
                public: /** complex */ NXOpen::CAE::Result::Complex Complex;
                public: /** phase angle */ double PhaseAngle;
                public: /** absolute value */ bool AbsoluteValue;
                public: /** scale value */ double ScaleValue;
                public: /** unit */ NXOpen::Unit * Unit;
                public: ResultParameters() :
                    LoadCaseIndex(),
                    IterationIndex(),
                    Type(),
                    Component((NXOpen::CAE::Result::Component)0),
                    Section(),
                    Plynumber(),
                    Layer(),
                    Averaging(),
                    IncludeMidnode(),
                    CoordinateSystem((NXOpen::CAE::Result::CoordinateSystem)0),
                    ElementValue(),
                    Complex((NXOpen::CAE::Result::Complex)0),
                    PhaseAngle(),
                    AbsoluteValue(),
                    ScaleValue(),
                    Unit()
                {
                }
                /** Constructor for the ResultParameters struct. */ 
                public: ResultParameters(int INIT_load_case_index /** load case number starting from 0 */, 
                        int INIT_iteration_index /** iteration number starting from 0 */, 
                        NXOpen::CAE::Result::Type INIT_type /** type */ , 
                        NXOpen::CAE::Result::Component INIT_component /** component */ , 
                        int INIT_section /** section */ , 
                        int INIT_plynumber /** plynumber */ , 
                        int INIT_layer /** layer */ , 
                        NXOpen::CAE::Result::Averaging INIT_averaging /** averaging */ , 
                        bool INIT_include_midnode /** include midnode */ , 
                        NXOpen::CAE::Result::CoordinateSystem INIT_coordinate_system /** coordinate system */ , 
                        NXOpen::CAE::Result::ElementValue INIT_element_value /** element value */ , 
                        NXOpen::CAE::Result::Complex INIT_complex /** complex */ , 
                        double INIT_phase_angle /** phase angle */ , 
                        bool INIT_absolute_value /** absolute value */ , 
                        double INIT_scale_value /** scale value */ , 
                        NXOpen::Unit * INIT_unit /** unit */ ) :
                    LoadCaseIndex(INIT_load_case_index),
                    IterationIndex(INIT_iteration_index),
                    Type(INIT_type),
                    Component(INIT_component),
                    Section(INIT_section),
                    Plynumber(INIT_plynumber),
                    Layer(INIT_layer),
                    Averaging(INIT_averaging),
                    IncludeMidnode(INIT_include_midnode),
                    CoordinateSystem(INIT_coordinate_system),
                    ElementValue(INIT_element_value),
                    Complex(INIT_complex),
                    PhaseAngle(INIT_phase_angle),
                    AbsoluteValue(INIT_absolute_value),
                    ScaleValue(INIT_scale_value),
                    Unit(INIT_unit)
                {
                }
            };

             /** Deformation parameter structure to specify complete result state for the deformed shape */
            public:
            struct DeformationParameters
            {
                public: /** load case number starting from 0 */int LoadCaseIndex;
                public: /** iteration number starting from 0 */int IterationIndex;
                public: /** type */ NXOpen::CAE::Result::Type Type;
                public: /** complex */ NXOpen::CAE::Result::Complex Complex;
                public: /** phase angle */ double PhaseAngle;
                public: /** deformation scale */ NXOpen::CAE::Result::DeformationScale DeformationScale;
                public: /** absolute scale value */ double AbsoluteScaleValue;
                public: /** model percent scale value */ double ModelPercentScaleValue;
                public: DeformationParameters() :
                    LoadCaseIndex(),
                    IterationIndex(),
                    Type(),
                    Complex((NXOpen::CAE::Result::Complex)0),
                    PhaseAngle(),
                    DeformationScale((NXOpen::CAE::Result::DeformationScale)0),
                    AbsoluteScaleValue(),
                    ModelPercentScaleValue()
                {
                }
                /** Constructor for the DeformationParameters struct. */ 
                public: DeformationParameters(int INIT_load_case_index /** load case number starting from 0 */, 
                        int INIT_iteration_index /** iteration number starting from 0 */, 
                        NXOpen::CAE::Result::Type INIT_type /** type */ , 
                        NXOpen::CAE::Result::Complex INIT_complex /** complex */ , 
                        double INIT_phase_angle /** phase angle */ , 
                        NXOpen::CAE::Result::DeformationScale INIT_deformation_scale /** deformation scale */ , 
                        double INIT_absolute_scale_value /** absolute scale value */ , 
                        double INIT_model_percent_scale_value /** model percent scale value */ ) :
                    LoadCaseIndex(INIT_load_case_index),
                    IterationIndex(INIT_iteration_index),
                    Type(INIT_type),
                    Complex(INIT_complex),
                    PhaseAngle(INIT_phase_angle),
                    DeformationScale(INIT_deformation_scale),
                    AbsoluteScaleValue(INIT_absolute_scale_value),
                    ModelPercentScaleValue(INIT_model_percent_scale_value)
                {
                }
            };

             /** Velociy parameter structure to specify result state for the 
                        velocity field used in streamline extraction */
            public:
            struct VelocityParameters
            {
                public: /** load case number starting from 0 */int LoadCaseIndex;
                public: /** iteration number starting from 0 */int IterationIndex;
                public: /** type */ NXOpen::CAE::Result::Type Type;
                public: VelocityParameters() :
                    LoadCaseIndex(),
                    IterationIndex(),
                    Type()
                {
                }
                /** Constructor for the VelocityParameters struct. */ 
                public: VelocityParameters(int INIT_load_case_index /** load case number starting from 0 */, 
                        int INIT_iteration_index /** iteration number starting from 0 */, 
                        NXOpen::CAE::Result::Type INIT_type /** type */ ) :
                    LoadCaseIndex(INIT_load_case_index),
                    IterationIndex(INIT_iteration_index),
                    Type(INIT_type)
                {
                }
            };

             /** The basic units system for a result*/
            public:
            struct ResultBasicUnit
            {
                public: /** mass unit */ NXOpen::Unit * MassUnit;
                public: /** length unit */ NXOpen::Unit * LengthUnit;
                public: /** time unit */ NXOpen::Unit * TimeUnit;
                public: /** temperature unit */ NXOpen::Unit * TemperatureUnit;
                public: /** angle unit */ NXOpen::Unit * AngleUnit;
                public: /** thermalenergy unit */ NXOpen::Unit * ThermalenergyUnit;
                public: ResultBasicUnit() :
                    MassUnit(),
                    LengthUnit(),
                    TimeUnit(),
                    TemperatureUnit(),
                    AngleUnit(),
                    ThermalenergyUnit()
                {
                }
                /** Constructor for the ResultBasicUnit struct. */ 
                public: ResultBasicUnit(NXOpen::Unit * INIT_mass_unit /** mass unit */ , 
                        NXOpen::Unit * INIT_length_unit /** length unit */ , 
                        NXOpen::Unit * INIT_time_unit /** time unit */ , 
                        NXOpen::Unit * INIT_temperature_unit /** temperature unit */ , 
                        NXOpen::Unit * INIT_angle_unit /** angle unit */ , 
                        NXOpen::Unit * INIT_thermalenergy_unit /** thermalenergy unit */ ) :
                    MassUnit(INIT_mass_unit),
                    LengthUnit(INIT_length_unit),
                    TimeUnit(INIT_time_unit),
                    TemperatureUnit(INIT_temperature_unit),
                    AngleUnit(INIT_angle_unit),
                    ThermalenergyUnit(INIT_thermalenergy_unit)
                {
                }
            };

            /** The result file type */
            public: enum Filetype
            {
                FiletypeNastran/** nastran */ ,
                FiletypeIdeas/** ideas */ ,
                FiletypeBud/** bud */ ,
                FiletypeVki/** vki */ ,
                FiletypeAbaqus/** abaqus */ ,
                FiletypeAnsys/** ansys */ ,
                FiletypeMapped/** mapped */ ,
                FiletypeAfu/** afu */ ,
                FiletypeRs2/** rs2 */ ,
                FiletypeAbaqusOdb/** abaqus odb */ 
            };

            private: friend class  _ResultBuilder;
            protected: Result();
            /** Number of loadcases available in the result file  @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNumLoadcases
            (
            );
            /** Number of loadcases available in the result file and their descriptions.
                        Loadcase index varies from 0 to N-1 (number of loadcases)
                     @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: std::vector<NXString> AskLoadcases
            (
            );
            /** Number of iterations available for a given loadcase.  @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNumIterations
            (
                int loadcaseIndex /** loadcaseindex */ 
            );
            /** Number of iterations available for a given loadcase and their descriptions 
                        Iteration index varies from 0 to N-1 (number of iterations)
                     @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: std::vector<NXString> AskIterations
            (
                int loadcaseIndex /** loadcaseindex */ 
            );
            /** Ask number of nodes in the model 
                        Node index varies from 1 to N (number of nodes)
                     @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNumNodes
            (
            );
            /** Ask number of elements in the model 
                        Element index varies from 0 to N-1 (number of elements)
                     @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNumElements
            (
            );
            /** Asks for the nodes given an element  <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: void AskElementNodes
            (
                int elementIndex /** elementindex */ ,
                std::vector<int> & nodeIndex /** nodeindex */ 
            );
            /** Asks for the coordinates of a node array  @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: std::vector<NXOpen::Point3d> AskNodeCoordinates
            (
                const std::vector<int> & nodeIndex /** nodeindex */ 
            );
            /** Returns an array of result types and descriptions available for a given loadcase and iteration  <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: void AskResultTypes
            (
                int loadcaseIndex /** loadcaseindex */ ,
                int iterationIndex /** iterationindex */ ,
                std::vector<NXOpen::CAE::Result::Type> & types /** types */ ,
                std::vector<NXString> & description /** description */ 
            );
            /** 
                        Returns the number of groups available in the model of type @link  CAE::Result::GroupContainer   CAE::Result::GroupContainer @endlink 
                     @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNumGroupsInContainer
            (
                NXOpen::CAE::Result::GroupContainer type /** type */ 
            );
            /** Returns an array of elements indices for a given group
                        Group index range from 0 to N-1 (number of groups)
                     <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: void AskNumElementsOfGroup
            (
                NXOpen::CAE::Result::GroupContainer type /** type */ ,
                int groupIndex /** groupindex */ ,
                std::vector<int> & elementIndex /** elementindex */ 
            );
            /** Ask node index of a given node user label  @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNodeIndex
            (
                int nodeLabel /** nodelabel */ 
            );
            /** Ask element index of a given element user label   @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskElementIndex
            (
                int elementLabel /** elementlabel */ 
            );
            /** Ask node user label of a given node index   @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskNodeLabel
            (
                int nodeIndex /** node index ranges from 1 to N (number of nodes) */
            );
            /** Ask element user label of a given element index   @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: int AskElementLabel
            (
                int elementIndex /** element index ranges from 1 to N (number of elements)*/
            );
            /** Ask element ids and corresponding number of sections at which result is defined  <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: void AskResultSections
            (
                int loadcaseIndex /** load case */,
                int iterationIndex /** iteration number */,
                const NXOpen::CAE::Result::Type & resultType /** result type */,
                std::vector<int> & sectionNums /** sectionnums */ 
            );
            /** Ask load case description, value type and value for the input load case  @return   <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: NXOpen::CAE::Result::LoadcaseValueType AskResultLoadcaseValue
            (
                int loadcaseIndex /** load case */,
                NXString* description /** description */ ,
                double* value /** value */ 
            );
            /** Ask element shape given an element index   @return  Element topology <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: NXOpen::CAE::ElementTypes::Shape AskElementShape
            (
                int elementIndex /** Element Index */
            );
            /** Ask result datatype  @return    <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: NXOpen::CAE::Result::DataType AskResultDataType
            (
                int loadcaseIndex /** loadcaseindex */ ,
                int iterationIndex /** iterationindex */ ,
                const NXOpen::CAE::Result::Type & resultType /** resulttype */ 
            );
            /** Ask whether a result type is complex or not  @return    <br> License requirements : nx_masterfem ("Finite Element Modeling") OR nx_design_sim ("NX Design Simulation") */
            public: bool IsResultTypeComplex
            (
                int loadcaseIndex /** loadcaseindex */ ,
                int iterationIndex /** iterationindex */ ,
                const NXOpen::CAE::Result::Type & resultType /** resulttype */ 
            );
        };
    }
}
#undef EXPORTLIBRARY
#endif
