#ifndef NXOpen_RULEMANAGER_HXX_INCLUDED
#define NXOpen_RULEMANAGER_HXX_INCLUDED
//--------------------------------------------------------------------------
//  Header for C++ interface to JA API
//--------------------------------------------------------------------------
//
//  Source File:
//     RuleManager.ja
//
//  Generated by:
//     apiwrap
//
//  WARNING:
//    This file is automatically generated - do not edit by hand
//
#include <vector>
#include <NXOpen/NXString.hxx>
#include <NXOpen/Callback.hxx>
#include <NXOpen/Session.hxx>
#include <NXOpen/TaggedObject.hxx>
#include <NXOpen/libnxopencpp_exports.hxx>
namespace NXOpen
{
    class RuleManager;
    class BasePart;
    class NXObject;
    /** Provides methods for manipulating the Knowledge Fusion rules in a part.  <br> To obtain an instance of this class, refer to @link BasePart BasePart@endlink  <br> */
    class NXOPENCPPEXPORT RuleManager
    {
        /** Indicates the data type of a rule. */
        public: enum RuleType
        {
            RuleTypeBoolean/** boolean */ ,
            RuleTypeFrame/** frame */ ,
            RuleTypeInteger/** integer */ ,
            RuleTypeList/** list */ ,
            RuleTypeName/** name */ ,
            RuleTypeNumber/** number */ ,
            RuleTypePoint/** point */ ,
            RuleTypeString/** string */ ,
            RuleTypeVector/** vector */ ,
            RuleTypeInstance/** instance */ ,
            RuleTypeAny/** any */ ,
            RuleTypeHostPointer/** host pointer */ 
        };

         /** Used to specify parameter values for child rule creation or modification. */
        public:
        struct ParameterRule
        {
            public: /** name of the parameter */NXString Name;
            public: /** new rule text for this parameter */NXString Rule;
            public: ParameterRule() :
                Name(),
                Rule()
            {
            }
            /** Constructor for the ParameterRule struct. */ 
            public: ParameterRule(NXString INIT_name /** name of the parameter */, 
                    NXString INIT_rule /** new rule text for this parameter */) :
                Name(INIT_name),
                Rule(INIT_rule)
            {
            }
        };

         /** Used to return information about a function. */
        public:
        struct FunctionInformation
        {
            public: /** Return type of function*/NXString ReturnType;
            public: /** Number of arguments */int NumArguments;
            public: /** Brief description of function */NXString BriefDescription;
            public: /** Full description of function */NXString FullDescription;
            public: /** Full description of return value */NXString ReturnDescription;
            public: /** TRUE for dynamic methods */bool IsDynamic;
            public: /** TRUE if usable in Design Logic */bool DesignLogic;
            public: /** Other related functions, comma-separated list */NXString SeeAlso;
            public: FunctionInformation() :
                ReturnType(),
                NumArguments(),
                BriefDescription(),
                FullDescription(),
                ReturnDescription(),
                IsDynamic(),
                DesignLogic(),
                SeeAlso()
            {
            }
            /** Constructor for the FunctionInformation struct. */ 
            public: FunctionInformation(NXString INIT_return_type /** Return type of function*/, 
                    int INIT_num_arguments /** Number of arguments */, 
                    NXString INIT_brief_description /** Brief description of function */, 
                    NXString INIT_full_description /** Full description of function */, 
                    NXString INIT_return_description /** Full description of return value */, 
                    bool INIT_is_dynamic /** TRUE for dynamic methods */, 
                    bool INIT_design_logic /** TRUE if usable in Design Logic */, 
                    NXString INIT_see_also /** Other related functions, comma-separated list */) :
                ReturnType(INIT_return_type),
                NumArguments(INIT_num_arguments),
                BriefDescription(INIT_brief_description),
                FullDescription(INIT_full_description),
                ReturnDescription(INIT_return_description),
                IsDynamic(INIT_is_dynamic),
                DesignLogic(INIT_design_logic),
                SeeAlso(INIT_see_also)
            {
            }
        };

         /** Used to return information about the arguments for a function. */
        public:
        struct FunctionArgumentsInformation
        {
            public: /** Argument name */NXString ArgumentName;
            public: /** Type of argument */NXString ArgumentType;
            public: /** Style of argument, Required or Optional */NXString ArgumentStyle;
            public: /** Default for optional argument */NXString ArgumentDefault;
            public: /** argument dimensionality */NXString ArgumentDimensionality;
            public: /** Description of argument */NXString ArgumentDescription;
            public: /** Selection object types for argument, comma-separated list */NXString ArgumentSelectionTypes;
            public: FunctionArgumentsInformation() :
                ArgumentName(),
                ArgumentType(),
                ArgumentStyle(),
                ArgumentDefault(),
                ArgumentDimensionality(),
                ArgumentDescription(),
                ArgumentSelectionTypes()
            {
            }
            /** Constructor for the FunctionArgumentsInformation struct. */ 
            public: FunctionArgumentsInformation(NXString INIT_argument_name /** Argument name */, 
                    NXString INIT_argument_type /** Type of argument */, 
                    NXString INIT_argument_style /** Style of argument, Required or Optional */, 
                    NXString INIT_argument_default /** Default for optional argument */, 
                    NXString INIT_argument_dimensionality /** argument dimensionality */, 
                    NXString INIT_argument_description /** Description of argument */, 
                    NXString INIT_argument_selection_types /** Selection object types for argument, comma-separated list */) :
                ArgumentName(INIT_argument_name),
                ArgumentType(INIT_argument_type),
                ArgumentStyle(INIT_argument_style),
                ArgumentDefault(INIT_argument_default),
                ArgumentDimensionality(INIT_argument_dimensionality),
                ArgumentDescription(INIT_argument_description),
                ArgumentSelectionTypes(INIT_argument_selection_types)
            {
            }
        };

         /** Used to return adoptable object types. */
        public:
        struct AdoptableTypes
        {
            public: /** object type */ int ObjectType;
            public: /** object subtype */ int ObjectSubtype;
            public: /** feature type */ int FeatureType;
            public: AdoptableTypes() :
                ObjectType(),
                ObjectSubtype(),
                FeatureType()
            {
            }
            /** Constructor for the AdoptableTypes struct. */ 
            public: AdoptableTypes(int INIT_object_type /** object type */ , 
                    int INIT_object_subtype /** object subtype */ , 
                    int INIT_feature_type /** feature type */ ) :
                ObjectType(INIT_object_type),
                ObjectSubtype(INIT_object_subtype),
                FeatureType(INIT_feature_type)
            {
            }
        };

        /** Indicates the license type to be used. */
        public: enum LicenseType
        {
            LicenseTypeNoLicense/** no license */ ,
            LicenseTypeAuthor/** author */ ,
            LicenseTypeExecute/** execute */ ,
            LicenseTypePipeline/** pipeline */ ,
            LicenseTypeKfFeature/** kf feature */ ,
            LicenseTypeKfInterop/** kf interop */ ,
            LicenseTypeKfNewGeom/** kf new geom */ ,
            LicenseTypeKfChecking/** kf checking */ 
        };

        /** Indicates the status from initializing RuleManager. */
        public: enum InitializationStatusType
        {
            InitializationStatusTypeSuccess/** Initialization succeeded */,
            InitializationStatusTypeFailure/** Initialization failed    */,
            InitializationStatusTypeUnavailable/** Intent not available     */,
            InitializationStatusTypeUnableToObtainLicense/** Cannot obtain license    */,
            InitializationStatusTypeCloseFailure/** Close failed             */
        };

        /** The filter option for asking for classes. */
        public: enum Filter
        {
            FilterUser/** User classes only */,
            FilterSystem/** System classes only */,
            FilterBoth/** Both user and system classes */,
            FilterUserPlus/** User and application classes */,
            FilterUserLoaded/** User classes that are loaded */,
            FilterSystemLoaded/** System classes that are loaded */,
            FilterBothLoaded/** System and user classes that are loaded */,
            FilterUserPlusLoaded/** User and application classes that are loaded */
        };

         /** Used to return debug update information for instances. */
        public:
        struct DebugInstance
        {
            public: /** part of instance  */NXString PartName;
            public: /** name of instance  */NXString RefChain;
            public: /** nha of instance   */NXString NhaChain;
            public: /** number of rules   */int NRules;
            public: /** index of rules[0] */int Rules0;
            public: DebugInstance() :
                PartName(),
                RefChain(),
                NhaChain(),
                NRules(),
                Rules0()
            {
            }
            /** Constructor for the DebugInstance struct. */ 
            public: DebugInstance(NXString INIT_part_name /** part of instance  */, 
                    NXString INIT_ref_chain /** name of instance  */, 
                    NXString INIT_nha_chain /** nha of instance   */, 
                    int INIT_n_rules /** number of rules   */, 
                    int INIT_rules0 /** index of rules[0] */) :
                PartName(INIT_part_name),
                RefChain(INIT_ref_chain),
                NhaChain(INIT_nha_chain),
                NRules(INIT_n_rules),
                Rules0(INIT_rules0)
            {
            }
        };

         /** Used to return debug update information for rules. */
        public:
        struct DebugRule
        {
            public: /** unit of rule    */NXString Unit;
            public: /** name of rule    */NXString Name;
            public: /** formula of rule */NXString Formula;
            public: /** type of value   */NXString Type;
            public: /** value of rule   */NXString Value;
            public: DebugRule() :
                Unit(),
                Name(),
                Formula(),
                Type(),
                Value()
            {
            }
            /** Constructor for the DebugRule struct. */ 
            public: DebugRule(NXString INIT_unit /** unit of rule    */, 
                    NXString INIT_name /** name of rule    */, 
                    NXString INIT_formula /** formula of rule */, 
                    NXString INIT_type /** type of value   */, 
                    NXString INIT_value /** value of rule   */) :
                Unit(INIT_unit),
                Name(INIT_name),
                Formula(INIT_formula),
                Type(INIT_type),
                Value(INIT_value)
            {
            }
        };

        private: NXOpen::BasePart* m_owner;
        public: explicit RuleManager(NXOpen::BasePart *owner): m_owner(owner)
        {
        }
        public: 
        /**Returns the tag of this object.  */
        tag_t Tag() const; 
        /** Initialize the RuleManager.  @return  Status from initializing RuleManager  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXOpen::RuleManager::InitializationStatusType Initialize
        (
            NXOpen::RuleManager::LicenseType licenseToTake /** Which license to take */,
            int* intentStatus /** Status from initializing subsystem */
        );
        /** Create or modify a dynamic rule.  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") OR ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void CreateDynamicRule
        (
            const NXString & referenceChain /** Reference chain for instance in which to create the dynamic rule */,
            const NXString & ruleName /** Name of rule to create */,
            NXOpen::RuleManager::RuleType ruleType /** Data type for the new rule */,
            const NXString & ruleText /** Value for the new rule as a string */
        );
        /** Create or modify a dynamic rule.  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") OR ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void CreateDynamicRule
        (
            const NXString & referenceChain /** Reference chain for instance in which to create the dynamic rule */,
            const NXString & ruleName /** Name of rule to create */,
            const NXString & behaviors /** Behaviors for the new rule, for example, "Number Modifiable" */,
            const NXString & ruleUnits /** Unit for the new rule, for example, "mm" */,
            const NXString & ruleText /** Value for the new rule as a string */,
            const NXString & leadingComment /** Leading comment for rule.  This can be NULL */
        );
        /** Create or modify a dynamic rule.  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") OR ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void CreateDynamicRule
        (
            const NXString & referenceChain /** Reference chain for instance in which to create the dynamic rule */,
            const NXString & ruleName /** Name of rule to create */,
            const NXString & behaviors /** Behaviors for the new rule, for example, "Number Modifiable" */,
            const NXString & ruleText /** Value for the new rule as a string */,
            const NXString & leadingComment /** Leading comment for rule.  This can be NULL */
        );
        /** Performs an KF update. This ensures that all KF objects will be properly updated 
                when created through dynamic rules.   
                 <br> 
                Note:  This method does the same thing as, @link Update::DoUpdate Update::DoUpdate@endlink 
                except that it does some addition updating to make sure CAE objects are complete.    
                 <br> 
              @return  The number of errors in the update module's error list.
                                       If errors occurred during update they will be added to that
                                       error list.  To obtain a list of these errors, use
                                       @link Update::ErrorList Update::ErrorList@endlink   <br> License requirements : None */
        public: int DoKfUpdate
        (
            NXOpen::Session::UndoMarkId undoMark /** If any update error occurs, the system 
                                                                  will roll back to this
                                                                  undo mark. */
        );
        /** Delete an existing dynamic rule.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void DeleteDynamicRule
        (
            const NXString & referenceChain /** Reference chain for instance from which to delete the dynamic rule */,
            const NXString & ruleName /** Name of rule to delete */
        );
        /** Create a child rule and the root for this rule manager's part.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void CreateChildRule
        (
            const NXString & ruleName /** Name of child rule to create */,
            const NXString & className /** Class to instantiate as this child */,
            const std::vector<NXOpen::RuleManager::ParameterRule> & parameters /** Input parameters for this class */
        );
        /** Delete a child rule from this rule manager.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void DeleteChildRule
        (
            const NXString & ruleName /** Name of child to delete */
        );
        /** Remove a dynamic child or attribute rule, but leave the geometry.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void RemoveRuleOnly
        (
            const NXString & referenceChain /** Reference chain for rule to remove */
        );
        /** Determine whether a class is a user class.  @return  True if the class is a user class  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsUserClass
        (
            const NXString & className /** Class name */
        );
        /** Get the names of all the rules defined in a class.  @return  Array of names of rules in the class  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetRulesOfClass
        (
            const NXString & className /** Class name */
        );
        /** Get the reference chains of all dynamic rules defined on a child rule (or Root:).  @return  Array of reference chains of rules in the child  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetDynamicRules
        (
            const NXString & childRuleName /** Name of child rule */
        );
        /** Get the parameters that have been specified on a dynamic child rule.  @return  Array of names of parameters specified  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetSpecifiedParameters
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Get the formula for a parameter that has been specified on a dynamic child rule.  @return  Formula for the specified parameter  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetParameterFormula
        (
            const NXString & referenceChain /** Reference chain for rule */,
            const NXString & parameterName /** Parameter name */
        );
        /** Rename a dynamic child or attribute rule.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void Rename
        (
            const NXString & referenceChain /** Reference chain for rule to rename */,
            const NXString & newName /** New leaf name */
        );
        /** Copy a dynamic child or attribute rule.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void Copy
        (
            const NXString & oldNameChain /** Name chain for rule to copy */,
            const NXString & oldLeafName /** Leaf name of rule to copy */,
            const NXString & newNameChain /** Name chain for copied rule */,
            const NXString & newLeafName /** Leaf name for copied rule */
        );
        /** Get the class of a dynamic rule.  @return  Class of rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetClass
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Get the classes for the members of a child list rule.  @return  Classes for members of child list  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetClassesOfChildList
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Get the rules that depend on the specified dynamic rule.  @return  Reference chains for dependent rules  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetDependents
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Get the rules that the specified dynamic rule depends on.  @return  Reference chains for rules depending on the specified rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetDependencies
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Get the data type of a dynamic routine  @return  Data type of the rule 
         @deprecated Deprecated in NX4 <br> 
         <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") */
        public: NXOpen::RuleManager::RuleType GetDynamicRuleType
        (
            const NXString & nameChain /** Reference chain of rule */
        );
        /** Get the type of a rule within a class.  @return  Data type required for this rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXOpen::RuleManager::RuleType GetRuleType
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Get the data type of a dynamic rule.  @return  Data type of the rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXOpen::RuleManager::RuleType GetRuleType
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Get the type of a parameter in a dynamic child rule.  @return  Data type required for this rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXOpen::RuleManager::RuleType GetParameterType
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a rule in a class is a child rule.  @return  True if the rule is a child rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsChildRule
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a dynamic rule is a child rule.  @return  True if the rule is a child rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsChildRule
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a rule within a class is a child list rule.  @return  True if the rule is a child list rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsChildList
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a dynamic rule is a child list.  @return  True if the rule is a child list  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsChildList
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a rule within a class is uncached.  @return  True if the rule is uncached  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsUncached
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a dynamic rule is uncached.  @return  True if the rule is uncached  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsUncached
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a rule within a class is hidden.  @return  True if the rule is hidden  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsHidden
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a dynamic rule is hidden.  @return  True if the rule is hidden  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsHidden
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a rule within a class is local to that class.  @return  True if the rule is local to the class  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsLocal
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a rule within a class is a parameter of that class.  @return  True if the rule is a parameter of the class  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsParameter
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a rule within a class is canonical.  @return  True if the rule is canonical  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsCanonical
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a rule within a class is modifiable.  @return  True if the rule is modifiable  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsModifiable
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a dynamic rule is modifiable.  @return  True if the rule is modifiable  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsModifiable
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a rule within a class is a method.  @return  True if the rule is a method  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsMethod
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns whether a dynamic rule is a method.  @return  True if the rule is a method  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsMethod
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Returns whether a dynamic rule's value has been computed yet.  @return  True if the rule's value has been computed  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsComputed
        (
            const NXString & referenceChain /** Reference chain for rule */
        );
        /** Rebuilds the KF Navigator tree and any Part Inspector trees that are being shown.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void RebuildTrees
        (
        );
        /** Returns whether the rule is defined in the specified class.  @return  True if the rule is defined in the class  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsRuleInClass
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Returns the default formula for a rule within a class . @return  The default formula for the rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetDefaultFormula
        (
            const NXString & className /** Class name */,
            const NXString & ruleName /** Rule name within the class */
        );
        /** Evaluate a rule and return its value as a string.  @return  Value of the rule formatted as a string  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString EvaluateAsString
        (
            const NXString & referenceChain /** Reference chain for the rule to evaluate */
        );
        /** Evaluate a rule and return its value as a string.  @return  Value of the rule formatted as a string  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString EvaluateAnyAsString
        (
            const NXString & referenceChain /** Reference chain for the rule to evaluate */
        );
        /** Returns the name chain  @return  full name chain of the object  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetNameChain
        (
            NXOpen::NXObject * ugObject /** object to find name chain  */
        );
        /** Regenerate all rules.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void RegenerateAll
        (
        );
        /** Run the syntax check on a dfa file.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void SyntaxCheck
        (
            const NXString & fileName /** dfa file to check   <br>  NOTE: The full Unicode character set is not supported for this parameter.  <br> */
        );
        /** Get the ancestor classes for a given class.  @return  names of ancestor classes  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetAncestorClasses
        (
            const NXString & className /** class name for which to get component classes */
        );
        /** Reload all classes and functions.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void Reload
        (
            bool refreshUserClassDir /** flag for whether to refresh search dirs after load */
        );
        /** Reload a single class.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void ReloadSingleClass
        (
            const NXString & className /** class name to reload */
        );
        /** Reload specified classes and functions.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void ReloadClassesAndFunctions
        (
            std::vector<NXString> & classes /** names of classes to reload */,
            std::vector<NXString> & functions /** names of functions to reload */
        );
        /** Get strings that describe the rule types.  @return  strings for rule types  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetRuleTypes
        (
        );
        /** Get class names that match the specified filter.  @return  class names  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetClasses
        (
            NXOpen::RuleManager::Filter filter /** filter for classes */
        );
        /** Get functions that match the specified filter.  @return  function names  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetFunctions
        (
            NXOpen::RuleManager::Filter filter /** filter for functions */,
            bool doSort /** TRUE to get the functions sorted alphabetically */
        );
        /** Remove all rules in the part.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void RemoveAllRules
        (
        );
        /** Read a dfa file and return its contents as a string.  @return  Contents of the file formatted as a string  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString ReadDfaFile
        (
            const NXString & fileName /** File name to read */
        );
        /** Write a string out to a dfa file.  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void WriteDfaFile
        (
            const NXString & fileName /** File name to write */,
            const NXString & fileString /** String to write to file */,
            bool replace /** if TRUE, replace the file if it exists */
        );
        /** Get the name of the dfa file that contains the specified class.  @return  File name that contains the class  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetClassDfaFile
        (
            const NXString & className /** Class name */
        );
        /** Get messages for the most recent error.  @return  lines for error messages  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXString> GetLastError
        (
        );
        /** Get the text to use when referencing the specified ug object in a rule.  @return  Reference text, either reference_chain or hostpointer text  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetReferenceText
        (
            NXOpen::NXObject * ugObject /** object to find reference text for */
        );
        /** Adopt the specified ug objects.  @return  TRUE if update needs to be called  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool AdoptObjects
        (
            const std::vector<NXOpen::NXObject *> & ugObjects /** objects to adopt */
        );
        /** The list of object types which can be adopted.  @return  Object type data  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXOpen::RuleManager::AdoptableTypes> GetAdoptableTypes
        (
        );
        /** Adoption text for the specified ug objects.  @return  Output text for the objects  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetRulesForObjects
        (
            const std::vector<NXOpen::NXObject *> & ugObjects /** objects to adopt */
        );
        /** Get information about a function.  @return  Information about the function  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXOpen::RuleManager::FunctionInformation GetFunctionInformation
        (
            const NXString & functionName /** Function name */,
            const NXString & instanceOrClassName /** Instance or class name (used only for a method otherwise null or Nothing */,
            bool isInstance /** TRUE if instance name passed, FALSE otherwise */,
            bool briefOnly /** TRUE if returning brief information only */
        );
        /** Get information about the arguments for a function.  @return  Information about the function arguments  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: std::vector<NXOpen::RuleManager::FunctionArgumentsInformation> GetFunctionArgumentsInformation
        (
            const NXString & functionName /** Function name */,
            const NXString & instanceOrClassName /** Instance or class name (used only for a method) */,
            bool isInstance /** TRUE if instance name passed, FALSE otherwise */,
            bool briefOnly /** TRUE if returning brief information only */
        );
        /** Get the file that contains the definitions for a function.  @return  File where the function is defined  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetFunctionFile
        (
            const NXString & functionName /** Function name */
        );
        /** Determine whether a function is one defined by the user.  @return  True if the class is a user function  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsUserFunction
        (
            const NXString & functionName /** Function name */
        );
        /** Determine whether a root level dynamic rule is mapped to an NX expression.  @return  True if the rule is an NX expression <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: bool IsExpressionRule
        (
            const NXString & ruleName /** Dynamic rule name */
        );
        /** Returns the rule text for a dynamic rule . @return  The text of the rule  <br> License requirements : ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: NXString GetDynamicRuleText
        (
            const NXString & referenceChain /** name chain for a dynamic rule */
        );
        /**Returns  the debug update flag.  <br> License requirements : None */
        public: bool DebugFlag
        (
        );
        /**Sets  the debug update flag.  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") OR ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void SetDebugFlag
        (
            bool debugFlag /** debug flag */ 
        );
        /** Get the debug update instances.  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") OR ug_kf_author ("UG/Knowledge Fusion - Author") */
        public: void GetDebugInstances
        (
            std::vector<NXOpen::RuleManager::DebugInstance> & instances /** Array of instances */,
            std::vector<NXOpen::RuleManager::DebugRule> & rules /** Array of rules     */
        );
        /**Returns  the create mode flag.  <br> License requirements : None */
        public: bool CreateMode
        (
        );
        /** Get the parse error start location.  @return  starting character pointer  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") */
        public: int GetErrorStart
        (
        );
        /** Get the parse error end location.  @return  ending character pointer  <br> License requirements : ug_kf_execute ("UG/Knowledge Fusion - Execute") */
        public: int GetErrorEnd
        (
        );
        public: virtual void initialize();
    };
}
#undef EXPORTLIBRARY
#endif
