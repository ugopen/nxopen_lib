<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Snap</name>
    </assembly>
    <members>
        <member name="T:Snap.Color">
            <summary>Provides functions to relate NX and Windows colors</summary>
        </member>
        <member name="M:Snap.Color.WindowsColor(System.Int32)">
            <summary>Returns the System.Drawing.Color corresponding to a given NX color index</summary>
            <param name="colorIndex">An index into the color table of the work part</param>
            <returns>The corresponding System.Drawing.Color color</returns>
            <remarks>The color index should be between 1 and 216.</remarks>
            <example> 
            This example shows how to get the System.Drawing.Color corresponding to a given NX color index:
            <code title="Get the System.Drawing.Color for an NX color index" lang="VB.NET" source="Color_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Color.ColorIndex(System.Drawing.Color)">
            <summary>Returns the index of the NX color most closely matching a given System.Drawing.Color</summary>
            <param name="windowsColor">A System.Drawing.Color</param>
            <returns>The index of the closest color in the work part</returns>
            <remarks>
            <para>
            This function returns an index from the color table of the work part, choosing the color
            that's closest to the given Windows color. Since the color table has only 216 entries, 
            it's quite likely that the NX color will not match the given Windows color exactly.
            </para>
            </remarks>
            <example> 
            This example shows how to get the NX color index most closely matching a given System.Drawing.Color:
            <code title="Get the NX color index matching a System.Drawing.Color" lang="VB.NET" source="Color_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Color.NXColor(System.Drawing.Color)">
            <summary>Returns the NX color most closely matching a given System.Drawing.Color</summary>
            <param name="windowsColor">A System.Drawing.Color</param>
            <returns>The closest NXOpen.NXColor in the work part</returns>
            <remarks>
            <para>
            This function returns a color from the color table of the work part, choosing the one
            that's closest to the given Windows color. Since the color table has only 216 entries, 
            it's quite likely that the NX color will not match the given Windows color exactly.      
            </para>
            </remarks>
            <example> 
            This example shows how to get the NX color most closely matching a given System.Drawing.Color
            <code title="Get the NX color matching a System.Drawing.Color" lang="VB.NET" source="Color_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.LineStyle">
            <summary> A collection of settings to control the display style of curves (color, width, font) </summary>
        </member>
        <member name="P:Snap.LineStyle.Color">
            <summary> The desired display color</summary>
        </member>
        <member name="P:Snap.LineStyle.Width">
            <summary> The desired line width (thin, thick, etc.)</summary>
        </member>
        <member name="P:Snap.LineStyle.Font">
            <summary>The desired line font (solid, dashed, etc.)</summary>  
        </member>
        <member name="M:Snap.LineStyle.#ctor(System.Drawing.Color,Snap.Globals.Width,Snap.Globals.Font)">
            <summary>Constructs a new LineStyle object</summary>
            <param name="color">The value for the Color field</param>
            <param name="width">The value for the Width field</param>
            <param name="font">The value for the Font field></param>
        </member>
        <member name="T:Snap.Draw">
            <summary>
            Provides functions for drawing temporary graphics in the NX window. 
            </summary>
            <remarks>
            <para>
            Drawing temporary graphics is useful when you want
            to provide information or feedback to the user of your programs.
            The graphics are erased if the user explicitly chooses the "Refresh" function,
            or uses some other function that involves refreshing the display.
            </para>
            <para>
            Drawing temporary graphics is often much faster than creating (and deleting) NX curves,
            and the display is easy for the user to erase when it's no longer needed.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Draw.DrawMarker(Snap.NX.View,Snap.Position,System.Drawing.Color,Snap.Draw.Marker)">
            <summary>Draws a temporary marker (a SNAP Marker) in the specified view</summary>
            <param name="view">The view in which the marker should be displayed</param>
            <param name="pt">The position where the marker should be displayed</param>
            <param name="color">The desired color of the marker</param>
            <param name="type">The type of marker to display (SNAP marker)</param>
            <remarks>
            <para>
            This function uses SNAP markers, which are just a limited set of the
            most common and useful ones. If you need
            access to a broader set of markers, please use the other
            <see cref= "M:Snap.Draw.DrawMarker(Snap.NX.View,Snap.Position,System.Drawing.Color,NXOpen.UF.UFDisp.PolyMarker)">
            Snap.Draw.DrawMarker</see> function.
            </para>
            </remarks>
            <example> 
            The following example draws some markers and a polyline
            <code title="Drawing temporary markers" lang="VB.NET" source="DrawMarker_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Draw.DrawMarker(Snap.NX.View,Snap.Position,System.Drawing.Color,NXOpen.UF.UFDisp.PolyMarker)">
            <summary>Draws a temporary marker (an NX Open PolyMarker) in the specified view</summary>
            <param name="view">The view in which the marker should be displayed</param>
            <param name="pt">The position where the marker should be displayed</param>
            <param name="color">The desired color of the marker</param>
            <param name="type">The type of marker to display (NX Open marker)</param>
        </member>
        <member name="T:Snap.Draw.Marker">
            <summary>A collection of common marker symbols</summary>
            <remarks>
            <para>
            The available marker symbols are shown below:
            </para>
            <para>
            <img src="../Images/markers.png"/>
            </para>
            </remarks>
        </member>
        <member name="F:Snap.Draw.Marker.Dot">
            <summary> Dot </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Asterisk">
            <summary> Asterisk </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Circle">
            <summary> Circle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Poundsign">
            <summary> Pound sign </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Cross">
            <summary> Cross </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Square">
            <summary> Square </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Triangle">
            <summary> Triangle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Diamond">
            <summary> Diamond </summary>
        </member>
        <member name="F:Snap.Draw.Marker.Centerline">
            <summary> Centerline </summary>
        </member>
        <member name="F:Snap.Draw.Marker.BigPlus">
            <summary> Big plus </summary>
        </member>
        <member name="F:Snap.Draw.Marker.BigCircle">
            <summary> Big circle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.BigCross">
            <summary> Big Cross </summary>
        </member>
        <member name="F:Snap.Draw.Marker.BigCrossInCircle">
            <summary> Big Cross In Circle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.BigAsterisk">
            <summary> Big Asterisk </summary>
        </member>
        <member name="F:Snap.Draw.Marker.BigFilledSquare">
            <summary> Big Filled Square </summary>
        </member>
        <member name="F:Snap.Draw.Marker.FilledCircle">
            <summary> Filled Circle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.FilledSquare">
            <summary> Filled Square </summary>
        </member>
        <member name="F:Snap.Draw.Marker.FilledDiamond">
            <summary> Filled Diamond </summary>
        </member>
        <member name="F:Snap.Draw.Marker.FilledTriangle">
            <summary> Filled Triangle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.CircleInCircle">
            <summary> Circle Inside Circle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.CircleInSquare">
            <summary> Circle In Square </summary>
        </member>
        <member name="F:Snap.Draw.Marker.SquareInSquare">
            <summary> Square In Square </summary>
        </member>
        <member name="F:Snap.Draw.Marker.LineInCircle">
            <summary> Line In Circle </summary>
        </member>
        <member name="F:Snap.Draw.Marker.PlusInCircle">
            <summary> Plus In Circle </summary>
        </member>
        <member name="M:Snap.Draw.DrawLine(Snap.NX.View,Snap.LineStyle,Snap.Position,Snap.Position)">
            <summary>Draws a temporary line in the specified view</summary>
            <param name="view">The view in which the line should be drawn</param>
            <param name="style">The LineStyle (color, width, font) to be used</param>
            <param name="p0">The start point of the line</param>
            <param name="p1">The end point of the line</param>
            <example> 
            The following example draws some temporary lines
            <code title="Drawing temporary lines" lang="VB.NET" source="DrawLine_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Draw.DrawPolyLine(Snap.NX.View,Snap.LineStyle,Snap.Position[])">
            <summary>Draws a temporary polyline (a string of connected lines) in the specified view</summary>
            <param name="view">The view in which the line should be drawn</param>
            <param name="style">The LineStyle (color, width, font) to be used</param>
            <param name="points">The points defining the polyline</param>
            <example> 
            The following example draws a temporary polyline
            <code title="Drawing temporary lines" lang="VB.NET" source="DrawPolyline_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Draw.DrawArc(Snap.NX.View,Snap.LineStyle,Snap.Geom.Curve.Arc)">
            <summary>Draws a temporary circular arc in the specified view</summary>
            <param name="view">The view in which the arc should be drawn</param>
            <param name="style">The LineStyle (color, width, font) to be used</param>
            <param name="arc">Geom.Curve.Arc object representing the arc</param>
            <example> 
            The following example draws some temporary arcs
            <code title="Drawing temporary arcs" lang="VB.NET" source="DrawArc_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Draw.DrawCircle(Snap.NX.View,Snap.LineStyle,Snap.Position,Snap.Vector,System.Double)">
            <summary>Draws a temporary circle in the specified view</summary>
            <param name="view">The view in which the circle should be drawn</param>
            <param name="style">The LineStyle (color, width, font) to be used</param>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisZ">Unit vector normal to plane of circle</param>
            <param name="radius">Radius</param>
            <example> 
            This example shows how to draw temporary circles: 
            <code title="Drawing circles" lang="VB.NET" source="DrawCircle_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Draw.DrawArc(Snap.NX.View,Snap.LineStyle,Snap.Geom.Curve.Arc)">Snap.Draw.DrawArc</seealso>
        </member>
        <member name="M:Snap.Draw.DrawText(Snap.NX.View,System.Drawing.Color,Snap.Position,System.String[])">
            <summary>Draws temporary text in the specified view</summary>
            <param name="view">The view in which the text should be drawn</param>
            <param name="color">The color of the text</param>
            <param name="pt">The location of the text</param>
            <param name="text">An array of lines of text</param>
            <remarks>
            <para>
            The text is drawn using the default system font at a "medium" size. 
            The text has a fixed size when measured in pixels, so, as you zoom in and out,
            the text will remain the same size. Also, the text will remain parallel to the plane 
            of the screen as you rotate the view. So, in short, the text looks and behaves
            like the text used to label the WCS axes in NX.
            </para>
            <para>
            The location specified is the left-hand end of the baseline of the first line of text.
            </para>
            </remarks>
            <example> 
            This example shows how to draw temporary text: 
            <code title="Drawing temporary text" lang="VB.NET" source="DrawText_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.Globals">
            <summary>Provides access to various global settings that affect the user's working environment.</summary>
            <example> 
            This example shows how to use the properties of the Snap.Globals class: " 
            <code title="Properties of the Globals class: " lang="VB.NET" source="Globals_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.Color">
            <summary>The general default color to be assigned to newly-created objects (as a System.Drawing.Color)</summary>
            <example> 
            This example shows how to get and set default colors
            <code title="Get and set object color " lang="VB.NET" source="Globals_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.BackGroundColor">
            <summary>The background color (as a System.Drawing.Color)</summary>
            <remarks>
            <para>
            Only works if the background is solid (rather than graduated)
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Globals.GetColor(Snap.Globals.DisplayType)">
            <summary>Gets the default color that will be assigned to newly-created objects of the specified type</summary>
            <param name="type">Object type</param>
            <returns>The default color that will be assigned</returns>
            <example> 
            This example shows how to get and set default colors
            <code title="Get and set object color " lang="VB.NET" source="Globals_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Globals.SetColor(Snap.Globals.DisplayType,System.Drawing.Color)">
            <summary>Sets the default color that will be assigned to newly-created objects of the specified type</summary>
            <param name="type">Object type</param>
            <param name="color">The default color that will be assigned</param>
            <remarks>
            <para>
            If NXOpen.Preferences.PartObject.ObjectType.AllButDefault has been set, then all objects will use the new default color.
            </para>
            </remarks>
            <example> 
            This example shows how to get and set default colors
            <code title="Get and set object color " lang="VB.NET" source="Globals_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.Globals.Width">
            <summary>Enumeration of display widths for use when drawing objects such as curves</summary>
        </member>
        <member name="F:Snap.Globals.Width.Normal">
            <summary>Normal width -- the same as Width018 (0.18 mm)</summary>
        </member>
        <member name="F:Snap.Globals.Width.Thick">
            <summary>Thick width -- the same as Width025 (0.25 mm)</summary>
        </member>
        <member name="F:Snap.Globals.Width.Thin">
            <summary>Thin width -- the same as Width013 (0.13 mm)</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width013">
            <summary>Width is 0.13 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width018">
            <summary>Width is 0.18 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width025">
            <summary>Width is 0.25 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width035">
            <summary>Width is 0.35 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width050">
            <summary>Width is 0.50 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width070">
            <summary>Width is 0.70 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width100">
            <summary>Width is 1.00 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width140">
            <summary>Width is 1.40 mm</summary>
        </member>
        <member name="F:Snap.Globals.Width.Width200">
            <summary>Width is 2.00 mm</summary>
        </member>
        <member name="P:Snap.Globals.LineWidth">
            <summary>The line width (thin, medium, or thick) to be assigned to newly-created objects</summary>
            <example> 
            This example shows how to get and set default line widths
            <code title="Using default line widths" lang="VB.NET" source="Globals_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Globals.GetLineWidth(Snap.Globals.DisplayType)">
            <summary>Gets the line width that will be assigned to newly-created objects of the specified type</summary>
            <param name="type">Object type</param>
            <returns>The default line width that will be assigned</returns>
            <example> 
            This example shows how to get and set default line widths
            <code title="Using default line widths" lang="VB.NET" source="Globals_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Globals.SetLineWidth(Snap.Globals.DisplayType,Snap.Globals.Width)">
            <summary>Sets the line width that will be assigned to newly-created objects of the specified type</summary>
            <param name="type">Object type</param>
            <param name="widthType">The default line width that will be assigned</param>
            <example>
            This example shows how to get and set default line widths
            <code title="Using default line widths" lang="VB.NET" source="Globals_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.Globals.Font">
            <summary>Enumeration of line fonts to be used when drawing objects such as curves</summary>
        </member>
        <member name="F:Snap.Globals.Font.Centerline">
            <summary>Centerline</summary>
        </member>
        <member name="F:Snap.Globals.Font.Dashed">
            <summary>Dashed</summary>
        </member>
        <member name="F:Snap.Globals.Font.Dotted">
            <summary>Dotted</summary>
        </member>
        <member name="F:Snap.Globals.Font.DottedDashed">
            <summary>DottedDashed</summary>
        </member>
        <member name="F:Snap.Globals.Font.LongDashed">
            <summary>LongDashed</summary>
        </member>
        <member name="F:Snap.Globals.Font.Phantom">
            <summary>Phantom</summary>
        </member>
        <member name="F:Snap.Globals.Font.Solid">
            <summary>Solid</summary>
        </member>
        <member name="P:Snap.Globals.LineFont">
            <summary>The line font (solid, dashed, etc.) to be assigned to newly-created objects</summary>
            <example> 
            This example shows how to get and set default line fonts 
            <code title="Using default line fonts" lang="VB.NET" source="Globals_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Globals.GetLineFont(Snap.Globals.DisplayType)">
            <summary>Gets the default line font that will be assigned to newly-created objects of the specified type</summary>
            <param name="type">Object type</param>
            <returns>The default line font that will be assigned</returns>
            <example> 
            This example shows how to get and set default line fonts 
            <code title="Using default line fonts" lang="VB.NET" source="Globals_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Globals.SetLineFont(Snap.Globals.DisplayType,Snap.Globals.Font)">
            <summary>Gets the default line font that will be assigned to newly-created objects of the specified type</summary>
            <param name="type">Object type</param>
            <param name="lineFontType">The default line font that will be assigned</param>
            <example> 
            This example shows how to get and set default line fonts 
            <code title="Using default line fonts" lang="VB.NET" source="Globals_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.Translucency">
            <summary>
            The translucency value to be assigned to newly-created objects
            </summary>
            <remarks>
            <para>
            The translucency value is an integer between 0 and 100. A value of 0 indicates that the
            object is completely opaque (no translucency at all). A value of 100 indicates that
            the object is completely translucent, and therefore invisible.
            </para>
            <para>
            The translucency setting affects any bodies (solids or sheets) or facetted bodies that are created subsequently.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Globals.DisplayType">
            <summary>Enumeration of the object types whose default display properties can be set</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.General">
            <summary>Default Type Value</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Line">
            <summary>Line</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Arc">
            <summary>Arc</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Conic">
            <summary>Conic</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Spline">
            <summary>Spline</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Solidbody">
            <summary>Solid Body</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Sheetbody">
            <summary>Sheet Body</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Datum">
            <summary>Datum</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Point">
            <summary>Point</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.CoordinateSystem">
            <summary>Coordinate System</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.AllButDefault">
            <summary>All But Default</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.DatumCsys">
            <summary>Datum CSYS Feature</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.Traceline">
            <summary>Traceline</summary>
        </member>
        <member name="F:Snap.Globals.DisplayType.InfiniteLine">
            <summary>Infinite Line</summary>
        </member>
        <member name="P:Snap.Globals.WorkLayer">
            <summary>The work layer (the layer on which newly-created objects should be placed)</summary>
            <remarks>
            <para>
            When you change the work layer, the previous work layer is given the status "Selectable".
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Globals.LayerStates">
            <summary>The "array" of layer states. LayerStates[n] gives the state of layer n.</summary>
            <example> 
            This example shows how to use the LayerStates property 
            <code title="Using layers " lang="VB.NET" source="Globals_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Globals.LayerObjectCount(System.Int32)">
            <summary>Get the number of objects on a specified layer</summary>
            <param name="layer">The layer number</param>
            <returns>The number of objects on the specified layer</returns>
            <example> 
            This example shows how to get the number of objects on a specified layer
            <code title="Get the number of objects on layer " lang="VB.NET" source="Globals_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.Globals.LayerStatesArray">
            <summary>A class to support indexed access to layer states.</summary>
            <remarks>
            <para>
            The actual states of the layers in the Work Part are accessible via the 
            <see cref="P:Snap.Globals.LayerStates">Snap.Globals.LayerStates</see> array. 
            Specifically, the array entry Snap.Globals.LayerStates[n] gives the status
            of layer number n.
            </para>
            </remarks>
            <seealso cref="P:Snap.Globals.LayerStates">Snap.Globals.LayerStates</seealso>
        </member>
        <member name="P:Snap.Globals.LayerStatesArray.Item(System.Int32)">
            <summary>The indexer for the LayerStatesArray class</summary>
            <param name="n">The index</param>
            <returns>The n-th element of the "array"</returns>
        </member>
        <member name="T:Snap.Globals.LayerState">
            <summary>The possible states of a layer</summary>
            <remarks>
            <para>
            The actual states of the layers in the Work Part are accessible via the 
            <see cref="P:Snap.Globals.LayerStates">Snap.Globals.LayerStates</see> array. 
            Specifically, the array entry Snap.Globals.LayerStates[n] gives the status
            of layer number n.
            </para>
            </remarks>
            <seealso cref="P:Snap.Globals.LayerStates">Snap.Globals.LayerStates</seealso>
        </member>
        <member name="F:Snap.Globals.LayerState.WorkLayer">
            <summary>Work layer. The layer on which all newly created objects are placed.</summary>
        </member>
        <member name="F:Snap.Globals.LayerState.Selectable">
            <summary>Objects on the layer are selectable</summary>
        </member>
        <member name="F:Snap.Globals.LayerState.Visible">
            <summary>Objects on the layer are visible, but not selectable</summary>
        </member>
        <member name="F:Snap.Globals.LayerState.Hidden">
            <summary>Objects on the layer are not visible and not selectable</summary>
        </member>
        <member name="P:Snap.Globals.NXOpenWorkPart">
            <summary>Gets the NXOpen.Parts.Work object of the session</summary>
        </member>
        <member name="P:Snap.Globals.WorkPart">
            <summary>Gets and sets the work part of the session</summary>
            <remarks>
            <para>
            SNAP functions always create objects in the work part. So, if you want to create objects 
            in several different parts, you use this property to change the work part.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Globals.DisplayPart">
            <summary>Gets and sets the display part</summary>
            <example> 
            This example shows how to get and set the display part
            <code title="Get and set the display part" lang="VB.NET" source="Globals_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.WorkView">
            <summary>The work view of the work part</summary>
        </member>
        <member name="P:Snap.Globals.Wcs">
            <summary>The work coordinate system (Wcs) of the work part</summary>
        </member>
        <member name="P:Snap.Globals.WcsOrientation">
            <summary>The orientation of the Wcs of the work part</summary>
            <example> 
            The following example shows how to use the WCS orientation.
            <code title="Using the WCS orientation" lang="VB.NET" source="WcsOrientation_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.MillimetersPerUnit">
            <summary>Millimeters Per Unit (either 1 or 25.4)</summary>
            <remarks>
            <para>
            A constant representing the number of millimeters in one part unit.
            </para>
            <para>If UnitType == Millimeter, then MillimetersPerUnit = 1.</para>
            <para>If UnitType == Inch, then MillimetersPerUnit = 25.4</para>
            </remarks>
            <example> 
            The following example shows how to use this property: 
            <code title="Millimeters Per Unit" lang="VB.NET" source="Globals_08.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.InchesPerUnit">
            <summary>Inches per part unit (either 1 or roughly 0.04)</summary>
            <remarks>
            <para>
            A constant representing the number of inches in one part unit.
            </para>
            <para>If UnitType = Millimeter, then InchesPerUnit = 0.0393700787402</para>
            <para>If UnitType = Inch, then InchesPerUnit = 1.</para>
            </remarks>
            <example> 
            The following example shows how to use this property: 
            <code title="Inches Per Unit" lang="VB.NET" source="Globals_08.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.DistanceTolerance">
            <summary>Distance tolerance</summary>
            <remarks>
            <para>
            This distance tolerance is the same one that you access via Preferences &#8594; Modeling Preferences in interactive NX.
            In many functions in NX, an approximation process is used to construct geometry (curves or bodies).
            The distance tolerance (together with the angle tolerance) controls the accuracy of this approximation, unless 
            you specify some over-riding tolerance within the function itself. For example, when you offset a curve, NX 
            will construct a spline curve that approximates the true offset to within the current distance tolerance.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Globals.AngleTolerance">
            <summary>Angle tolerance, in degrees</summary>
            <remarks>
            <para>
            This angle tolerance is the same one that you access via Preference &#8594; Modeling Preferences in interactive NX.
            In many functions in NX, an approximation process is used to construct geometry (curves or bodies).
            The angle tolerance (together with the distance tolerance) controls the accuracy of this approximation, unless 
            you specify some over-riding tolerance within the function itself. For example, when you create a Through Curve Mesh
            feature in NX, the resulting surface will match the input curves to within the current distance and angle tolerances.
            </para>
            <para>
            The angle tolerance is expressed in degrees.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Globals.ChainingTolerance">
            <summary>The chaining tolerance used in building "section" objects</summary>
            <remarks>
            <para>
            Most modeling features seem to set this internally to 0.95*DistanceTolerance,
            so that's what we use here.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Globals.Session">
            <summary>Get NX Open Session</summary>
        </member>
        <member name="P:Snap.Globals.UFSession">
            <summary>Get NXOpen.UF.UFSession</summary>
        </member>
        <member name="P:Snap.Globals.HistoryMode">
            <summary>If true, indicates that the modeling mode is set to History mode
            (as opposed to History-free mode).</summary>
            <remarks>
            <para>
            This is the same setting that you access via 
            Insert &#8594; Synchronous Modeling &#8594; History Mode in interactive NX.
            Please refer to the NX documentation for a discussion of the History and
            History-free modeling modes.
            </para>
            <para>
            To create features in SNAP code, you must first set HistoryMode to True.
            </para>
            </remarks>
            <example> 
            This example shows how to use this property" 
            <code title="History mode" lang="VB.NET" source="HistoryMode_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Globals.ManagedMode">
            <summary>
            If true, indicates that NX is running in managed mode,
            with Teamcenter (as opposed to native mode).
            </summary>
        </member>
        <member name="P:Snap.Globals.UnitType">
            <summary>The unit type of the work part</summary>
            <remarks>
            <para>
            This property only gives the type of the unit.
            To get a Snap.NX.Unit object, please use the 
            <see cref= "P:Snap.Globals.PartUnit">Snap.Globals.PartUnit</see>
            property, instead. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.Globals.PartUnit">Snap.Globals.PartUnit</seealso>
        </member>
        <member name="T:Snap.Globals.Unit">
            <summary>Enumeration of length unit types that can be used</summary>
        </member>
        <member name="F:Snap.Globals.Unit.Millimeter">
            <summary>Millimeter</summary>
        </member>
        <member name="F:Snap.Globals.Unit.Inch">
            <summary>Inch</summary>
        </member>
        <member name="P:Snap.Globals.PartUnit">
            <summary>The length unit of the work part</summary>
            <remarks>
            <para>
            This will be either Snap.NX.Unit.Millimeter or Snap.NX.Unit.Inch
            </para>
            </remarks>
            <seealso cref= "T:Snap.NX.Unit">Snap.NX.Unit</seealso>
            <seealso cref= "F:Snap.NX.Unit.Millimeter">Snap.NX.Unit.Millimeter</seealso>
            <seealso cref= "F:Snap.NX.Unit.Inch">Snap.NX.Unit.Inch</seealso>
        </member>
        <member name="M:Snap.Globals.SetUndoMark(Snap.Globals.MarkVisibility,System.String)">
            <summary>Creates an Undo mark</summary>
            <param name="markVisibility">Indicates the visibility of the undo mark</param>
            <param name="name">The name to be assigned to the Undo mark</param>
            <returns>The ID of the newly created Undo mark</returns>
            <remarks>
            <para>
            Creating an Undo mark gives you a way to save the state of the NX session. Then,
            at some later time, you can "roll back" to the Undo mark to restore NX to the saved state.
            This is useful for error recovery, and for reversing any temporary changes you have made
            (such as creation of temporary objects).
            </para>
            <para>
            If you create a visible Undo mark, the name you assign will be shown in
            the Undo List on the NX Edit menu.
            </para>
            <para>
            Please refer to the NX/Open Programmer's Guide for more
            information about Undo marks.
            </para>
            </remarks>
            <example>
            This example shows how to use Undo marks: 
            <code title="Using Undo marks" lang="VB.NET" source="UndoMark_01.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Globals.DeleteUndoMark(Snap.Globals.UndoMarkId,System.String)">DeleteUndoMark</seealso>
            <seealso cref= "M:Snap.Globals.UndoToMark(Snap.Globals.UndoMarkId,System.String)">UndoToMark</seealso>
        </member>
        <member name="M:Snap.Globals.DeleteUndoMark(Snap.Globals.UndoMarkId,System.String)">
            <summary>Deletes an Undo mark</summary>
            <param name="markId">The ID of the Undo mark</param>
            <param name="markName">The name of the Undo mark.</param>
            <remarks>
            <para>
            You can access an Undo mark either using its ID or its name.
            The system will try to find the mark using the given ID, first.
            If this fails (because you have provided an incorrect ID), the system
            will try again to find the mark based on its name.
            </para>
            </remarks>
            <example>
            This example shows how to use Undo marks: 
            <code title="Using Undo marks" lang="VB.NET" source="UndoMark_01.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Globals.SetUndoMark(Snap.Globals.MarkVisibility,System.String)">SetUndoMark</seealso>
            <seealso cref= "M:Snap.Globals.UndoToMark(Snap.Globals.UndoMarkId,System.String)">UndoToMark</seealso>
        </member>
        <member name="M:Snap.Globals.UndoToMark(Snap.Globals.UndoMarkId,System.String)">
            <summary>Roll back to an existing Undo mark</summary>
            <param name="markId">The ID of the Undo mark to roll back to</param>
            <param name="markName">The name of the Undo mark.</param>
            <remarks>
            <para>
            You can access an Undo mark either using its ID or its name.
            The system will try to find the mark using the given ID, first.
            If this fails (because you have provided an incorrect ID), the system
            will try again to find the mark based on its name.
            </para>
            </remarks>
            <example>
            This example shows how to use Undo marks: 
            <code title="Using Undo marks" lang="VB.NET" source="UndoMark_01.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Globals.SetUndoMark(Snap.Globals.MarkVisibility,System.String)">SetUndoMark</seealso>
            <seealso cref= "M:Snap.Globals.DeleteUndoMark(Snap.Globals.UndoMarkId,System.String)">UndoToMark</seealso>
        </member>
        <member name="T:Snap.Globals.MarkVisibility">
            <summary>Indicates the visibility of an Undo mark</summary>
            <remarks>
            <para>
            If an Undo mark is visible, its name will be shown 
            in the Undo List on the NX Edit menu.
            </para>
            <para>
            If an Undo mark is invisible, it will not be shown 
            in the Undo List. An invisible Undo mark
            is typically used to save a "safe" state of the NX session that
            your code can then restore if some problem arises.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.Globals.MarkVisibility.AnyVisibility">
            <summary>Use only in query methods</summary>
        </member>
        <member name="F:Snap.Globals.MarkVisibility.Invisible">
            <summary>Invisible</summary>
        </member>
        <member name="F:Snap.Globals.MarkVisibility.Visible">
            <summary>Visible</summary>         
        </member>
        <member name="T:Snap.Globals.UndoMarkId">
            <summary>An identifier used to refer to an Undo mark</summary>
        </member>
        <member name="T:Snap.InfoWindow">
            <summary>
            Provides functions to write output to the NX Information window 
            (sometimes known as the "Listing" window).
            </summary>
        </member>
        <member name="M:Snap.InfoWindow.Write(System.String)">
            <summary>
            Writes a string to the Info window (with no newline added)
            </summary>
            <param name="mystring">The string to write</param>
            <example> 
            The following example shows how to write a string or a string array to the Info window : 
            <code title="Write a string or a string array to the Info window " lang="VB.NET" source="InfoWindow_03.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.String)">
            <summary>
            Writes a string to the Info window (with a newline added)
            </summary>
            <param name="mystring">The string to write</param>
            <example> 
            The following example shows how to write a string or a string array to the Info window : 
            <code title="Write a string or a string array to the Info window " lang="VB.NET" source="InfoWindow_03.vb"> 
            </code> 
            </example>            
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.String[],System.Int32)">
            <summary>
            Write an array of strings to the Info window (with a newline added)
            </summary>
            <param name="myStringArray">The array of strings to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 20</param>
            <example> 
            The following example shows how to write a string or a string array to the Info window : 
            <code title="Write a string or a string array to the Info window " lang="VB.NET" source="InfoWindow_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.Write(System.Int32)">
            <summary>
            Write an integer to the Info window (with no newline added)
            </summary>
            <param name="myInteger">The integer to write</param>
            <example> 
            The following example shows how to write an integer or an integer array to the Info window : 
            <code title="Write an integer or an integer array to the Info window " lang="VB.NET" source="InfoWindow_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Int32)">
            <summary>
            Write an integer to the Info window (with a newline added)
            </summary>
            <param name="myInteger">The integer to write</param>
            <example> 
            The following example shows how to write an integer or an integer array to the Info window : 
            <code title="Write an integer or an integer array to the Info window " lang="VB.NET" source="InfoWindow_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Int32[],System.Int32)">
            <summary>
            Write an array of integers to the Info window (with a newline added)
            </summary>
            <param name="myIntArray">The array of integers to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 7</param>
            <example> 
            The following example shows how to write an integer or an integer array to the Info window : 
            <code title="Write an integer or an integer array to the Info window " lang="VB.NET" source="InfoWindow_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Int32[0:,0:],System.Int32)">
            <summary>
            Writes a two-dimensional array of integers to the Info window (with a newline added)
            </summary>
            <param name="myIntArray">The two-dimensional array of integers to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 7</param>
            <example> 
            The following example shows how to write a two-dimensional array of integers to the Info window : 
            <code title="Write a two-dimensional array of integers to the Info window " lang="VB.NET" source="InfoWindow_13.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.Write(System.Double)">
            <summary>
            Writes a double to the Info window (with no newline added)
            </summary>
            <param name="mydouble">The double to write</param>
            <remarks>
            <para>
            The double is converted to a string in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. If you need more control
            over the conversion process, please use the standard .NET ToString function
            with an appropriate format specifier.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a double or a double array to the Info window : 
            <code title="Write a double or a double array to the Info window " lang="VB.NET" source="InfoWindow_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Double)">
            <summary>
            Writes a double to the Info window (with a newline added)
            </summary>
            <param name="mydouble">The double to write</param>
            <remarks>
            <para>
            The double is converted to a string in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. If you need more control
            over the conversion process, please use the standard .NET ToString function
            with an appropriate format specifier.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a double or a double array to the Info window : 
            <code title="Write a double or a double array to the Info window " lang="VB.NET" source="InfoWindow_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Double[],System.Int32)">
            <summary>
            Write an array of doubles to the Info window (with a newline added)
            </summary>
            <param name="myDoubleArray">The array of doubles to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 10</param>
            <remarks>
            <para>
            The double is converted to a string in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. If you need more control
            over the conversion process, please use the standard .NET ToString function
            with an appropriate format specifier.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a double or a double array to the Info window : 
            <code title="Write a double or a double array to the Info window " lang="VB.NET" source="InfoWindow_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Double[],System.String)">
            <summary>
            Write an array of doubles to the Info window (with a newline added)
            </summary>
            <param name="myDoubleArray">The array of doubles to be written</param>
            <param name="format">The format specifier to be used when writing each double</param>
            <remarks>
            <para>
            You can use any format specifier that is allowed in the standard .NET string.Format function.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Double[0:,0:],System.Int32)">
            <summary>
            Writes a two-dimensional array of doubles to the Info window (with a newline added)
            </summary>
            <param name="myDoubleArray">The two-dimensional array of doubles to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 10</param>
            <remarks>
            <para>
            The double is converted to a string in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. If you need more control
            over the conversion process, please use the standard .NET ToString function
            with an appropriate format specifier.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a two-dimensional array of doubles to the Info window : 
            <code title="Write a two-dimensional array of doubles to the Info window " lang="VB.NET" source="InfoWindow_12.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.Write(Snap.Position)">
            <summary>
            Writes a position to the Info window (with no newline added)
            </summary>
            <param name="myPosition">The position to write</param>
            <remarks>
            <para>
            The position is written in the form :  ( X, Y, Z ).
            </para>
            <para>
            If you want to control the formatting of the X, Y, Z coordinates, please use the 
            <see cref= "M:Snap.Position.ToString(System.String)">Snap.Position.ToString</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a position to the Info window : 
            <code title="Write a position to the Info window " lang="VB.NET" source="InfoWindow_06.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Position.ToString(System.String)">Snap.Position.ToString</seealso>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Position)">
            <summary>
            Writes a position to the Info window (with a newline added)
            </summary>
            <param name="myPosition">The position to write</param>
            <remarks>
            <para>
            The position is written in the form :  ( X, Y, Z ).
            </para>
            <para>
            If you want to control the formatting of the X, Y, Z coordinates, please use the 
            <see cref= "M:Snap.Position.ToString(System.String)">Snap.Position.ToString</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a position to the Info window : 
            <code title="Write a position to the Info window " lang="VB.NET" source="InfoWindow_06.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Position.ToString(System.String)">Snap.Position.ToString</seealso>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Position[],System.Int32)">
            <summary>
            Writes a position array to the Info window (with a newline added)
            </summary>
            <param name="myPositionArray">The position array to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 20</param>
            <example> 
            The following example shows how to write a position array to the Info window : 
            <code title="Write a position array to the Info window " lang="VB.NET" source="InfoWindow_07.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Position[0:,0:],System.Int32)">
            <summary>
            Writes a two-dimensional array of positions to the Info window (with a newline added)
            </summary>
            <param name="myPositionArray">The two-dimensional array of positions to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 20</param>
            <example> 
            The following example shows how to write a two-dimensional array of positions to the Info window : 
            <code title="Write a two-dimensional array of positions to the Info window " lang="VB.NET" source="InfoWindow_08.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.Write(Snap.Vector)">
            <summary>
            Writes a 3D vector to the Info window (with no newline added)
            </summary>
            <param name="myVector">The vector to write</param>
            <remarks>
            <para>
            The vector is written in the form :  (X, Y, Z).
            </para>
            <para>
            If you want to control the formatting of the X, Y, Z components, please use the 
            <see cref= "M:Snap.Vector.ToString(System.String)">Snap.Vector.ToString</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a 3D vector to the Info window : 
            <code title="Write a 3D vector to the Info window " lang="VB.NET" source="InfoWindow_04.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Vector.ToString(System.String)">Snap.Vector.ToString</seealso> function.
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Vector)">
            <summary>
            Writes a 3D vector to the Info window (with a newline added)
            </summary>
            <param name="myVector">The vector to write</param>
            <remarks>
            <para>
            The vector is written in the form :  (X, Y, Z).
            </para>
            <para>
            If you want to control the formatting of the X, Y, Z components, please use the 
            <see cref= "M:Snap.Vector.ToString(System.String)">Snap.Vector.ToString</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to write a 3D vector to the Info window : 
            <code title="Write a 3D vector to the Info window " lang="VB.NET" source="InfoWindow_04.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Vector.ToString(System.String)">Snap.Vector.ToString</seealso> function.
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Vector[],System.Int32)">
            <summary>
            Write an array of 3D vectors to the Info window (with a newline added)
            </summary>
            <param name="myVectorArray">The vector array to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 20</param>
            <example> 
            The following example shows how to write an array of 3D vectors to the Info window : 
            <code title="Write an array of 3D vectors to the Info window " lang="VB.NET" source="InfoWindow_09.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Vector[0:,0:],System.Int32)">
            <summary>
            Writes a two-dimensional array of 3D vectors to the Info window (with a newline added)
            </summary>
            <param name="myVectorArray">The two-dimensional array of 3D vectors to write</param>
            <param name="paddedWidth">The total width of each number field (padding added on the right). Optional. Default = 20</param>
            <example>
            The following example shows how to write a two-dimensional array of 3D vectors to the Info window :
            <code title="Write a two-dimensional array of 3D vectors to the Info window " lang="VB.NET" source="InfoWindow_10.vb">
            </code>
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(Snap.Orientation)">
            <summary>
            Write an orientation to the Info window (with a newline added)
            </summary>
            <param name="myOrientation">The orientation to write</param>
            <example> 
            The following example shows how to write an orientation to the Info window : 
            <code title="Write an orientation to the Info window " lang="VB.NET" source="InfoWindow_11.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.WriteLine(System.Object)">
            <summary>
            Writes a string representation of an object to the Info window (with a newline added)
            </summary>
            <param name="myobject">The object to write</param>
            <remarks>
            <para>
            Writes the string produced by the object's ToString method
            </para>
            </remarks>
            <example> 
            The following example shows how to write a string representation of an object to the Info window : 
            <code title="Write to the Info window " lang="VB.NET" source="InfoWindow_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.InfoWindow.Close">
            <summary>Closes the Information window</summary>
            <remarks>
            <para>
            Closing the Info window will also clear its contents.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.InfoWindow.Clear">
            <summary>Clears the Info Window</summary>
        </member>
        <member name="T:Snap.Number">
            <summary>Class to allow either double or string inputs when creating features</summary>
            <remarks>
            <para>
            When creating features, it is often useful to allow either Double or String values as function inputs.
            Rather than having two separate feature creation functions (one with Double inputs and one
            with String inputs), we typically have just a single function that uses Number objects as inputs.
            Since a Double or a String can be implicitly converted to a Number, this single function
            can accept either data type as input.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Number.ToString">
            <summary>Produces a string representation of a Number object</summary>
            <returns>The string</returns> 
            <remarks>
            <para>
            The string representation is in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. 
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Number.#ctor(System.Double)">
            <summary>Creates a Number from a given double</summary>
            <param name="x">Double value</param>
        </member>
        <member name="M:Snap.Number.#ctor(System.Int32)">
            <summary>Creates a Number from a given integer</summary>
            <param name="x">Integer value</param>
        </member>
        <member name="M:Snap.Number.#ctor(System.String)">
            <summary>Creates a Number from a given double</summary>
            <param name="s">String value</param>
            <remarks>
            <para>
            In feature creation the Number is used as the right-hand side of an expression,
            so the string input here must be something that makes sense in this role.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Number.NullToZero(Snap.Number)">
            <summary>Returns Number.Zero if the Number is <c>Nothing</c></summary>
            <remarks>
            <para>
            There are some places where we would like to use Number.Zero as the default value
            of an optional function argument. But we can't use Number.Zero
            as a default value, since it is not a compile-time constant, so we use
            <c>Nothing</c>, instead. This means (by convention) that the numerical value should be zero, by default. 
            So then we need some standard way to convert <c>Nothing</c> to Number.Zero.
            That's what this function does.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Number.op_Implicit(System.Double)~Snap.Number">
            <summary>
            Implicit conversion of double to Number (allows doubles to be used as inputs when creating features)
            </summary>
            <param name="x">Double value</param>
            <returns>Number representing the double value</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Number.op_Implicit(System.String)~Snap.Number">
            <summary>
            Implicit conversion of string to Number (allows strings to be used as inputs when creating features)
            </summary>
            <param name="s">String value</param>
            <returns>Number representing the string value</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Number.op_Implicit(System.Int32)~Snap.Number">
            <summary>
            Implicit conversion of integer to Number (allows integer to be used as inputs when creating features)
            </summary>
            <param name="x">Integer value</param>
            <returns>Number representing the integer value</returns>
            <exclude/>
        </member>
        <member name="F:Snap.Number.Zero">
            <summary>The Number representing zero</summary>
        </member>
        <member name="M:Snap.Number.ToString(System.Double)">
            <summary>Convert number to string</summary>
            <param name="number">A double variable</param>
            <returns>String using dot as decimal separator</returns>
        </member>
        <member name="M:Snap.Number.Parse(System.String)">
            <summary>Convert string to number</summary>
            <param name="number">A string variable</param>
            <returns>Double using dot as decimal separator</returns>
        </member>
        <member name="T:Snap.Print">
            <summary>
            Provides functions to support printing
            </summary>   
        </member>
        <member name="M:Snap.Print.PrintDisplay(System.Int32,System.Double,System.Double,System.Double,NXOpen.PrintBuilder.OutputOption,System.Boolean,System.Boolean,System.Boolean,NXOpen.PrintBuilder.ImageResolutionOption,NXOpen.PrintBuilder.OrientationOption,NXOpen.PrintBuilder.PaperSize)">
            <summary>
            Printing the Current Display
            </summary>
            <param name="copies">The number of copies to be printed. Optional. Default = 1</param>
            <param name="thinWidth">
            The thin width scale factor. See remarks below. This number cannot be less than 0.0. Optional. Default = 1.0
            </param>
            <param name="normalWidth">
            The normal width scale factor.  See remarks below. This number cannot be less than 0.0. Optional. Default = 2.0
            </param>
            <param name="thickWidth">The thick width scale factor.  See remarks below. This number cannot be less than 0.0. Optional. Default = 3.0</param>
            <param name="output">The type of output desired (shaded or wire-fame). Optional. Default = WireframeBlackWhite </param>
            <param name="whiteBackground">
            If true, outputs an image with a white background, rather than using the current NX background color(s).
            This option is only applicable when the "output" parameter is set to "shaded".  Optional. Default = False
            </param>
            <param name="rasterImages">
            If true, indicates that any raster images inserted in drawings will be output when printing. Optional. Default = True
            </param>
            <param name="shadedGeometry">
            The shaded geometry as wireframe option.
            If true, indicates that shaded objects will be printed as wireframes, rather than shaded. Optional. Default = False
            </param>
            <param name="imageResolutionOption">The resolution of images created for printing shaded views. Optional. Default = Draft</param>
            <param name="orientation">The orientation of the printed page. Optional. Default = Landscape</param>
            <param name="paper">The paper size used for printing. Optional. Default = A4</param> 
            <remarks>
            <para>
            The basic line width is roughly 0.5 points. The thinWidth, normalWidth and thickWidth factors express line widths
            as multiples of this basic width. So, for example, if thinWidth = 3, then any line that has been designated
            as "thin" in NX will be printed with a width of roughly 1.5 points.
            </para>
            </remarks>
            <example>
            The following example prints the current display: 
            <code title="Print the current display" lang="VB.NET" source="UI_Print_01.vb">
            </code>
            </example>
        </member>
        <member name="T:Snap.NamespaceDoc">
            <summary>
            Contains functions for creating NX objects (in the Snap.Create class) and 
            for doing computations on these objects (in the Snap.Compute class).
            </summary> 
        </member>
        <member name="T:Snap.UnitConversion">
            <summary>Provides functions to do unit conversions of various sorts</summary>
            <remarks>
            <para>
            Note that these are all multiplicative factors -- to do the conversion, you multiply by
            the numbers given below.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UnitConversion.PartUnitsToMillimeters">
            <summary>Multiply by this number to convert Part Units to Millimeters (1 or 25.4)</summary>
        </member>
        <member name="P:Snap.UnitConversion.MillimetersToPartUnits">
            <summary>Multiply by this number to convert Millimeters to Part Units (1 or 0.04)</summary>
        </member>
        <member name="P:Snap.UnitConversion.PartUnitsToInches">
            <summary>Multiply by this number to convert Part Units to Inches (1 or 0.04) </summary>
        </member>
        <member name="P:Snap.UnitConversion.InchesToPartUnits">
            <summary>Multiply by this number to convert Inches to Part Units (either 1 or 25.4)</summary>
        </member>
        <member name="P:Snap.UnitConversion.PartUnitsToMeters">
            <summary>Multiply by this number to convert Part Units to Meters, to go to Parasolid (0.001 or 0.0254)</summary>
        </member>
        <member name="P:Snap.UnitConversion.MetersToPartUnits">
            <summary>Multiply by this number to convert Meters to Part Units, when coming from Parasolid (1000 or 40)</summary>
        </member>
        <member name="P:Snap.UnitConversion.PartUnitsToPoints">
            <summary>Multiply by this number to convert Part Units to Points (for font sizes)</summary>
        </member>
        <member name="P:Snap.UnitConversion.PointsToPartUnits">
            <summary>Multiply by this number to convert Points to Part Units (for font sizes)</summary>
        </member>
        <member name="T:Snap.UnloadOption">
            <summary>
            Indicates when you want the system to unload your application library from a running NX session.
            </summary>
            <remarks>
            <para>
            This enum is exactly equivalent to NXOpen.Session.LibraryUnloadOption.
            </para>
            <para>
            To use it, you should implement a static function called GetUnloadOption in 
            the same class or module as the "Main" function of your application, as shown in the
            example below. NX will call this function to determine how it should unload
            your application library.
            </para>
            <para>
            The GetUnloadOption function is not needed when running an application from the NX
            Journal Editor. In this scenario, the "Immediately" setting is always used.
            </para>
            <para>
            If you base your application on a SNAP template in Visual Studio, then you don't have to 
            write the GetUnloadOption function, because the template already includes it.
            </para>
            </remarks>
            <example> 
            This example shows how to use the UnloadOption enum:
            <code title="Using UnloadOption: " lang="VB.NET" source="Unload_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="F:Snap.UnloadOption.Immediately">
            <summary>
            You want the system to unload the library as soon as your application program has finished running.
            </summary>
            <remarks>
            <para>
            This setting is very convenient when you are developing and debugging your application. But loading and
            unloading the library takes a little time, so this may not be suitable for an application that is finished
            and being used in production.
            </para>
            <para>
            If your application is using the Show() method to display a winform, then it should not use the 
            Immediately setting, since this will cause the winform to disappear immediately after it is displayed.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.UnloadOption.Explicitly">
            <summary>
            You will unload the library yourself, using the "Unload Shared Image" command in File-->Utilities.
            </summary>
        </member>
        <member name="F:Snap.UnloadOption.AtTermination">
            <summary>
            You want the system to unload the library when the current NX session terminates. 
            </summary>
            <remarks>
            <para>
            This is usually the best setting for an application that is being used in production. It enhances 
            performance (though usually only slightly) because your application is loaded into memory only once,
            regardless of how many times it is executed.
            </para>
            <para>
            The AtTermination setting is used as the default if you do not provide a GetUnloadOption function.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Create">
            <summary>Provides functions for creating NX objects in the Work Part</summary>
        </member>
        <member name="M:Snap.Create.Widget">
            <summary>Creates a "widget" body for examples and testing</summary>
            <returns>An NX.Body</returns>
            <remarks>
            <para>
            The widget object is shown in the pictures below.
            </para>
            <para>
            <img src="../Images/widget.png"/>
            </para>
            <para>
            This object is useful for examples and testing because it has many different 
            types of faces and edges. The faces are named, for easy reference in example
            code, as outlined below.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Face Name</term>
            <description>Face Description</description>
            </listheader>
            <item><term>CYAN_REVOLVED</term><description>Revolved face on left end</description></item>
            <item><term>MAGENTA_TORUS_BLEND</term><description>Toroidal face with minor radius = 10</description></item>
            <item><term>TEAL_CONE</term><description>Large conical face</description></item>
            <item><term>YELLOW_SPHERE</term><description>Spherical face with diameter = 15</description></item>
            <item><term>PINK_CYLINDER_HOLE</term><description>Cylindrical hole with diameter = 20</description></item>  
            <item><term>RED_BSURFACE_BLEND</term><description>B-surface representing a variable radius blend</description></item>      
            <item><term>BLUE_CYLINDER_VERTICAL</term><description>Vertical cylindrical face with diameter = 30</description></item>     
            <item><term>TAN_PLANE_TOP</term><description>Planar face on top</description></item>       
            <item><term>ORANGE_BLEND</term><description>Blend face with radius = 7</description></item> 
            <item><term>GREEN_EXTRUDED</term><description>Extruded face on right-hand end</description></item> 
            <item><term>GREY_PLANE_BACK</term><description>Large planar face on back</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Create.Arc(Snap.Position,System.Double,System.Double,System.Double)">
            <summary>Constructs a Snap.NX.Arc parallel to the XY-plane</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="radius">Radius</param>
            <param name="angle1">Start angle (in degrees)</param>
            <param name="angle2">End angle (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <remarks>
            <para>
            The arc will have its center at the given point, and will be parallel to the XY-plane.
            </para>
            <para>
            If the center point does not lie in the XY-plane, then the arc will not, either.
            </para>
            </remarks>      
            <example> 
            This example shows how to create an arc: 
            <code title="Create an arc" lang="VB.NET" source="Arc_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Arc(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs a Snap.NX.Arc lying in the XY-plane</summary>
            <param name="cx">X-coordinate of center point (in absolute coordinates)</param>
            <param name="cy">Y-coordinate of center point (in absolute coordinates)</param>
            <param name="radius">Radius</param>
            <param name="angle1">Start angle (in degrees)</param>
            <param name="angle2">End angle (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create an arc: 
            <code title="Create an arc" lang="VB.NET" source="Arc_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Arc(Snap.Position,Snap.Orientation,System.Double,System.Double,System.Double)">
            <summary>Constructs a Snap.NX.Arc from center, rotation matrix, radius, angles</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="matrix">Orientation</param>
            <param name="radius">Radius</param>
            <param name="angle1">Start angle (in degrees)</param>
            <param name="angle2">End angle (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create an arc: 
            <code title="Create an arc" lang="VB.NET" source="Arc_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Arc(Snap.Position,Snap.Vector,Snap.Vector,System.Double,System.Double,System.Double)">
            <summary>Constructs a Snap.NX.Arc from center, axes, radius, angles</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="radius">Radius</param>
            <param name="angle1">Start angle (in degrees)</param>
            <param name="angle2">End angle (in degrees)</param>
            <returns> A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create an arc: 
            <code title="Create an arc" lang="VB.NET" source="Arc_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Fillet(Snap.Position,Snap.Position,Snap.Position,System.Double)">
            <summary>Constructs a fillet arc from three points</summary>
            <param name="p0">First point</param>
            <param name="pa">Apex point</param>
            <param name="p1">Last point</param>
            <param name="radius">Radius</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <remarks>
            <para>
            The fillet will be tangent to the lines p0-pa and pa-p1.
            Its angular span will we be less than 180 degrees.
            </para>
            </remarks>
            <example> 
            This example shows how to create a fillet arc: 
            <code title="Create a fillet arc" lang="VB.NET" source="Arc_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Fillet(Snap.NX.Curve,Snap.NX.Curve,System.Double,Snap.Position,System.Boolean)">
            <summary>Creates a fillets between two given curves</summary>
            <param name="curve1">First curve for the fillet</param>
            <param name="curve2">Second curve for the fillet</param>
            <param name="radius">Radius of the fillet</param>
            <param name="center">Approximate fillet center</param>
            <param name="doTrim">Indicates whether the input curves should get trimmed by the fillet. Optional. Default = True</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create a fillet arc: 
            <code title="Create a fillet arc" lang="VB.NET" source="Arc_07.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Arc(Snap.Position,Snap.Position,Snap.Position)">
            <summary>Creates an NX.Arc from three points</summary>
            <param name="startPoint">Start point</param>
            <param name="throughPoint">Point that the arc passes through</param>
            <param name="endPoint">End point</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create an arc: 
            <code title="Create an arc" lang="VB.NET" source="Arc_06.vb">
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.BezierCurve(Snap.Position[],System.Double[])">
            <summary>Creates a rational Bezier curve from given poles and weights</summary>
            <param name="poles">Array of m+1 poles (3D)</param>
            <param name="weights">Array of m+1 weights</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object of degree m (order m+1)</returns>
            <example> 
            This example shows how to create rational Bezier curves: 
            <code title="Create rational Bezier curves" lang="VB.NET" source="BezierCurve_02.vb"> 
            </code> 
            <para>
            The following picture shows the results of the program:
            </para>
            <img src="../Images/BezierCurve_02.png"/>
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>
            <seealso cref="O:Snap.Create.BezierCurveThroughPoints">Snap.Create.BezierCurveThroughPoints</seealso>
            <seealso cref="M:Snap.Create.BezierCurveFit(Snap.Create.CurvePositionFunction,System.Object,System.Int32)">Snap.Create.BezierCurveFit</seealso>
        </member>
        <member name="M:Snap.Create.BezierCurve(Snap.Position[])">
            <summary>Creates a Bezier curve from given poles</summary>
            <param name="poles">Array of m+1 poles (3D)</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object of degree m (order m+1)</returns>
            <example> 
            This example shows how to create a Bezier curve: 
            <code title="Create a Bezier curve" lang="VB.NET" source="BezierCurve_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>      
        </member>
        <member name="M:Snap.Create.BezierCurve(Snap.NX.Point[])">
            <summary>Creates a Bezier curve using given points as poles</summary>
            <param name="poles">Array of m+1 poles (3D)</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object of degree m (order m+1)</returns>
            <example> 
            This example shows how to create a Bezier curve: 
            <code title="Create a Bezier curve" lang="VB.NET" source="BezierCurve_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>      
        </member>
        <member name="M:Snap.Create.BezierCurve(Snap.Position,Snap.Vector,Snap.Position,Snap.Vector)">
            <summary>Creates a cubic Bezier curve from two points and two directions</summary>
            <param name="p0">Start point of curve</param>
            <param name="u0">Tangent direction at start point (unit vector)</param>
            <param name="p1">End point of curve</param>
            <param name="u1">Tangent direction at end point (unit vector)</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            Uses an algorithm due to John D. Hobby, Journal of Discrete and Computational Geometry, 1986.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bezier curve: 
            <code title="Create a Bezier curve" lang="VB.NET" source="BezierCurve_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>
        </member>
        <member name="M:Snap.Create.BezierCurveThroughPoints(Snap.Position[],System.Double[])">
            <summary>Creates a Bezier curve interpolating (passing through) a given sequence of points</summary>
            <param name="intPoints">The n points to be interpolated</param>
            <param name="nodes">The n parameter values (nodes) at which to interpolate</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <example> 
            This example shows how to create a Bezier curve through points: 
            <code title="Create a Bezier curve through points" lang="VB.NET" source="BezierCurve_01.vb"> 
            </code> 
            </example>
            <para>
            The following picture shows the result of the example:
            </para>
            <img src="../Images/BezierCurve_01.png"/>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>      
        </member>
        <member name="M:Snap.Create.BezierCurveThroughPoints(Snap.Position[])">
            <summary>Creates a Bezier curve interpolating (passing through) a given sequence of points</summary>
            <param name="intPoints">The n points to be interpolated</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> of degree n - 1 object</returns>
            <example> 
            This example shows how to create a Bezier curve: 
            <code title="Create a Bezier curve" lang="VB.NET" source="BezierCurve_01.vb"> 
            </code> 
            <para>
            The following picture shows the result of the example:
            </para>
            <img src="../Images/BezierCurve_01.png"/>
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>      
        </member>
        <member name="M:Snap.Create.BezierCurveFit(Snap.Create.CurvePositionFunction,System.Object,System.Int32)">
            <summary>Bezier approximation of a curve given by a function</summary>
            <param name="f">Evaluator function that returns positions on curve</param>
            <param name="data">Data to be passed when calling evaluator function</param>
            <param name="m">Degree of desired curve</param>
            <returns>Degree m Bezier curve approximating the given function</returns>
            <remarks>
            <para>
            To approximate a given curve, you could just create points on it, and then create
            a spline curve through those points. However, the distribution of the points can
            significantly impact the quality of the approximation. The approach used here
            frees you from the responsibility of choosing a good point distribution. To
            use this approach, you must provide a function that returns a position at
            a given parameter value on the curve you want to approximate.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bezier curve that approximates a 
            special curve called a catenary:
            <code title="Approximating a catenary" lang="VB.NET" source="BezierCurveFit_01.vb"> 
            </code> 
            This example shows how to create a Bezier curve that approximates an offset curve:
            <code title="Approximating an offset curve" lang="VB.NET" source="BezierCurveFit_02.vb"> 
            </code> 
            <para>
            The following picture shows the results of the program:
            </para>
            <img src="../Images/BezierCurveFit_02.png"/>
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>
        </member>
        <member name="T:Snap.Create.CurvePositionFunction">
            <summary>A function that evaluates a position at a point on a curve</summary>
            <param name="data">Data item to be used in evaluation</param>
            <param name="t">Parameter value at which to evaluate (in range 0 to 1)</param>
            <returns>Position on curve at given parameter value</returns>
            <remarks>
            <para>
            You use a CurvePositionFunction when constructing approximating curves using 
            the <see cref="M:Snap.Create.BezierCurveFit(Snap.Create.CurvePositionFunction,System.Object,System.Int32)">BezierCurveFit</see> function.
            </para>
            </remarks>
            <seealso cref="M:Snap.Create.BezierCurveFit(Snap.Create.CurvePositionFunction,System.Object,System.Int32)">BezierCurveFit</seealso>
        </member>
        <member name="M:Snap.Create.ApproxCurveDeriv(Snap.Create.CurvePositionFunction,System.Object,System.Double)">
            <summary>Evaluates approximate first derivative at a point on a curve</summary>
            <param name="f">Position evaluator</param>
            <param name="curveData">Data to be used in evaluation</param>
            <param name="t">Parameter value at which to evaluate (in range 0 to 1)</param>
            <returns>First derivative vector</returns>
            <remarks>Uses a central difference approximation</remarks>
        </member>
        <member name="T:Snap.Create.ChebyshevConstants">
            <summary>Numerical constants for use in Chebyshev approximation</summary>
        </member>
        <member name="M:Snap.Create.ChebyshevConstants.InterpolationMatrix(System.Int32)">
            <summary>
            Returns the interpolation matrix for constrained
            Chebyshev interpolation with a degree m Bezier curve
            </summary>
            <param name="m">Degree of interpolating curve</param>
            <returns>Interpolation matrix</returns>
            <remarks>
            <para>
            The matrix will have size m+1 by m+1
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Create.ChebyshevConstants.Zeros(System.Int32)">
            <summary>
            Zeros of constrained Chebyshev polynomials.
            </summary>
            <param name="m">Degree of interpolating curve</param>
            <returns>Zeros of constrained Chebyshev polynomial of degree m</returns>
            <remarks>
            <para>
            These are used as nodes when doing Chebyshev interpolation
            with matching of start/end points and start/end first derivatives.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Create.BezierPatch(Snap.Position[0:,0:],System.Double[0:,0:])">
            <summary>Creates a rational Bezier patch</summary>
            <param name="poles">A 2D array of (mu+1) x (mv+1) 3D positions representing poles</param>
            <param name="weights">A 2D array of (mu+1) x (mv+1) values representing weights</param>
            <returns>A rational Bezier patch of degree mu x mv</returns>
            <remarks>
            <para>
            The object returned is a <see cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</see>, which is a body having a single face.
            </para>
            </remarks>
            <example> 
            This example shows how to create a rational Bezier patch: 
            <code title="Create a rational Bezier patch" lang="VB.NET" source="BezierPatch_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.BezierPatch(Snap.Position[0:,0:])">
            <summary>Creates a polynomial Bezier patch</summary>
            <param name="poles">A 2D array of (mu+1) x (mv+1) 3D positions representing poles</param>
            <returns>A polynomial Bezier patch of degree mu x mv</returns>
            <remarks>
            <para>
            The object returned is a <see cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</see>, which is a body having a single face.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bezier patch: 
            <code title="Create a Bezier patch" lang="VB.NET" source="BezierPatch_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.BezierPatchThroughPoints(Snap.Position[0:,0:],System.Double[],System.Double[])">
            <summary>Creates a Bezier patch interpolating (passing through) a given array of points</summary>
            <param name="intPoints">A 2D array of (mu+1) x (mv+1) 3D points to be interpolated</param>
            <param name="nodesU">The mu+1 u-values (nodes) at which to interpolate</param>
            <param name="nodesV">The mv+1 v-values (nodes) at which to interpolate</param>
            <returns>A Bezier patch interpolating the given points at the given (u,v) values</returns>
            <remarks>
            <para>
            The points are interpolated at the given node values. Specifically, the surface passes
            through the point intPoints[i,j] at the parameter values (u, v) = ( nodesU[i], nodesV[j] ).
            </para>
            <para>
            If you have no good way to specify node values, it may be better to use a different
            BezierPatchThroughPoints function that does not require nodes as input.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bezier patch: 
            <code title="Create a Bezier patch" lang="VB.NET" source="BezierPatch_03.vb"> 
            </code> 
            </example>     
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.BezierPatchThroughPoints(Snap.Position[0:,0:])">
            <summary>Creates a Bezier patch interpolating (passing through) a given array of points</summary>
            <param name="intPoints">A 2D array of (mu+1) x (mv+1) 3D points to be interpolated</param>
            <returns>A Bezier patch interpolating the given points</returns>
            <example> 
            This example shows how to create a Bezier patch: 
            <code title="Create a Bezier patch" lang="VB.NET" source="BezierPatch_03.vb"> 
            </code> 
            </example>     
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.BezierSpherePatch(Snap.Position,Snap.Orientation,System.Double)">
            <summary>
            Create a Bezier patch representing one sixth of a sphere
            </summary>
            <param name="center">The center of the sphere</param>
            <param name="matrix">An orientation matrix, explained below</param>
            <param name="radius">The radius of the spherical patch</param>
            <returns>A Bezier patch of degrees 4x4 representing one sixth of a sphere</returns>
            <remarks>
            <para>
            This function is mostly for testing  and for creating simple examples.
            </para>
            <para>
            The middle point of the patch will be at center + radius*matrix.AxisZ, and
            the patch will be symmetric in the X and Y directions of the orientation.</para>
            </remarks>
            <example> 
            This example shows how to create a sphere from 6 Bezier patches: 
            <code title="Create a Bezier sphere" lang="VB.NET" source="BezierPatch_04.vb"> 
            </code> 
            </example>     
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
            <seealso cref="T:Snap.NX.Sphere">Snap.NX.Sphere</seealso> 
        </member>
        <member name="M:Snap.Create.BezierPatchFit(Snap.Create.SurfacePositionFunction,System.Object,System.Int32,System.Int32)">
            <summary>Bezier patch approximation of a surface given by a function</summary>
            <param name="f">Evaluator function that returns positions on surface</param>
            <param name="data">Data to be passed when calling evaluator function</param>
            <param name="mu">Degree of desired surface in u-direction</param>
            <param name="mv">Degree of desired surface in v-direction</param>
            <returns>Bezier patch of degree mu x mv approximating the given function</returns>
            <remarks>
            <para>
            To approximate a given surface, you could just create points on it, and then create
            a surface through those points. However, the distribution of the points can
            significantly impact the quality of the approximation. The approach used here
            frees you from the responsibility of choosing a good point distribution. To
            use this approach, you must provide a function that returns a position at
            a given parameter value on the surface you want to approximate.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bezier surface that approximates a 
            hump-shaped function:
            <code title="Approximating a hump function" lang="VB.NET" source="BezierPatchFit_01.vb"> 
            </code> 
            <para>
            The following picture shows the results of the program, with curvature analysis:
            </para>
            <img src="../Images/BezierPatchFit.png"/>
            </example>
        </member>
        <member name="M:Snap.Create.BezierPatchFit(Snap.Position[0:,0:],Snap.Vector[0:,0:],Snap.Vector[0:,0:],Snap.Vector[0:,0:])">
            <summary>Create an approximating Bezier patch by Chebyshev interpolation</summary>
            <param name="q">Points to be interpolated (an m-1 by m-1 array)</param>
            <param name="a">Partial derivs wrt v along v=0 and v=1 edges (m-1 values along each edge)</param>
            <param name="b">Partial derivs wrt u along u=0 and u=1 edges (m-1 values along each edge)</param>
            <param name="c">Mixed partials at corners (4 values)</param>
            <returns>Poles of approximating patch of degree m</returns>
        </member>
        <member name="T:Snap.Create.SurfacePositionFunction">
            <summary>A function that evaluates a position at a location on a surface</summary>
            <param name="data">Data item to be used in evaluation</param>
            <param name="uv">Parameter values at which to evaluate (in range [0,1] x [0,1])</param>
            <returns>Position on surface at given parameter value</returns>
            <remarks>
            <para>
            You use a SurfacePositionFunction when constructing approximating surfaces using 
            the <see cref="M:Snap.Create.BezierPatchFit(Snap.Create.SurfacePositionFunction,System.Object,System.Int32,System.Int32)">BezierPatchFit</see> function.
            </para>
            </remarks>
            <seealso cref="M:Snap.Create.BezierPatchFit(Snap.Create.SurfacePositionFunction,System.Object,System.Int32,System.Int32)">BezierPatchFit</seealso>
        </member>
        <member name="M:Snap.Create.ApproxSurfaceDeriv(Snap.Create.SurfacePositionFunction,System.Object,System.Double,System.Double[])">
            <summary>Evaluates approximate first derivatives at a location on a surface</summary>
            <param name="f">Position evaluator</param>
            <param name="surfaceData">Data to be used in evaluation</param>
            <param name="h">Step size for derivative approximation</param>
            <param name="uv">Parameter values at which to evaluate (in range [0,1] x [0,1])</param>
            <returns>Approximate derivative vectors dS/du, dS/dv</returns>
            <remarks>Uses a central difference approximation</remarks>
        </member>
        <member name="M:Snap.Create.ApproxSurfaceDeriv2(Snap.Create.SurfacePositionFunction,System.Object,System.Double,System.Double[])">
            <summary>Evaluates approximate mixed partial derivative at a location on a surface</summary>
            <param name="f">Position evaluator</param>
            <param name="surfaceData">Data to be used in evaluation</param>
            <param name="h">Step size for derivative approximation</param>
            <param name="uv">Parameter values at which to evaluate (in range [0,1] x [0,1])</param>
            <returns>Approximate mixed partial derivative d2S/dudv</returns>
            <remarks>Uses a central difference approximation</remarks>
        </member>
        <member name="M:Snap.Create.Block(Snap.Position,Snap.Orientation,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a Snap.NX.Block feature from origin, orientation, xLength, yLength, zLength</summary>
            <param name="origin">The corner-point of the block (in absolute coordinates)</param>
            <param name="matrix">Orientation (see remarks)</param>
            <param name="xLength">Length in x-direction</param>
            <param name="yLength">Length in y-direction</param>
            <param name="zLength">Length in z-direction</param>        
            <returns>A <see cref="T:Snap.NX.Block">Snap.NX.Block</see> object</returns>
            <remarks>
            <para>
            The edges of the block will be parallel to the vectors matrix.AxisX, matrix.AxisY, matrix.AxisZ.
            </para>
            </remarks>
            <example> 
            This example shows how to create a block feature: 
            <code title="Create a block feature" lang="VB.NET" source="Block_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Block">Snap.NX.Block</seealso>
        </member>
        <member name="M:Snap.Create.Block(Snap.Position,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a Snap.NX.Block feature from origin, xLength, yLength, zLength</summary>
            <param name="origin">The corner-point of the block (in absolute coordinates</param>
            <param name="xLength">Length in x-direction</param>
            <param name="yLength">Length in y-direction</param>
            <param name="zLength">Length in z-direction</param>        
            <returns>A <see cref="T:Snap.NX.Block">Snap.NX.Block</see> object</returns>
            <remarks>
            <para>
            The faces and edges of the block will be aligned with the axes of the absolute coordinate system.
            </para>
            </remarks>
            <example> 
            This example shows how to create a block feature: 
            <code title="Create a block feature" lang="VB.NET" source="Block_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Block">Snap.NX.Block</seealso>
        </member>
        <member name="M:Snap.Create.Block(Snap.Orientation,Snap.Position,Snap.Position,Snap.Number)">
            <summary>Creates a Snap.NX.Block feature from two points and height</summary>
            <param name="matrix">Orientation (see remarks)</param>
            <param name="originPoint">The origin-point of the block (in absolute coordinates</param>       
            <param name="cornerPoint">The corner-point of the block (on the base of the block, opposite the origin point)</param>        
            <param name="height">Length in z-direction</param>        
            <returns>A <see cref="T:Snap.NX.Block">Snap.NX.Block</see> object</returns>
            <example> 
            This example shows how to create a block feature: 
            <code title="Create a block feature" lang="VB.NET" source="Block_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Block">Snap.NX.Block</seealso>
        </member>
        <member name="M:Snap.Create.Block(Snap.Orientation,Snap.Position,Snap.Position)">
            <summary>Creates a Snap.NX.Block feature from two diagonal points</summary>
            <param name="matrix">Orientation (see remarks)</param>
            <param name="originPoint">The origin-point of the block (in absolute coordinates</param>        
            <param name="cornerPoint">Corner point, diagonally opposite the origin point</param>                
            <returns>A <see cref="T:Snap.NX.Block">Snap.NX.Block</see> object</returns>
            <example> 
            This example shows how to create a block feature: 
            <code title="Create a block feature" lang="VB.NET" source="Block_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Block">Snap.NX.Block</seealso>
        </member>
        <member name="M:Snap.Create.Unite(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Unites an array of tool bodies with a target body</summary>
            <param name="targetBody">Target body</param>
            <param name="toolBodies">Array of tool bodies</param>
            <returns><see cref="T:Snap.NX.Boolean">Snap.NX.Boolean</see> feature formed by uniting tools with target</returns>
            <example> 
            The following example shows how to unite an array of tool bodies with a target body: 
            <code title="Unite bodies" lang="VB.NET" source="Boolean_01.vb">
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Boolean">Snap.NX.Boolean</seealso>
        </member>
        <member name="M:Snap.Create.Subtract(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Subtracts an array of tool bodies from a target body</summary>
            <param name="targetBody">Target body</param>
            <param name="toolBodies">Array of tool bodies</param>
            <returns><see cref="T:Snap.NX.Boolean">Snap.NX.Boolean</see> feature formed by subtracting tools from target</returns>
            <example> 
            The following example shows how to subtracts an array of tool bodies from a target body
            <code title="Subtract bodies" lang="VB.NET" source="Boolean_02.vb">
            </code>
            </example>
            <seealso cref="T:Snap.NX.Boolean">Snap.NX.Boolean</seealso>
        </member>
        <member name="M:Snap.Create.Intersect(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Intersects an array of tool bodies with a target body</summary>
            <param name="targetBody">Target body</param>
            <param name="toolBodies">Array of tool bodies</param>
            <returns><see cref="T:Snap.NX.Boolean">Snap.NX.Boolean</see> feature formed by intersecting tools with target</returns>
            <example> 
            The following example shows how to intersect an array of tool bodies with a target body: 
            <code title="Intersect bodies" lang="VB.NET" source="Boolean_03.vb">
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Boolean">Snap.NX.Boolean</seealso>
        </member>
        <member name="M:Snap.Create.BoundedPlane(Snap.NX.Curve[])">
            <summary>Creates a BoundedPlane object</summary>
            <param name="boundingCurves">Array of curves forming the boundary</param>      
            <returns> A <see cref="T:Snap.NX.BoundedPlane">Snap.NX.BoundedPlane</see> object</returns>
            <remarks>
            <para>
            The boundary curves are input in a single list, which can include both periphery curves
            and curves bounding holes. The order of the curves in the array does not matter.
            </para>
            </remarks>
            <example>
            The following example creates a bounded plane: 
            <code title="Create a bounded plane" lang="VB.NET" source="BoundedPlane_01.vb">        
            </code>
            </example>
            <seealso cref="T:Snap.NX.BoundedPlane">Snap.NX.BoundedPlane</seealso>
        </member>
        <member name="M:Snap.Create.Bsurface(Snap.Position[0:,0:],System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a rational b-surface from poles, weights, and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D poles</param>
            <param name="weights">A 2D array of nu x nv weights</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <returns>A <see cref="T:Snap.NX.Bsurface">NX.Bsurface</see> object, which is a body having a single face.</returns>  
            <remarks>        
            <para>
            For further details, please see the documentation for the <see cref="T:Snap.NX.Bsurface">NX.Bsurface</see> object.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bsurface: 
            <code title="Create a Bsurface" lang="VB.NET" source="Bsurface_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.Bsurface(Snap.Geom.Surface.Bsurface)">
            <summary>Constructs a Snap.NX.Bsurface from a Snap.Geom.Surface.Bsurface</summary>
            <param name="geom">A Snap.Geom.Surface.Bsurface</param>
            <returns>A <see cref="T:Snap.NX.Bsurface">NX.Bsurface</see> object, which is a body having a single face.</returns>  
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
            <seealso cref="T:Snap.Geom.Surface.Bsurface">Snap.Geom.Surface.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.Bsurface(Snap.Position[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a polynomial b-surface from poles and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D poles</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <returns>A <see cref="T:Snap.NX.Bsurface">NX.Bsurface</see> object, which is a body having a single face.</returns>  
            <remarks>        
            <para>
            For further details, please see the documentation for the <see cref="T:Snap.NX.Bsurface">NX.Bsurface</see> object.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bsurface: 
            <code title="Create a Bsurface" lang="VB.NET" source="Bsurface_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.BsurfaceThroughPoints(Snap.Position[0:,0:],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>Creates a Bsurface interpolating (passing through) a given array of points</summary>
            <param name="intPoints">An nu x nv array of points to be interpolated</param>
            <param name="nodesU">The nu parameter u-values (nodes) at which to interpolate</param>
            <param name="nodesV">The nv parameter v-values (nodes) at which to interpolate</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <returns>A Bsurface interpolating the given points at the given (u,v) values</returns>
            <remarks>
            <para>
            To use this function, you have to be somewhat familiar with b-spline technology, so it is not
            intended for beginners. If you've never heard of nodes or knots, and you don't know how to
            choose reasonable values for them, you should use the simpler version of BsurfaceThroughPoints,
            which does require you to specify nodes and knots.
            </para>
            </remarks>
            <example> 
            This example shows how to create a Bsurface: 
            <code title="Create a Bsurface" lang="VB.NET" source="Bsurface_04.vb"> 
            </code> 
            <para>
            The following picture shows the result of the example:
            </para>
            <img src="../Images/Bsurface_04.png"/>
            </example>
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.BsurfaceThroughPoints(Snap.Position[0:,0:],System.Int32,System.Int32)">
            <summary>Creates a Bsurface interpolating (passing through) a given array of points</summary>
            <param name="intPoints">An nu x nv array of points to be interpolated</param>
            <param name="degreeU">The degree of the desired surface in the u-direction</param>
            <param name="degreeV">The degree of the desired surface in the v-direction</param>
            <returns>A <see cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</see> object passing through the given points</returns>
            <remarks>
            <para>
            For most purposes, a surface of degree 3&#215;3 works fine.
            </para>
            <para>
            If we denote the intPoints array by q, for brevity, then ...
            <para>
            </para>
            The points q[0,0], q[0,1], ... ,q[0,nv] will lie along edge u = 0  (0 &lt; v &lt; 1)
            </para>
            <para>
            The points q[0,0], q[1,0], ... ,q[nu,0] will lie along edge v = 0  (0 &lt; u &lt; 1)
            </para>
            So, in particular, if S(u,v) denotes the surface position at parameters u,v, then
            <list type = "bullet">
            <item>S(0,0) = q[0,0]   = </item>
            <item>S(0,1) = q[0,nv]  = </item>
            <item>S(1,0) = q[nu,0]  = </item>
            <item>S(1,1) = q[nu,nv] = </item>
            </list>
            </remarks>
            <example> 
            The following example creates a b-surface through points:
            <code title="Create a b-surface through points" lang="VB.NET" source="Bsurface_03.vb"> 
            </code>
            <para>
            The following picture shows the result of the example:
            </para>
            <img src="../Images/Bsurface_03.png"/>
            </example>
            <seealso cref="T:Snap.NX.Bsurface">Snap.NX.Bsurface</seealso>
        </member>
        <member name="M:Snap.Create.Category(System.String,System.String,System.Int32[])">
            <summary>Creates a layer category</summary>
            <param name="name">Name to be assigned to the new category</param>
            <param name="description">Description of layer category</param>
            <param name="layers">Layers to be placed into the category</param>
            <returns>An NX.Category object </returns>
            <remarks>
            <para>
            Two categories with the same name are not allowed in a given part file.
            So, if a category with the given name already exists in the work part, then this function will fail. 
            An exception will be raised, no new category will be created, and the function will return <c>Nothing</c>.
            </para>
            </remarks>
            <example> 
            This example shows how to create a layer category: 
            <code title="Create a layer category" lang="VB.NET" source="Category_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Category">Snap.NX.Category</seealso>
            <exception cref="T:System.ArgumentException">A category with the given name already exists.</exception>
        </member>
        <member name="M:Snap.Create.Chamfer(Snap.NX.Edge,Snap.Number,System.Boolean)">
            <summary>Creates a symmetric Snap.NX.Chamfer feature with a given offset distance</summary>
            <param name="edge">The edge to be chamfered</param>
            <param name="distance">Offset distance</param>
            <param name="offsetFaces">The offsetting method used (see remarks below)</param>
            <returns> A <see cref="T:Snap.NX.Chamfer">Snap.NX.Chamfer</see> feature</returns>
            <remarks>
            <para>
            The offsetFaces parameter indicates the offsetting method used to determine the size of the chamfer.
            <list type = "bullet">
            <item>If true, the edges of the chamfer face will be constructed by offsetting the faces adjacent to the selected edge</item>
            <item>If false, the edges of the chamfer face will be constructed by offsetting the selected edge along the adjacent faces</item>
            </list>
            </para>
            </remarks>
            <example> 
            This example shows how to chamfer an edge: 
            <code title="Chamfer an edge" lang="VB.NET" source="Chamfer_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Chamfer">Snap.NX.Chamfer</seealso>
        </member>
        <member name="M:Snap.Create.Chamfer(Snap.NX.Edge,Snap.Number,Snap.Number,System.Boolean)">
            <summary>Creates an asymmetric Snap.NX.Chamfer feature using two given offset distances</summary>
            <param name="edge">The edge to be chamfered</param>
            <param name="distance1">Offset distance1</param>
            <param name="distance2">Offset distance2</param>
            <param name="offsetFaces">The offsetting method used (see remarks below)</param>
            <returns> A <see cref="T:Snap.NX.Chamfer">Snap.NX.Chamfer</see> feature</returns>
            <remarks>
            <para>
            The offsetFaces parameter indicates the offsetting method used to determine the size of the chamfer
            <list type = "bullet">
            <item>If true, the edges of the chamfer face will be constructed by offsetting the faces adjacent to the selected edge</item>
            <item>If false, the edges of the chamfer face will be constructed by offsetting the selected edge along the adjacent faces</item>
            </list>
            </para>
            </remarks>
            <example> 
            This example shows how to chamfer an edge: 
            <code title="Chamfer an edge" lang="VB.NET" source="Chamfer_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Chamfer">Snap.NX.Chamfer</seealso>
        </member>
        <member name="M:Snap.Create.Chamfer(Snap.NX.Edge,Snap.Number,Snap.Number)">
            <summary>Creates a Snap.NX.Chamfer feature with a given offset distance and angle</summary>
            <param name="edge">The edge to be chamfered</param>
            <param name="distance">Offset distance</param>
            <param name="angle">Offset angle</param>           
            <returns> A <see cref="T:Snap.NX.Chamfer">Snap.NX.Chamfer</see> feature</returns>
            <example> 
            This example shows how to chamfer an edge: 
            <code title="Chamfer an edge" lang="VB.NET" source="Chamfer_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Chamfer">Snap.NX.Chamfer</seealso>
        </member>
        <member name="M:Snap.Create.Circle(Snap.Position,Snap.Vector,Snap.Vector,System.Double)">
            <summary>Constructs circle from center, axes, radius</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="radius">Radius</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create a circle: 
            <code title="Create a circle" lang="VB.NET" source="Circle_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Circle(Snap.Position,Snap.Orientation,System.Double)">
            <summary>Constructs a circle from center, rotation matrix, radius</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="matrix">Orientation matrix</param>
            <param name="radius">Radius</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create a circle: 
            <code title="Create a circle" lang="VB.NET" source="Circle_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Circle(Snap.Position,System.Double)">
            <summary>Constructs a circle parallel to the XY-plane</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="radius">Radius</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <remarks>
            <para>
            The circle will have its center at the given point, and will be parallel to the XY-plane.
            </para>
            <para>
            If the center point does not lie in the XY-plane, then the circle will not, either.
            </para>
            </remarks>      
            <example> 
            This example shows how to create a circle: 
            <code title="Create a circle" lang="VB.NET" source="Circle_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Circle(System.Double,System.Double,System.Double)">
            <summary>Constructs a circle lying in the XY-plane</summary>
            <param name="cx">X-coordinate of center point (in absolute coordinates)</param>
            <param name="cy">Y-coordinate of center point (in absolute coordinates)</param>
            <param name="radius">Radius</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <example> 
            This example shows how to create a circle: 
            <code title="Create a circle" lang="VB.NET" source="Circle_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Circle(Snap.Position,Snap.Vector,System.Double)">
            <summary>Constructs a circle from center, normal, radius</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisZ">Unit vector normal to plane of circle</param>
            <param name="radius">Radius</param>
            <returns>A <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <remarks>
            <para>
            This function gives you no control over how the circle is parameterized. You don't 
            provide the X-axis, so you can't specify at which point the angle parameter is zero
            </para>
            </remarks>
            <example> 
            This example shows how to create a circle: 
            <code title="Create a circle" lang="VB.NET" source="Circle_06.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.Circle(Snap.Position,Snap.Position,Snap.Position)">
            <summary>Creates a circle through three points</summary>
            <param name="p1">First point</param>
            <param name="p2">Second point</param>
            <param name="p3">Third point</param>
            <returns>Circle (360 degrees) passing through the 3 points</returns>
            <example> 
            This example shows how to create a circle: 
            <code title="Create a circle" lang="VB.NET" source="Circle_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.Create.ConeFromDiametersHeight(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, axis vector, base diameter, top diameter and height</summary>        
            <param name="axisPoint">The cone axis position (center of base arc)</param>
            <param name="axisVector">The cone axis vector</param>
            <param name="baseDiameter">The cone base diameter</param>
            <param name="topDiameter">The cone top diameter</param>
            <param name="height">The cone height</param>
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example> 
            The following example creates a cone feature: 
            <code title="Create a cone feature" lang="VB.NET" source="Cone_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.Cone(Snap.Position,Snap.Vector,Snap.Number[],Snap.Number)">
            <summary>Creates a cone feature, given cone base position, axis vector, base diameter, top diameter and height</summary>        
            <param name="axisPoint">The cone axis position (center of base arc)</param>
            <param name="axisVector">The cone axis vector</param>
            <param name="diameters">A two dimension array. The first dimension is base diameter, and the second dimension is top diameter. </param>       
            <param name="height">The cone height</param>
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example> 
            The following example creates a cone feature: 
            <code title="Create a cone feature" lang="VB.NET" source="Cone_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.ConeFromDiametersAngle(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, axis vector, base diameter, top diameter and half-angle</summary>        
            <param name="axisPoint">The cone axis position (center of base arc)</param>
            <param name="axisVector">The cone axis vector</param>
            <param name="baseDiameter">The cone base diameter</param>
            <param name="topDiameter">The cone top diameter</param>
            <param name="halfAngle">The cone half-angle, in degrees</param>         
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example> 
            The following example creates a cone feature: 
            <code title="Create a cone feature" lang="VB.NET" source="Cone_02.vb"> 
            </code> 
            </example>  
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.Cone(Snap.Position,Snap.Vector,Snap.Number,Snap.Number[])">
            <summary>Creates a cone feature, given cone base position, axis vector, base diameter, top diameter and half-angle</summary>        
            <param name="axisPoint">The cone axis position (center of base arc)</param>
            <param name="axisVector">The cone axis vector</param>
            <param name="halfAngle">The cone half-angle, in degrees</param>         
            <param name="diameters">A two dimension array. The first dimension is base diameter, and the second dimension is top diameter. </param>       
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example> 
            The following example creates a cone feature: 
            <code title="Create a cone feature" lang="VB.NET" source="Cone_02.vb"> 
            </code> 
            </example>  
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.ConeFromDiameterHeightAngle(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, axis vector, base diameter, height and half-angle</summary>
            <param name="axisPoint">The cone axis position (center of base arc)</param>
            <param name="axisVector">The cone axis vector</param>
            <param name="baseDiameter">The cone base diameter</param>
            <param name="height">The cone height</param>
            <param name="halfAngle">The cone half-angle, in degrees</param>         
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example> 
            The following example creates a cone feature: 
            <code title="Create a cone feature" lang="VB.NET" source="Cone_03.vb"> 
            </code> 
            </example>                
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.Cone(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, axis vector, base diameter, height and half-angle</summary>
            <param name="axisPoint">The cone axis position (center of base arc)</param>
            <param name="axisVector">The cone axis vector</param>
            <param name="baseDiameter">The cone base diameter</param>
            <param name="height">The cone height</param>
            <param name="halfAngle">The cone half-angle, in degrees</param>         
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example> 
            The following example creates a cone feature: 
            <code title="Create a cone feature" lang="VB.NET" source="Cone_03.vb"> 
            </code> 
            </example>                
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.ConeFromArcs(Snap.NX.ICurve,Snap.NX.ICurve)">
            <summary>Creates a cone feature, given base arc and top arc</summary>                        
            <param name="baseArc">The base arc of the cone</param>
            <param name="topArc">The top arc of the cone</param>     
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example>
            The following example creates a cone feature:
            <code title="Create a cone feature" lang="VB.NET" source="Cone_04.vb"> 
            </code> 
            </example>     
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.Cone(Snap.NX.ICurve,Snap.NX.ICurve)">
            <summary>Creates a cone feature, given base arc and top arc</summary>
            <param name="baseArc">The base arc of the cone</param>
            <param name="topArc">The top arc of the cone</param>     
            <returns>A <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object</returns>
            <remarks>
            <para>
            There are several restrictions on the base diameter, top diameter, height, and half-angle. 
            Please see the documentation for the <see cref="T:Snap.NX.Cone">Snap.NX.Cone</see> object for details.
            </para>
            </remarks>
            <example>
            The following example creates a cone feature:
            <code title="Create a cone feature" lang="VB.NET" source="Cone_04.vb"> 
            </code> 
            </example>     
            <seealso cref="T:Snap.NX.Cone">Snap.NX.Cone</seealso> 
        </member>
        <member name="M:Snap.Create.CoordinateSystem(Snap.Position,Snap.NX.Matrix)">
            <summary>Constructs a coordinate system from an origin and an NX.Matrix</summary>
            <param name="origin">Origin point</param>
            <param name="matrix">An NX.Matrix object</param>
            <returns>A <see cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</see> object</returns>
            <example> 
            This example shows how to create a coordinate system: 
            <code title="Create a coordinate system" lang="VB.NET" source="Csys_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</seealso>
        </member>
        <member name="M:Snap.Create.CoordinateSystem(Snap.Position,Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Constructs a coordinate system from an origin and three axis vectors</summary>
            <param name="origin">Origin position</param>
            <param name="axisX">X axis</param>
            <param name="axisY">Y axis</param>
            <param name="axisZ">Z axis</param>
            <returns>A <see cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</see> object</returns>
            <remarks>Assumes that the three axis vectors are orthonormal, and does not perform any checking.</remarks>
            <example> 
            This example shows how to create a coordinate system: 
            <code title="Create a coordinate system" lang="VB.NET" source="Csys_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</seealso>
        </member>
        <member name="M:Snap.Create.CoordinateSystem(Snap.Position,Snap.Orientation)">
            <summary>Constructs a coordinate system from an origin and an orientation</summary>
            <param name="origin">Origin position</param>
            <param name="matrix">Orientation</param>
            <returns>A <see cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</see> object</returns>
            <example> 
            This example shows how to create a coordinate system: 
            <code title="Create a coordinate system" lang="VB.NET" source="Csys_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</seealso>
        </member>
        <member name="M:Snap.Create.Cylinder(Snap.Position,Snap.Vector,Snap.Number,Snap.Number)">
            <summary>Creates a cylinder feature, given base point, axis vector, height, and diameter</summary>
            <param name="axisPoint">The cylinder axis position (center of base arc)</param>
            <param name="axisVector">The cylinder axis vector (length doesn't matter)</param>
            <param name="height">Number object representing height of cylinder (must be positive)</param>
            <param name="diameter">Number object representing diameter of cylinder</param>
            <returns>A <see cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</see> feature</returns>  
            <remarks>        
            <para>
            For further details, please see the documentation for the <see cref="T:Snap.NX.Cylinder">NX.Cylinder</see> object.
            </para>
            </remarks>
            <example> 
            The following example creates a cylinder feature: 
            <code title="Create a cylinder feature" lang="VB.NET" source="Cylinder_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</seealso> 
        </member>
        <member name="M:Snap.Create.Cylinder(Snap.NX.ICurve,Snap.Number)">
            <summary>Creates a cylinder from base arc and height</summary>
            <param name="arc">Arc to be used as the base circle of cylinder</param>
            <param name="height">Height of cylinder</param>        
            <returns>A <see cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</see> feature</returns>  
            <remarks>        
            <para>
            For further details, please see the documentation for the <see cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</see> object.
            </para>
            </remarks>
            <example> 
            The following example creates a cylinder feature: 
            <code title="Create a cylinder feature" lang="VB.NET" source="Cylinder_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</seealso> 
        </member>
        <member name="M:Snap.Create.Cylinder(Snap.Position,Snap.Position,Snap.Number)">
            <summary>Creates a cylinder from two points and a diameter</summary>
            <param name="basePoint">Position at center of base of cylinder</param>
            <param name="topPoint">Position at center of other end of cylinder</param>
            <param name="diameter">Diameter of cylinder</param>        
            <returns>A <see cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</see> feature</returns>  
            <remarks>        
            <para>
            For further details, please see the documentation for the <see cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</see> object.
            </para>
            </remarks>
            <example> 
            The following example creates a cylinder feature: 
            <code title="Create a cylinder feature" lang="VB.NET" source="Cylinder_02.vb">
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Cylinder">Snap.NX.Cylinder</seealso> 
        </member>
        <member name="M:Snap.Create.DatumAxis(Snap.NX.ICurve,Snap.Number,Snap.NX.DatumAxis.CurveOrientations)">
            <summary>Creates a datum axis at a given arclength along a curve or an edge</summary>
            <param name="icurve">The curve or edge on which the datum axis will be created</param>
            <param name="arcLengthPercent">Percent arclength along the curve, in range 0 to 100</param>
            <param name="curveOrientation">The orientation option</param>
            <returns> A <see cref="T:Snap.NX.DatumAxis">Snap.NX.DatumAxis</see> object</returns>
            <remarks>
            <para>
            The StartPoint/Origin of the Datum Axis will lie on the curve.
            </para>
            </remarks>
            <example> 
            This example shows how to create a datum axis: 
            <code title="Create a datum axis feature" lang="VB.NET" source="DatumAxis_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumAxis">Snap.NX.DatumAxis</seealso>
        </member>
        <member name="M:Snap.Create.DatumAxis(Snap.Position,Snap.Vector)">
            <summary>Creates a datum axis with a given origin and direction</summary>
            <param name="origin">The origin of the datum axis</param>
            <param name="direction">The direction of the datum axis</param>
            <returns> A <see cref="T:Snap.NX.DatumAxis">Snap.NX.DatumAxis</see> object</returns>
            <example> 
            This example shows how to create a datum axis: 
            <code title="Create a datum axis feature" lang="VB.NET" source="DatumAxis_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumAxis">Snap.NX.DatumAxis</seealso>
        </member>
        <member name="M:Snap.Create.DatumAxis(Snap.Position,Snap.Position)">
            <summary>Creates a datum axis from two points</summary>
            <param name="startPoint">The start point of the datum axis</param>
            <param name="endPoint">The end point of the datum axis</param>
            <returns> A <see cref="T:Snap.NX.DatumAxis">Snap.NX.DatumAxis</see> object</returns>     
            <example> 
            This example shows how to create a datum axis: 
            <code title="Create a datum axis feature" lang="VB.NET" source="DatumAxis_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumAxis">Snap.NX.DatumAxis</seealso>
        </member>
        <member name="M:Snap.Create.DatumCsys(Snap.Position,Snap.NX.Matrix)">
            <summary>Creates a Snap.NX.DatumCsys object from an NX.Matrix</summary>
            <param name="origin">The origin of the csys</param>
            <param name="matrix">The orientation of the csys</param>
            <returns>A <see cref="T:Snap.NX.DatumCsys">Snap.NX.DatumCsys</see> object</returns>
            <example> 
            The following example creates a Datum Coordinate System (Datum CSYS): 
            <code title="Create a Snap.NX.DatumCsys object" lang="VB.NET" source="DatumCsys_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumCsys">Snap.NX.DatumCsys</seealso>
        </member>
        <member name="M:Snap.Create.DatumCsys(Snap.Position,Snap.Vector,Snap.Vector)">
            <summary>Creates a Snap.NX.DatumCsys object from three axis vectors</summary>
            <param name="origin">The origin of the csys</param>
            <param name="axisX">The axis in x direction</param>
            <param name="axisY">The axis in y direction</param>
            <returns>A <see cref="T:Snap.NX.DatumCsys">Snap.NX.DatumCsys</see> object</returns>
            <remarks>
            <para>
            The input axisX vector does not have to be a unit vector. 
            The x-axis of the csys will be parallel to this vector.    
            </para>
            <para>
            The input axisY vector does not have be a unit vector, and 
            it does not have to be perpendicular to the axisX vector.
            The y-axis of the csys will lie in the plane of the
            input axisX and axisY vectors.
            </para> 
            </remarks>
            <example> 
            The following example creates a Datum Coordinate System (Datum CSYS): 
            <code title="Create a Snap.NX.DatumCsys object" lang="VB.NET" source="DatumCsys_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumCsys">Snap.NX.DatumCsys</seealso>
        </member>
        <member name="M:Snap.Create.DatumPlane(Snap.NX.ICurve,Snap.Number)">
            <summary>Creates a Snap.NX.DatumPlane feature normal to a curve or an edge at a given arclength</summary>
            <param name="curve">The curve or edge on which the datum plane will be created</param>
            <param name="arcLength">Percent arclength along the curve, in range 0 to 100</param>
            <returns> A <see cref="T:Snap.NX.DatumPlane">Snap.NX.DatumPlane</see> object</returns>
            <example> 
            The following example creates a datum plane normal to a curve: 
            <code title="Create datum plane normal to curve" lang="VB.NET" source="DatumPlane_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumPlane">Snap.NX.DatumPlane</seealso>
        </member>
        <member name="M:Snap.Create.DatumPlane(Snap.Position,Snap.Orientation)">
            <summary>Creates a Snap.NX.DatumPlane feature from a given position and orientation</summary>
            <param name="origin">Origin of the datum plane</param>
            <param name="orientation">Orientation of the datum plane</param>
            <returns> A <see cref="T:Snap.NX.DatumPlane">Snap.NX.DatumPlane</see> object</returns>
            <example> 
            The following example creates a datum plane feature: 
            <code title="Create a datum plane feature" lang="VB.NET" source="DatumPlane_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumPlane">Snap.NX.DatumPlane</seealso>
        </member>
        <member name="M:Snap.Create.DatumPlane(Snap.Position,Snap.Vector)">
            <summary>Creates a Snap.NX.DatumPlane feature from a given position and normal vector</summary>
            <param name="origin">Position of the datum plane origin</param>
            <param name="normal">Normal direction of the datum plane</param>
            <returns> A <see cref="T:Snap.NX.DatumPlane">Snap.NX.DatumPlane</see> object</returns>
            <example> 
            The following example creates a datum plane feature: 
            <code title="Create a datum plane feature" lang="VB.NET" source="DatumPlane_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.DatumPlane">Snap.NX.DatumPlane</seealso>
        </member>
        <member name="M:Snap.Create.EdgeBlend(Snap.Number,Snap.NX.Edge[])">
            <summary>Creates an edge blend</summary>
            <param name="radius">Radius of the blend</param>
            <param name="edges">Array of edges to be blended</param>
            <returns> A <see cref="T:Snap.NX.EdgeBlend">Snap.NX.EdgeBlend</see> feature</returns>
            <example> 
            This example shows how to create edge blends: 
            <code title="Create edge blends" lang="VB.NET" source="EdgeBlend_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.EdgeBlend">Snap.NX.EdgeBlend</seealso> 
            <seealso cref="T:Snap.NX.FaceBlend">Snap.NX.FaceBlend</seealso> 
            <seealso cref="M:Snap.Create.FaceBlend(Snap.NX.Face,Snap.NX.Face,Snap.Number)">Snap.Create.FaceBlend</seealso> 
        </member>
        <member name="M:Snap.Create.Ellipse(Snap.Position,Snap.Vector,Snap.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs an ellipse from center, axes, radius, angles</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="majorRadius">Major radius</param>
            <param name="minorRadius">Minor radius</param>
            <param name="startAngle">Start angle (in degrees)</param>
            <param name="endAngle">End angle (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Ellipse">NX.Ellipse</see> object</returns>
            <example> 
            This example shows how to create an ellipse: 
            <code title="Create an ellipse" lang="VB.NET" source="Ellipse_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</seealso>
        </member>
        <member name="M:Snap.Create.Ellipse(Snap.Position,Snap.Orientation,System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs an ellipse from center, rotation matrix, radius, angles</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="matrix">Orientation</param>
            <param name="majorRadius">Major radius</param>
            <param name="minorRadius">Minor radius</param>
            <param name="startAngle">Start angle (in degrees)</param>
            <param name="endAngle">End angle (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> object</returns>
            <example> 
            This example shows how to create an ellipse: 
            <code title="Create an ellipse" lang="VB.NET" source="Ellipse_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</seealso>
        </member>
        <member name="M:Snap.Create.Ellipse(Snap.Position,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs an NX.Ellipse parallel to the XY-plane</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="rotation">Rotation angle in the XY-plane (in degrees)</param>
            <param name="majorRadius">Major radius</param>
            <param name="minorRadius">Minor radius</param>
            <param name="startAngle">Start angle (in degrees)</param>
            <param name="endAngle">End angle (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> object</returns>
            <remarks>
            <para>
            The ellipse will have its center at the given point, and will be parallel to the XY-plane.
            </para>
            <para>
            If the center point does not lie in the XY-plane, then the ellipse will not, either.
            </para>
            </remarks>      
            <example> 
            This example shows how to create an ellipse: 
            <code title="Create an ellipse" lang="VB.NET" source="Ellipse_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</seealso>
        </member>
        <member name="M:Snap.Create.Ellipse(Snap.Position,System.Double,System.Double,System.Double)">
            <summary>Constructs a complete (360 degrees) NX.Ellipse parallel to the XY-plane</summary>
            <param name="center">Center point (in absolute coordinates)</param>      
            <param name="majorRadius">Major radius</param>
            <param name="minorRadius">Minor radius</param>
            <param name="rotation">Rotation angle in the XY-plane (in degrees)</param>
            <returns>A <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> object</returns>
            <remarks>
            <para>
            The ellipse will have its center at the given point, and will be parallel to the XY-plane.
            </para>
            <para>
            If the center point does not lie in the XY-plane, then the ellipse will not, either.
            </para>
            </remarks>      
            <example> 
            This example shows how to create an ellipse: 
            <code title="Create an ellipse" lang="VB.NET" source="Ellipse_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,System.Boolean)">
            <summary>Creates a boolean expression object</summary>       
            <param name="name">The name of the expression</param>
            <param name="value">The boolean value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionBoolean">Snap.NX.ExpressionBoolean</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_01_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,System.Int32)">
            <summary>Creates an integer expression object</summary>
            <param name="name">The name of the expression</param>
            <param name="value">The integer value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionInteger">Snap.NX.ExpressionInteger</see> object</returns>
            <example>
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_02_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,Snap.NX.Point)">
            <summary>Creates a point expression object</summary>      
            <param name="name">The name of the expression</param>
            <param name="value">The point value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionPoint">Snap.NX.ExpressionPoint</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_04_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,Snap.Position)">
            <summary>Creates a point expression object</summary>      
            <param name="name">The name of the expression</param>
            <param name="value">The point value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionPoint">Snap.NX.ExpressionPoint</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_04_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,System.String)">
            <summary>Creates a string expression object</summary>      
            <param name="name">The name of the expression</param>
            <param name="value">The string value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionString">Snap.NX.ExpressionString</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,Snap.Vector)">
            <summary>Creates a vector expression object</summary>              
            <param name="name">The name of the expression</param>
            <param name="value">The vector value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionVector">Snap.NX.ExpressionVector</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_06_01.vb">
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.Expression(System.String,System.Double)">
            <summary>Creates a constant number expression object</summary>
            <param name="name">The name of the expression</param>
            <param name="value">The number value of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionNumber">Snap.NX.ExpressionNumber</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_03_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="M:Snap.Create.ExpressionNumber(System.String,System.String)">
            <summary>Creates a number expression object</summary>
            <param name="name">The name of the expression</param>
            <param name="rightHandSide">The right-hand side of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionNumber">Snap.NX.ExpressionNumber</see> object</returns>
            <example> 
            The following example creates an expression: 
            <code title="Create an expression" lang="VB.NET" source="Expression_03_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>       
        </member>
        <member name="M:Snap.Create.ExpressionNumber(System.String,Snap.Number,Snap.NX.Unit)">
            <summary>Creates a number expression object</summary>
            <param name="name">The name of the expression</param>
            <param name="rightHandSide">The right-hand side of the expression</param>
            <param name="unit">The units of the expression</param>
            <returns>A <see cref="T:Snap.NX.ExpressionNumber">Snap.NX.ExpressionNumber</see> object</returns>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>       
        </member>
        <member name="M:Snap.Create.ExtractCurve(Snap.NX.Edge[])">
            <summary>Creates curves that replicate given edges</summary>
            <param name="edges">Edge array</param>          
            <returns> An array of <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <example> 
            The following example extracts curves from given edges: 
            <code title="Extract curves from edges" lang="VB.NET" source="ExtractedCurve_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Curve">Snap.NX.Curve</seealso>
            <seealso cref="M:Snap.NX.Edge.ToCurve">Snap.NX.Edge.ToCurve</seealso>
            <seealso cref="M:Snap.NX.Edge.ToSpline">Snap.NX.Edge.ToSpline</seealso>
        </member>
        <member name="M:Snap.Create.ExtractFace(Snap.NX.Face[])">
            <summary>Creates a Snap.NX.ExtractFace feature</summary>
            <param name="faces">The array of faces that will be extracted</param>
            <returns> A <see cref="T:Snap.NX.ExtractFace">Snap.NX.ExtractFace</see> object</returns>
            <example> 
            The following example creates an extract feature: 
            <code title="Create an extract feature" lang="VB.NET" source="Extract_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ExtractFace">Snap.NX.ExtractFace</seealso>
        </member>
        <member name="M:Snap.Create.Extrude(Snap.NX.ICurve[],Snap.Vector,Snap.Number[],Snap.Number)">
            <summary>Creates a Snap.NX.Extrude feature using extrusion extents</summary>
            <param name="curves">The curves (or edges) to be extruded</param>
            <param name="axis">Extrusion direction (vector magnitude not significant)</param>
            <param name="distances">Extents of the extrusion (measured from input curves)</param>
            <param name="draftAngle">Draft angle, in degrees. Optional. Default = <c>Nothing</c>, which gives a value of zero. </param>
            <returns> A <see cref="T:Snap.NX.Extrude">Snap.NX.Extrude</see> feature</returns>
            <remarks>
            <para>
            The type of body created will depend on whether or not the curve array is closed. 
            A closed curve array will produce a solid body, and an open curve array will produce a sheet body.
            To force creation of a sheet body, please use the <see cref="O:Snap.Create.ExtrudeSheet">ExtrudeSheet</see> functions. 
            </para>
            <para>
            If the draft angle is positive, the cross-sectional shape will grow smaller as you travel in the direction of the axis vector.
            </para>
            </remarks>      
            <example> 
            The following example shows how to create extruded features: 
            <code title="Create extruded features" lang="VB.NET" source="Extrude_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Extrude">Snap.NX.Extrude</seealso>      
        </member>
        <member name="M:Snap.Create.Extrude(Snap.NX.ICurve[],Snap.Vector,Snap.Number,Snap.Number)">
            <summary>Creates a Snap.NX.Extrude feature using an extrusion length</summary>
            <param name="curves">The curves (or edges) to be extruded</param>
            <param name="axis">Extrusion direction (vector magnitude not significant)</param>
            <param name="length">Length of the extrusion (measured from input curves)</param>
            <param name="draftAngle">Draft angle, in degrees. Optional. Default = <c>Nothing</c>, which gives a value of zero. </param>
            <returns> A <see cref="T:Snap.NX.Extrude">Snap.NX.Extrude</see> feature</returns>
            <remarks>
            <para>
            The type of body created will depend on whether or not the curve array is closed. 
            A closed curve array will produce a solid body, and an open curve array will produce a sheet body.
            To force creation of a sheet body, please use the <see cref="O:Snap.Create.ExtrudeSheet">ExtrudeSheet</see> functions. 
            </para>
            <para>
            If the draft angle is positive, the cross-sectional shape will grow smaller as you travel in the direction of the axis vector.
            </para>
            </remarks>      
            <example> 
            The following example shows how to create extruded features: 
            <code title="Create extruded features" lang="VB.NET" source="Extrude_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Extrude">Snap.NX.Extrude</seealso>
        </member>
        <member name="M:Snap.Create.ExtrudeSheet(Snap.NX.ICurve[],Snap.Vector,Snap.Number[],Snap.Number)">
            <summary>Creates a sheet body type of Snap.NX.Extrude feature using extrusion extents</summary>
            <param name="curves">The curves (or edges) to be extruded</param>
            <param name="axis">Extrusion direction (vector magnitude not significant)</param>
            <param name="distances">Extents of the extrusion (measured from input curves)</param>
            <param name="draftAngle">Draft angle, in degrees. Optional. Default = <c>Nothing</c>, which gives a value of zero. </param>
            <returns> A <see cref="T:Snap.NX.Extrude">Snap.NX.Extrude</see> feature</returns>
            <remarks>
            <para>
            This function always produces a sheet body.
            To create a solid body, please use the <see cref="O:Snap.Create.Extrude">Extrude</see> functions. 
            </para>
            <para>
            If the draft angle is positive, the cross-sectional shape will grow smaller as you travel in the direction of the axis vector.
            </para>
            </remarks>      
            <example> 
            The following example shows how to create extruded sheet features: 
            <code title="Create extruded sheets" lang="VB.NET" source="ExtrudeSheet_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Extrude">Snap.NX.Extrude</seealso>
        </member>
        <member name="M:Snap.Create.ExtrudeSheet(Snap.NX.ICurve[],Snap.Vector,Snap.Number,Snap.Number)">
            <summary>Creates a sheet body type of Snap.NX.Extrude feature using an extrusion length</summary>
            <param name="curves">The curves (or edges) to be extruded</param>
            <param name="axis">Extrusion direction (vector magnitude not significant)</param>
            <param name="length">Length of the extrusion (measured from input curves)</param>
            <param name="draftAngle">Draft angle, in degrees. Optional. Default = <c>Nothing</c>, which gives a value of zero. </param>
            <returns> A <see cref="T:Snap.NX.Extrude">Snap.NX.Extrude</see> feature</returns>
            <remarks>
            <para>
            This function always produces a sheet body.
            To create a solid body, please use the <see cref="O:Snap.Create.Extrude">Extrude</see> functions. 
            </para>
            <para>
            If the draft angle is positive, the cross-sectional shape will grow smaller as you travel in the direction of the axis vector.
            </para>
            </remarks>      
            <example> 
            The following example shows how to create extruded sheet features: 
            <code title="Create extruded sheets" lang="VB.NET" source="ExtrudeSheet_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Extrude">Snap.NX.Extrude</seealso>
        </member>
        <member name="M:Snap.Create.ExtrudeShell(Snap.NX.ICurve[],Snap.Vector,Snap.Number[],Snap.Number[],Snap.Number)">
            <summary>Creates a thin-walled shell type of Snap.NX.Extrude feature</summary>
            <param name="curves">The curves (or edges) to be extruded</param>
            <param name="axis">Extrusion direction (vector magnitude not significant)</param>
            <param name="distances">Extents of the extrusion (measured from input curves)</param>
            <param name="offsets">Offset distances controlling the wall thickness of the shell</param>
            <param name="draftAngle">Draft angle, in degrees. Optional. Default = <c>Nothing</c>, which gives a value of zero. </param>
            <returns> A <see cref="T:Snap.NX.Extrude">Snap.NX.Extrude</see> feature</returns>
            <remarks>
            <para>
            Conceptually, this function sweeps the input curves to form a sheet body, and then
            thickens this sheet body to form a solid. The offset distances control the thickening process.
            </para>
            <para>
            If the draft angle is positive, the cross-sectional shape will grow smaller as you travel in the direction of the axis vector.
            </para>
            </remarks>      
            <example> 
            The following example shows how to create an extruded shell feature: 
            <code title="Create extruded features" lang="VB.NET" source="ExtrudeShell_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Extrude">Snap.NX.Extrude</seealso>
        </member>
        <member name="M:Snap.Create.FaceBlend(Snap.NX.Face,Snap.NX.Face,Snap.Number)">
            <summary>Creates a Snap.NX.FaceBlend feature</summary>
            <param name="face1">Face one</param>
            <param name="face2">Face two</param>
            <param name="radius">Radius of the blend</param>
            <returns> A <see cref="T:Snap.NX.FaceBlend">Snap.NX.FaceBlend</see> object</returns>
            <example> 
            This example shows how to create a face blend: 
            <code title="Create a face blend" lang="VB.NET" source="FaceBlend_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.FaceBlend">Snap.NX.FaceBlend</seealso>
        </member>
        <member name="M:Snap.Create.Isocline(Snap.NX.Face,Snap.Vector,System.Double)">
            <summary>Creates isocline curves on a given face</summary>
            <param name="face">Face used to get isocline curves</param>
            <param name="direction">Reference direction</param>
            <param name="draftAngle">The draft angle defining the isocline curves (in degrees)</param>
            <returns>An array of <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <example>
            <remarks>
            <para>
            An isocline is a curve along which the face normal makes some constant angle
            with a given plane. In other words, it is a curve along which the "draft angle" is constant.
            </para>
            <para>
            The reference plane from which the draft angle is measured is normal to the
            given reference vector. Some specific examples might help to clarify:
            </para>
            <list type="bullet">
            <item>If draftAngle = 0, the isoclines are silhouette curves</item>
            <item>If draftAngle = 90, then, at points on the isoclines, the face normal is in the same direction as the given reference vector</item>
            <item>If draftAngle = -90, then, at points on the isoclines, the face normal is in the opposite direction to the given reference vector</item>
            </list>
            <para>
            The given draftAngle must be between -90 and 90 degrees (inclusive).
            </para>
            <para>
            In simple cases, the isocline curves returned might be lines or arcs. But, more commonly,
            this function will return spline curves that approximate the true isocline
            curves to within modeling tolerances.
            </para>
            </remarks>
            The following example creates isocline curves: 
            <code title="Create isocline curves" lang="VB.NET" source="Isocline_01.vb"> 
            </code> 
            <para>
            The following picture shows the results of the program:
            </para>
            <img src="../Images/Isocline_01.png"/>
            </example>
            <seealso cref="T:Snap.NX.Curve">Snap.NX.Curve</seealso>
        </member>
        <member name="M:Snap.Create.IsoparametricCurve(Snap.NX.Face,Snap.Create.DirectionUV,System.Double,System.Double)">
            <summary>Creates isoparametric curves in U or V direction on a given face</summary>
            <param name="face">The face used to create isoparametric curves</param>
            <param name="UV">The direction of the curves, u = constant or v = constant</param>
            <param name="value">The constant parameter value at which to create the iso-curves</param>
            <param name="tolerance">Tolerance value, explained below. Optional. Default = 0.0254</param>
            <returns> An array of <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <remarks>
            <para>
            If UV = DirectionUV.U, then the isoparametric curves will have U = constant.
            </para>
            <para>
            If the face is an offset surface or a foreign surface, the iso-curves are approximations,
            and the accuracy of the approximation is controlled by the input tolerance.
            In other cases, the isoparametric curves can be created exactly, so the tolerance is not used.
            </para>
            <para>
            If the face has not been trimmed, then this function will always return a single curve.
            </para>
            <para>
            The different <see cref="T:Snap.NX.Face">Snap.NX.Face</see> types also have
            IsoCurveU and IsoCurveV methods. These may be more convenient because they
            return curves of specific known types.
            </para>
            </remarks>
            <example> 
            The following example shows how to create isoparametric curves: 
            <code title="Create isoparametric curves" lang="VB.NET" source="IsoparametricCurve_01.vb"> 
            </code> 
            </example>
            <exception cref="T:System.InvalidOperationException">Iso-curve of form v=constant requested on a blend face, which is not supported.</exception>
            <seealso cref="T:Snap.NX.Curve">Snap.NX.Curve</seealso>
        </member>
        <member name="T:Snap.Create.DirectionUV">
            <summary>Direction used to create isoparametric curve</summary>
        </member>
        <member name="F:Snap.Create.DirectionUV.U">
            <summary>Direction U</summary>
        </member>
        <member name="F:Snap.Create.DirectionUV.V">
            <summary>Direction V</summary>
        </member>
        <member name="M:Snap.Create.JoinCurves(Snap.NX.ICurve[])">
            <summary>Creates a spline curve by joining together a string of given curves</summary>
            <param name="icurves">The curves to be joined (NX.Curve or NX.Edge objects)</param>
            <returns>An <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            The string of curves or edges that you input may not have large gaps (larger than
            the current DistanceTolerance). If the input curves have sharp corners where they
            join, a spline will be created, but it will also contain sharp corners, so it
            may not be acceptable as input to some NX functions.
            </para>
            <para>
            The order of the given curves in the input array doesn’t matter.
            </para>
            <para>
            To convert a single curve into a spline, you should use the ToSpline method.
            </para>
            </remarks>
            <example> 
            This example shows how to join curves: 
            <code title="Join curves" lang="VB.NET" source="JoinCurve_01a.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>
            <seealso cref="M:Snap.NX.Curve.ToSpline">Snap.NX.Curve.ToSpline</seealso>
        </member>
        <member name="M:Snap.Create.Line(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Construct a line, given x,y,z coordinates of its end-points</summary>
            <param name="x0">X-coordinate of start point</param>
            <param name="y0">Y-coordinate of start point</param>
            <param name="z0">Z-coordinate of start point</param>
            <param name="x1">X-coordinate of end   point</param>
            <param name="y1">Y-coordinate of end   point</param>
            <param name="z1">Z-coordinate of end   point</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <example> 
            This example shows you how to create a line: 
            <code title="Create a line" lang="VB.NET" source="Line_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.Line(System.Double,System.Double,System.Double,System.Double)">
            <summary>Construct a line, given x,y coordinates of its end-points (z assumed zero)</summary>
            <param name="x0">X-coordinate of start point</param>
            <param name="y0">Y-coordinate of start point</param>
            <param name="x1">X-coordinate of end   point</param>
            <param name="y1">Y-coordinate of end   point</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <example> 
            This example shows you how to create a line: 
            <code title="Create a line" lang="VB.NET" source="Line_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.Line(Snap.Position,Snap.Position)">
            <summary>Creates a line between two positions</summary>
            <param name="p0">Position for start of line</param>
            <param name="p1">Position for end of line</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <example> 
            This example shows you how to create a line: 
            <code title="Create a line" lang="VB.NET" source="Line_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.Line(Snap.NX.Point,Snap.NX.Point)">
            <summary>Creates a line between two points (NX.Point objects)</summary>
            <param name="pt0">Point at start of line</param>
            <param name="pt1">Point at end of line</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <example> 
            This example shows you how to create a line: 
            <code title="Create a line" lang="VB.NET" source="Line_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.LineTangent(Snap.Position,Snap.NX.ICurve,Snap.Position)">
            <summary>Creates a line through a given point, tangent to a curve</summary>
            <param name="basePoint">Point through which the line passes</param>
            <param name="icurve">A curve or edge</param>
            <param name="helpPoint">A point near the desired tangency point</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <remarks>
            <para>
            The line will start at the given point, and end at the tangent point on the curve.
            </para>
            <para>
            The help point does not have to lie on the curve, just somewhere near the desired tangency point.
            </para>
            <para>
            If the base point lies on the curve, then an infinite line is generated. In this case, the help point has no influence.
            </para>
            <para>
            If the base point and the curve are not in the same plane, then the base point is projected to the plane of the curve,
            and a tangent line is generated between the projected point and the given curve.
            </para>
            </remarks>
            <example> 
            This example shows how to create a tangent line: 
            <code title="Create a tangent line" lang="VB.NET" source="LineTangent_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.LineTangent(Snap.NX.ICurve,Snap.Position,Snap.NX.ICurve,Snap.Position)">
            <summary>Creates a line tangent to two curves</summary>
            <param name="icurve1">The first curve or edge</param>
            <param name="helpPoint1">A point near the desired tangency point on the first curve</param>
            <param name="icurve2">The second curve or edge</param>
            <param name="helpPoint2">A point near the desired tangency point on the second curve</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <remarks>
            <para>
            The line will start and end at the tangency points on the two curves.
            </para>
            <para>
            The help points do not have to lie on the curves, just somewhere near the desired tangency points.
            </para>
            <para>
            If the two given curves are not coplanar, then the second curve is projected to the plane of the first curve,
            and a tangent line is constructed between the first curve and the projected one.
            </para>
            </remarks>
            <example> 
            This example shows how to create a line tangent to two curves: 
            <code title="Create a tangent line" lang="VB.NET" source="LineTangent_02.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.LineTangent(Snap.NX.ICurve,System.Double,Snap.Position)">
            <summary>Creates a line at a given angle, tangent to a given curve</summary>
            <param name="icurve">A curve or edge lying in a plane parallel to the XY-plane</param>
            <param name="angle">An angle measured relative to the X-axis</param>
            <param name="helpPoint">A point near the desired tangency point</param>
            <returns>A <see cref="T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <remarks>
            <para>
            The line created has "infinite" length; specifically, its length is
            limited by the bounding box of the model.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input curve is a line, is non-planar, or does not lie in a plane parallel to the XY-plane</exception>
            <example> 
            This example shows how to create a tangent line: 
            <code title="Create a tangent line" lang="VB.NET" source="LineTangent_03.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
        </member>
        <member name="M:Snap.Create.Matrix(Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Creates a matrix using three vectors</summary>
            <param name="axisX">X-axis vector</param>
            <param name="axisY">Y-axis vector</param>
            <param name="axisZ">Z-axis vector</param>
            <returns>A <see cref="T:Snap.NX.Matrix">Snap.NX.Matrix</see> object</returns>
            <remarks>
            <para>
            The three vectors must form an orthonormal right-handed system.
            </para>
            <para>
            In other words, they must each have unit length, and they must satisfy
            </para>
            <list type = "bullet">
            <item>Cross(axisX, axisY) = axisZ</item>
            <item>Cross(axisY, axisZ) = axisX</item>
            <item>Cross(axisZ, axisX) = axisY</item>
            </list>
            </remarks>
            <example> 
            This example shows how to create a matrix from three vectors: 
            <code title="Create a matrix" lang="VB.NET" source="Matrix_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Matrix">Snap.NX.Matrix</seealso>
        </member>
        <member name="M:Snap.Create.Matrix(Snap.Orientation)">
            <summary>Creates a matrix from an orientation</summary>
            <param name="rotation">The orientation (rotation)</param>
            <returns>A <see cref="T:Snap.NX.Matrix">Snap.NX.Matrix</see> object</returns>
            <example> 
            This example shows how to create a matrix from an orientation: 
            <code title="Create a matrix" lang="VB.NET" source="Matrix_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Matrix">Snap.NX.Matrix</seealso>
        </member>
        <member name="M:Snap.Create.Note(Snap.Position,Snap.NX.TextStyle,System.String[])">
            <summary>Creates a note, given text, origin, and style</summary>
            <param name="text">The lines of text (one line per array element)</param>
            <param name="origin">Origin (in absolute coordinates)</param>
            <param name="textStyle">A <see cref="T:Snap.NX.TextStyle">Snap.NX.Note.TextStyle</see> object describing formatting, or <c>Nothing</c></param>
            <returns>A <see cref="T:Snap.NX.Note">Snap.NX.Note</see> object</returns>
            <remarks>
            <para>
            The note lies in a plane parallel to the XY-plane of the Absolute Coordinate System.
            </para>
            <para>
            If the input textStyle is <c>Nothing</c>, then formatting information comes from the settings in Annotation Preferences.
            </para>
            </remarks>
            <example> 
            The following example illustrates creation of notes: 
            <code title="Create notes" lang="VB.NET" source="Note_01.vb"> 
            </code> 
            <para>
            The following picture shows the results of the program:
            </para>
            <img src="../Images/Note_01.png"/>
            </example>
            <seealso cref="T:Snap.NX.Note">Snap.NX.Note</seealso>
        </member>
        <member name="M:Snap.Create.Note(Snap.Position,Snap.Orientation,Snap.NX.TextStyle,System.String[])">
            <summary>Creates a note, given text, origin, orientation, and style</summary>
            <param name="text">The lines of text (one line per array element)</param>
            <param name="origin">Origin (in absolute coordinates)</param>
            <param name="matrix">The orientation of the note</param>
            <param name="textStyle">A <see cref="T:Snap.NX.TextStyle">Snap.NX.Note.TextStyle</see> object describing formatting, or <c>Nothing</c></param>
            <returns>A <see cref="T:Snap.NX.Note">Snap.NX.Note</see> object</returns>
            <remarks>
            <para>
            The note lies in a plane parallel to the vectors matrix.AxisX and matrix.AxisY, with matrix.AxisX forming the horizontal.
            </para>
            <para>
            If the input textStyle is <c>Nothing</c>, then formatting information comes from the settings in Annotation Preferences.
            </para>
            </remarks>
            <example> 
            The following example illustrates creation of notes: 
            <code title="Create notes" lang="VB.NET" source="Note_02.vb"> 
            </code> 
            <para>
            The following picture shows the results of the program:
            </para>
            <img src="../Images/Note_02.png"/>
            </example>
            <seealso cref="T:Snap.NX.Note">Snap.NX.Note</seealso>
        </member>
        <member name="M:Snap.Create.OffsetCurve(Snap.Number,System.Boolean,Snap.NX.ICurve[])">
            <summary>Creates a Snap.NX.OffsetCurve feature with a given offset distance</summary>
            <param name="distance">Offset distance</param>
            <param name="reverse">If true, reverse the direction of offset. The default direction is the normal of the array of curves.</param>
            <param name="curves">Array of curves or edges to be offset</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve feature may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            This function doesn't accept a single line object as input. 
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.Create.OffsetCurve(Snap.Number,Snap.Number,System.Boolean,Snap.NX.ICurve[])">
            <summary>Creates a Snap.NX.OffsetCurve feature with a given draft height and angle</summary>
            <param name="height">Draft height</param>
            <param name="angle">Draft angle</param>
            <param name="reverse">If true, reverse direction of offset. The default direction is close to the normal of the array of curves.</param>
            <param name="curves">Array of curves to be offset</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            This function doesn't accept a single line as input. 
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.Create.OffsetCurve(Snap.Number,Snap.Position,Snap.Vector,Snap.NX.ICurve[])">
            <summary>Creates an offset curve feature from given curves, direction, distance</summary>
            <param name="curves">Array of base curves to be offset</param>
            <param name="distance">Offset distance</param>
            <param name="helpPoint">A help point on the first curve</param>
            <param name="helpVector">The offset direction (roughly) at the help point</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            Offsets of lines and arcs will again be lines and arcs, respectively. Offsets of splines
            and ellipses will be splines that approximate the exact offsets to within DistanceTolerance.
            </para>
            <para>
            This function doesn't accept an array consisting of a single line as input.
            </para> 
            </remarks>
            <example> 
            This example shows how to create an offset curve: 
            <code title="Create an offset curve" lang="VB.NET" source="OffsetCurve_02_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.Create.OffsetCurve(Snap.Number,Snap.Number,Snap.Position,Snap.Vector,Snap.NX.ICurve[])">
            <summary>Creates an offset curve feature from given curves, direction, distance</summary>
            <param name="curves">Array of curves to be offset</param>
            <param name="height">Draft height</param>
            <param name="angle">Draft angle</param>
            <param name="helpPoint">A help point on the first curve</param>
            <param name="helpVector">The offset direction (roughly) at the help point</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            Offsets of lines and arcs will again be lines and arcs, respectively. Offsets of splines
            and ellipses will be splines that approximate the exact offsets to within DistanceTolerance.
            </para>
            <para>
            This function doesn't accept an array consisting of a single line as input.
            </para> 
            </remarks>
            <example> 
            This example shows how to create offset curves: 
            <code title="Create offset curves" lang="VB.NET" source="OffsetCurve_02_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.Create.OffsetFace(Snap.Number,System.Boolean,Snap.NX.Face[])">
            <summary>Creates a Snap.NX.OffsetFace feature</summary>
            <param name="faces">Offset faces</param>
            <param name="distance">Offset distance</param>
            <param name="reverse">If true, reverses the direction of offsetting</param>
            <returns> A <see cref="T:Snap.NX.OffsetFace">Snap.NX.OffsetFace</see> feature</returns>
            <example> 
            This example shows how to create an offset face: 
            <code title="Create an offset face" lang="VB.NET" source="OffsetFace_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetFace">Snap.NX.OffsetFace</seealso>
        </member>
        <member name="M:Snap.Create.Part(System.String,Snap.NX.Part.Templates,Snap.NX.Part.Units)">
            <summary>Creates a new part</summary>
            <param name="pathName">The full path of the new part</param>
            <param name="templateType">The type of template to be used</param>
            <param name="unitType">The type of the unit</param>
            <returns>A <see cref="T:Snap.NX.Part">Snap.NX.Part</see> object</returns>
            <example> 
            This example shows how to create and use a new part: 
            <code title="Create part" lang="VB.NET" source="Part_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Part">Snap.NX.Part</seealso>
        </member>
        <member name="M:Snap.Create.Point(System.Double,System.Double,System.Double)">
            <summary>Creates a point from x, y, z coordinates</summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
            <returns>A <see cref="T:Snap.NX.Point">Snap.NX.Point</see> object</returns>
            <example> 
            This example shows how to create a point: 
            <code title="Create a point" lang="VB.NET" source="Point_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Point">Snap.NX.Point</seealso>
        </member>
        <member name="M:Snap.Create.Point(System.Double,System.Double)">
            <summary>Creates a point from xy-coordinates (assumes z=0)</summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <returns>A <see cref="T:Snap.NX.Point">Snap.NX.Point</see> object</returns>
            <example> 
            This example shows how to create a point: 
            <code title="Create a point" lang="VB.NET" source="Point_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Point">Snap.NX.Point</seealso>
        </member>
        <member name="M:Snap.Create.Point(Snap.Position)">
            <summary>Creates a point from a position</summary>
            <param name="p">Position</param>
            <returns>A <see cref="T:Snap.NX.Point">Snap.NX.Point</see> object</returns>
            <example> 
            This example shows how to create a point: 
            <code title="Create a point" lang="VB.NET" source="Point_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Point">Snap.NX.Point</seealso>
        </member>
        <member name="M:Snap.Create.Point(System.Double[])">
            <summary>Creates a point from an array of 3 coordinates</summary>
            <param name="coords">Array of doubles</param>
            <returns>A <see cref="T:Snap.NX.Point">Snap.NX.Point</see> object</returns>
            <example> 
            This example shows how to create a point: 
            <code title="Create a point" lang="VB.NET" source="Point_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Point">Snap.NX.Point</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.Geom.Surface.Plane,Snap.NX.Curve[],Snap.NX.Point[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting onto a plane</summary>
            <param name="curves">Array of curves to be projected</param>
            <param name="points">Array of points to be projected</param>
            <param name="geomPlane">The Geom.Plane to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.Geom.Surface.Plane,Snap.NX.Curve[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting curves onto a plane</summary>
            <param name="curves">Array of curves to be projected</param>>
            <param name="geomPlane">The Geom.Plane to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.Geom.Surface.Plane,Snap.NX.Point[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting points onto a plane</summary>
            <param name="points">Array of points to be projected</param>
            <param name="geomPlane">The Geom.Plane to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.NX.DatumPlane,Snap.NX.Curve[],Snap.NX.Point[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting onto a datum plane</summary>
            <param name="curves">Array of curves to be projected</param>
            <param name="points">Array of points to be projected</param>
            <param name="datumPlane">The datum plane to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_07.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.NX.DatumPlane,Snap.NX.Curve[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting curves onto a datum plane</summary>
            <param name="curves">Array of curves to be projected</param>
            <param name="datumPlane">The datum plane to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_08.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.NX.DatumPlane,Snap.NX.Point[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting points onto a datum plane</summary>
            <param name="points">Array of points to be projected</param>
            <param name="datumPlane">The datum plane to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_09.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.NX.Curve[],Snap.NX.Point[],Snap.NX.Face)">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting onto a face</summary>
            <param name="curves">Array of curves to be projected</param>
            <param name="points">Array of points to be projected</param>
            <param name="face">The face to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a ProjectCurve feature: 
            <code title="Create a ProjectCurve feature" lang="VB.NET" source="ProjectCurve_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.NX.Face,Snap.NX.Curve[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting curves onto a face</summary>
            <param name="curves">Array of curves to be projected</param>
            <param name="face">The face to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a project curve: 
            <code title="Create a project curve" lang="VB.NET" source="ProjectCurve_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.ProjectCurve(Snap.NX.Face,Snap.NX.Point[])">
            <summary>Creates a Snap.NX.ProjectCurve feature by projecting onto a face</summary>
            <param name="points">Array of points to be projected</param>
            <param name="face">The face to project onto</param>
            <returns>A <see cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</see> object</returns>
            <example> 
            This example shows how to create a project curve: 
            <code title="Create a project curve" lang="VB.NET" source="ProjectCurve_06.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ProjectCurve">Snap.NX.ProjectCurve</seealso>
        </member>
        <member name="M:Snap.Create.PolyLine(Snap.Position[])">
            <summary>Creates a polyline (an array of lines connecting given positions)</summary>
            <param name="points">Array of positions forming the vertices of the polyline</param>
            <returns>Array of lines forming the segments of the polyline</returns>
            <remarks>
            <para>
            The i-th line has startPoint = points[i] and endPoint = points[i+1].
            </para>
            </remarks>
            <example> 
            This example shows you how to create a polyline: 
            <code title="Create a polyline" lang="VB.NET" source="Line_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
            <seealso cref="M:Snap.Create.Polygon(Snap.Position[])"/>
            <seealso cref="O:Snap.Create.Rectangle"/>
        </member>
        <member name="M:Snap.Create.Polygon(Snap.Position[])">
            <summary>Creates a polygon (an array of lines forming a closed figure)</summary>
            <param name="points">Array of positions forming the vertices of the polygon</param>
            <returns>Array of lines forming the sides of the polygon</returns>
            <remarks>
            <para>
            The i-th line has startPoint = points[i] and endPoint = points[i+1]. The last line closes
            the figure -- it has startPoint = points[n-1] and endPoint = points[0].
            </para>
            </remarks>
            <example> 
            This example shows you how to create a polygon: 
            <code title="Create a polygon" lang="VB.NET" source="Line_06_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
            <seealso cref="M:Snap.Create.PolyLine(Snap.Position[])"/>
            <seealso cref="O:Snap.Create.Rectangle"/>
        </member>
        <member name="M:Snap.Create.Rectangle(Snap.Position,System.Double,System.Double)">
            <summary>Creates a rectangle (an array of four lines) from given center and side lengths</summary>
            <param name="center">Center location</param>
            <param name="width">Width in the x-direction</param>
            <param name="height">Height in the y-direction</param>
            <returns>Array of four lines</returns>
            <example> 
            This example shows you how to create a rectangle: 
            <code title="Create a rectangle" lang="VB.NET" source="Line_07.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
            <seealso cref="M:Snap.Create.Polygon(Snap.Position[])"/>
            <seealso cref="M:Snap.Create.PolyLine(Snap.Position[])"/>
        </member>
        <member name="M:Snap.Create.Rectangle(Snap.Position,Snap.Position)">
            <summary>Creates a rectangle from two diagonal points</summary>
            <param name="bottomLeft">The point at the (xmin, ymin) corner</param>
            <param name="topRight">The point at the (xmax, ymax) corner</param>
            <returns>Array of four lines</returns>
            <example> 
            This example shows you how to create a rectangle: 
            <code title="Create a rectangle" lang="VB.NET" source="Line_08.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Line">Snap.NX.Line</seealso>
            <seealso cref="M:Snap.Create.Polygon(Snap.Position[])"/>
            <seealso cref="M:Snap.Create.PolyLine(Snap.Position[])"/>
        </member>
        <member name="M:Snap.Create.Revolve(Snap.NX.ICurve[],Snap.Position,Snap.Vector,Snap.Number[])">
            <summary>Creates a Snap.NX.Revolve feature using angular extents</summary>
            <param name="curves">The curves (or edges) to be revolved</param>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
            <param name="angles">Angular extents of the revolved shape, in degrees, measured from the input curves</param>
            <returns> A <see cref="T:Snap.NX.Revolve">Snap.NX.Revolve</see> feature</returns>
            <remarks>
            <para>
            The type of body created will depend on whether or not the curve array is closed. 
            A closed curve array will produce a solid body, and an open curve array will produce a sheet body.
            To force creation of a sheet body, please use the <see cref="O:Snap.Create.RevolveSheet">RevolveSheet</see> functions. 
            </para>
            </remarks>      
            <example> 
            The following example shows how to create revolve features: 
            <code title="Create revolve features" lang="VB.NET" source="Revolve_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Revolve">Snap.NX.Revolve</seealso>
        </member>
        <member name="M:Snap.Create.Revolve(Snap.NX.ICurve[],Snap.Position,Snap.Vector)">
            <summary>Creates a complete (360 degrees) Snap.NX.Revolve feature</summary>
            <param name="curves">The curves (or edges) to be revolved</param>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
            <returns> A <see cref="T:Snap.NX.Revolve">Snap.NX.Revolve</see> feature</returns>
            <remarks>
            <para>
            The type of body created will depend on whether or not the curve array is closed. 
            A closed curve array will produce a solid body, and an open curve array will produce a sheet body.
            To force creation of a sheet body, please use the <see cref="O:Snap.Create.RevolveSheet">RevolveSheet</see> functions. 
            </para>
            </remarks>      
            <example> 
            The following example shows how to create revolve features: 
            <code title="Create revolve features" lang="VB.NET" source="Revolve_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Revolve">Snap.NX.Revolve</seealso>
        </member>
        <member name="M:Snap.Create.RevolveSheet(Snap.NX.ICurve[],Snap.Position,Snap.Vector,Snap.Number[])">
            <summary>Creates a sheet body type of Snap.NX.Revolve feature using angular extents</summary>
            <param name="curves">The curves (or edges) to be revolved</param>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
            <param name="angles">Angular extents of the revolved shape, in degrees, measured from the input curves</param>
            <returns> A <see cref="T:Snap.NX.Revolve">Snap.NX.Revolve</see> feature</returns>
            <remarks>
            <para>
            This function always creates a sheet body. 
            To create a solid body, please use the <see cref="O:Snap.Create.Revolve">Revolve</see> functions. 
            </para>
            </remarks>      
            <example> 
            The following example shows how to create revolve features: 
            <code title="Create revolve features" lang="VB.NET" source="RevolveSheet_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Revolve">Snap.NX.Revolve</seealso>
        </member>
        <member name="M:Snap.Create.RevolveSheet(Snap.NX.ICurve[],Snap.Position,Snap.Vector)">
            <summary>Creates a complete (360 degrees) sheet body type of Snap.NX.Revolve feature</summary>
            <param name="curves">The curves (or edges) to be revolved</param>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
            <returns> A <see cref="T:Snap.NX.Revolve">Snap.NX.Revolve</see> feature</returns>
            <remarks>
            <para>
            The type of body created will depend on whether or not the curve array is closed. 
            A closed curve array will produce a solid body, and an open curve array will produce a sheet body.
            To force creation of a sheet body, please use the <see cref="O:Snap.Create.RevolveSheet">RevolveSheet</see> functions. 
            </para>
            </remarks>      
            <example> 
            The following example shows how to create revolve features: 
            <code title="Create revolve features" lang="VB.NET" source="RevolveSheet_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Revolve">Snap.NX.Revolve</seealso>      
        </member>
        <member name="M:Snap.Create.RevolveShell(Snap.NX.ICurve[],Snap.Position,Snap.Vector,Snap.Number[],Snap.Number[])">
            <summary>Creates a thin-walled shell type of Snap.NX.Revolve feature</summary>
            <param name="curves">The curves (or edges) to be revolved</param>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
            <param name="angles">Angular extents of the revolved shape, in degrees, measured from the input curves</param>
            <param name="offsets">Offset distances controlling the wall thickness of the shell</param>
            <returns> A <see cref="T:Snap.NX.Revolve">Snap.NX.Revolve</see> feature</returns>
            <remarks>
            <para>
            Conceptually, this function revolves the input curves to form a sheet body, and then
            thickens this sheet body to form a solid. The offset distances control the thickening process.
            </para>
            </remarks>      
            <example> 
            The following example shows how to create revolve features: 
            <code title="Create revolve features" lang="VB.NET" source="RevolveShell_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Revolve">Snap.NX.Revolve</seealso>
        </member>
        <member name="M:Snap.Create.Ruled(Snap.NX.Curve,Snap.NX.Curve)">
            <summary>Creates a ruled feature</summary>
            <param name="curve0">First curve (along u=0)</param>
            <param name="curve1">Second curve (along u=1)</param>
            <returns>The ruled feature (an NXOpen.Features.Ruled object)</returns>
            <returns>A <see cref="T:Snap.NX.Ruled">Snap.NX.Ruled</see> object</returns>
            <example> 
            This example shows how to create a ruled feature: 
            <code title="Create a ruled feature" lang="VB.NET" source="Ruled_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Ruled">Snap.NX.Ruled</seealso>
        </member>
        <member name="M:Snap.Create.Ruled(Snap.NX.Curve,Snap.NX.Curve,System.Boolean,System.Boolean)">
            <summary>Creates a ruled feature</summary>
            <param name="curve0">First curve (along u=0)</param>
            <param name="curve1">Second curve (along u=1)</param>
            <param name="reverse0">If true, direction of curve0 is reversed (see remarks below)</param>
            <param name="reverse1">If true, direction of curve1 is reversed</param>
            <returns>A <see cref="T:Snap.NX.Ruled">Snap.NX.Ruled</see> object</returns>
            <remarks>
            <para>
            If <c>reverse0</c> is False, the <c>v=0</c> isoparametric curve of the ruled surface
            passes through the start-point of curve0; if True, it passes through the end-point
            of this curve. Similar remarks apply to <c>reverse1</c> and curve1. So, by adjusting the values
            of <c>reverse0</c> and <c>reverse1</c>, you can control the twisting of the ruled surface.
            </para>
            </remarks>
            <example> 
            This example shows how to create ruled features with control of twisting: 
            <code title="Create a ruled feature" lang="VB.NET" source="Ruled_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Ruled">Snap.NX.Ruled</seealso>
        </member>
        <member name="M:Snap.Create.Sew(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Creates a sew object</summary>
            <param name="targetBody">The target sheet body</param>
            <param name="toolBodies">The array of tool sheet bodies</param>
            <returns> A <see cref="T:Snap.NX.Sew">Snap.NX.Sew</see> object</returns>
            <example> 
            This example shows how to create a sew feature: 
            <code title="Create a sew feature" lang="VB.NET" source="Sew_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Sew">Snap.NX.Sew</seealso>
        </member>
        <member name="M:Snap.Create.Silhouette(Snap.NX.Face,Snap.Vector)">
            <summary>Creates the silhouette curves of a given face</summary>
            <param name="face">Face used to get silhouette curves</param>
            <param name="direction">Viewing direction</param>
            <returns>An array of <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <remarks>
            <para>
            In simple cases, the silhouette curves returned might be lines or arcs. But, more commonly,
            this function will return spline curves that approximate the true silhouette
            curves to within modeling tolerances.
            </para>
            </remarks>
            <example>
            The following example creates silhouette curves: 
            <code title="Create silhouette curves" lang="VB.NET" source="SilhouetteCurves_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Curve">Snap.NX.Curve</seealso>
        </member>
        <member name="M:Snap.Create.Sphere(System.Double,System.Double,System.Double,Snap.Number)">
            <summary>Creates a sphere feature, given center coordinates and diameter</summary>
            <param name="x">x-coordinate of center</param>
            <param name="y">y-coordinate of center</param>
            <param name="z">z-coordinate of center</param>
            <param name="diameter">Diameter</param>
            <returns>A <see cref="T:Snap.NX.Sphere">Snap.NX.Sphere</see> object</returns>
            <example> 
            This example shows how to create a sphere: 
            <code title="Create a sphere" lang="VB.NET" source="Sphere_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Sphere">Snap.NX.Sphere</seealso>
        </member>
        <member name="M:Snap.Create.Sphere(Snap.Position,Snap.Number)">
            <summary>Creates a sphere feature, given center position and diameter</summary>
            <param name="center">Position of center</param>
            <param name="diameter">Diameter</param>
            <returns>A <see cref="T:Snap.NX.Sphere">Snap.NX.Sphere</see> object</returns>
            <example> 
            This example shows how to create a sphere: 
            <code title="Create a sphere" lang="VB.NET" source="Sphere_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Sphere">Snap.NX.Sphere</seealso>
        </member>
        <member name="M:Snap.Create.Sphere(Snap.NX.Point,Snap.Number)">
            <summary>Creates a sphere feature, given center point and diameter</summary>
            <param name="center">Point at center</param>
            <param name="diameter">Diameter</param>
            <returns>A <see cref="T:Snap.NX.Sphere">Snap.NX.Sphere</see> object</returns>
            <example> 
            This example shows how to create a sphere: 
            <code title="Create a sphere" lang="VB.NET" source="Sphere_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Sphere">Snap.NX.Sphere</seealso> 
        </member>
        <member name="M:Snap.Create.Spline(System.Double[],Snap.Position[],System.Double[])">
            <summary>Creates a rational spline curve from knots, poles, and weights</summary>
            <param name="knots">Knots -- an array of n+k knot values : t[0], ... , t[n+k-1]</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <param name="weights">An array of n weight values</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            To create a spline that passes through a given set of points, you can use the
            <see cref= "O:Snap.Create.SplineThroughPoints">SplineThroughPoints</see> functions.
            </para>
            <para>
            To create a Bezier curve (which is a spline having only a single segment), you can use the
            <see cref= "O:Snap.Create.BezierCurve">BezierCurve</see> functions.
            </para>
            <para>
            Another way to create a spline curve is by converting a curve of some other type. You can do 
            this by using the <see cref= "M:Snap.NX.Curve.ToSpline">ToSpline</see> function.
            </para>
            </remarks>
            <example> 
            The following example creates a spline: 
            <code title="Create a spline" lang="VB.NET" source="Spline_01.vb"> 
            </code> 
            </example>
            <seealso cref= "O:Snap.Create.SplineThroughPoints">Snap.Create.SplineThroughPoints</seealso> 
            <seealso cref= "O:Snap.Create.BezierCurve">Snap.Create.BezierCurve</seealso> 
            <seealso cref= "O:Snap.Create.BezierCurveThroughPoints">Snap.Create.BezierCurveThroughPoints</seealso>
            <seealso cref= "M:Snap.NX.Curve.ToSpline">Snap.NX.Curve.ToSpline</seealso>
        </member>
        <member name="M:Snap.Create.Spline(System.Double[],Snap.Position[])">
            <summary>Creates a polynomial spline curve from knots and poles</summary>
            <param name="knots">Knots -- an array of n+k knot values : t[0], ... , t[n+k-1]</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <example> 
            The following example creates a spline: 
            <code title="Create a spline" lang="VB.NET" source="Spline_02.vb"> 
            </code> 
            </example>
            <seealso cref= "O:Snap.Create.SplineThroughPoints">SplineThroughPoints</seealso>
        </member>
        <member name="M:Snap.Create.SplineThroughPoints(Snap.Position[],System.Double[],System.Double[])">
            <summary>Creates a spline curve interpolating (passing through) a given sequence of points</summary>
            <param name="points">The n points to be interpolated</param>
            <param name="nodes">The n parameter values at which to interpolate</param>
            <param name="knots">Knot sequence : n+k values t[0], ... , t[n+k-1]</param>   
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            The spline passes through the i-th data point points[i] at the parameter value t = nodes[i]. In other words, if
            we denote the spline by S, then we have S(nodes[i]) = points[i] for 0 &#8804; i &lt; n. 
            </para>
            <para>
            Choosing "good" values for the nodes and knots is not easy. 
            The <see cref="T:Snap.Math.SplineMath">Snap.Math.SplineMath</see> class
            has some tools to help you. But, unless you are a spline expert, it's probably best to create
            your splines by using other SNAP functions that don't require nodes and knots as input.
            </para>
            </remarks>
            <example> 
            The following example creates a spline: 
            <code title="Create a spline" lang="VB.NET" source="Spline_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Create.SplineThroughPoints(Snap.Position[],System.Int32)">
            <summary>Creates a spline curve interpolating (passing through) a given sequence of points</summary>
            <param name="points">The n points to be interpolated</param>
            <param name="degree">The degree of the desired spline</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            For most purposes, a degree of 3 (a cubic spline) works fine.
            </para>
            </remarks>
            <example> 
            The following example creates a spline: 
            <code title="Create a spline" lang="VB.NET" source="Spline_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Create.SplineThroughPoints(Snap.Position[],Snap.Vector,Snap.Vector)">
            <summary>Creates a cubic (degree = 3) spline curve interpolating given points and end tangents</summary>
            <param name="points">The n points to be interpolated</param>
            <param name="startTangent">The desired tangent vector at the start of the curve (magnitude doesn't matter)</param>
            <param name="endTangent">The desired tangent vector at the end of the curve (magnitude doesn't matter)</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            Only the directions of the input start and end tangents are used by this function, so the magnitudes
            of these vectors have no effect on the shape of the resulting curve.
            </para>
            </remarks>
            <example> 
            The following example creates a spline: 
            <code title="Create a spline" lang="VB.NET" source="Spline_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Create.SplitBody(Snap.NX.Body,Snap.NX.Face[])">
            <summary>Creates a SplitBody feature by splitting with faces</summary>
            <param name="targetBody">The target body to be split</param>
            <param name="toolFaces">The array of faces used to split the target body</param>
            <returns> A <see cref="T:Snap.NX.SplitBody">Snap.NX.SplitBody</see> object</returns>
            <example> 
            This example shows how to create a SplitBody feature: 
            <code title="Create a SplitBody feature" lang="VB.NET" source="Split_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.SplitBody">Snap.NX.SplitBody</seealso>
        </member>
        <member name="M:Snap.Create.SplitBody(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Creates a SplitBody feature by splitting with sheet bodies</summary>
            <param name="targetBody">The target body to be split</param>
            <param name="toolBodies">The array of sheet bodies used to split the target body</param>
            <returns> A <see cref="T:Snap.NX.SplitBody">Snap.NX.SplitBody</see> object</returns>
            <example> 
            This example shows how to create a SplitBody feature: 
            <code title="Create a SplitBody feature" lang="VB.NET" source="Split_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.SplitBody">Snap.NX.SplitBody</seealso>
        </member>
        <member name="M:Snap.Create.SplitBody(Snap.NX.Body,Snap.NX.DatumPlane[])">
            <summary>Creates a SplitBody feature by splitting with datum planes</summary>
            <param name="targetBody">The target body to be split</param>
            <param name="toolDatumPlanes">The array of datum planes used to split the target body</param>
            <returns> A <see cref="T:Snap.NX.SplitBody">Snap.NX.SplitBody</see> object</returns>
            <example> 
            This example shows how to create a SplitBody feature: 
            <code title="Create a SplitBody feature" lang="VB.NET" source="Split_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.SplitBody">Snap.NX.SplitBody</seealso>
        </member>
        <member name="M:Snap.Create.Thicken(Snap.Number,Snap.Number,Snap.NX.Body[])">
            <summary>Creates a thicken object</summary>
            <param name="targetBodies">The sheet bodies to be thickened</param>
            <param name="offset1">The first offset distance</param>
            <param name="offset2">The second offset distance</param>
            <returns> A <see cref="T:Snap.NX.Thicken">Snap.NX.Thicken</see> feature</returns>
            <remarks>
            <para>
            Thickening is controlled by two offset distances, which can be either positive or negative.
            Positive values indicate an offset to one side of the original sheet body, and negative
            values indicate the other side. The thickened body lies between these two offsets.
            </para>
            </remarks>
            <example> 
            This example shows how to create a thicken feature: 
            <code title="Create a thicken feature" lang="VB.NET" source="Thicken_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Thicken">Snap.NX.Thicken</seealso>
        </member>
        <member name="M:Snap.Create.ThroughCurveMesh(Snap.NX.ICurve[],Snap.NX.ICurve[])">
            <summary>Creates a Snap.NX.ThroughCurveMesh feature</summary>
            <param name="primaryCurves">Array of primary curves (curves or edges)</param>
            <param name="crossCurves">Array of cross curves (curves or edges)</param>
            <returns> A <see cref="T:Snap.NX.ThroughCurveMesh">Snap.NX.ThroughCurveMesh</see> object</returns>
            <example> 
            This example shows how to create a ThroughCurveMesh feature: 
            <code title="Create a ThroughCurveMesh feature" lang="VB.NET" source="ThroughCurveMesh_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ThroughCurveMesh">Snap.NX.ThroughCurveMesh</seealso>
        </member>
        <member name="M:Snap.Create.ThroughCurves(Snap.NX.ICurve[])">
            <summary>Creates a Snap.NX.ThroughCurves feature</summary>
            <param name="curves">The curves through which the feature should pass (curves or edges)</param>
            <returns> A <see cref="T:Snap.NX.ThroughCurves">Snap.NX.ThroughCurves</see> object</returns>
            <example> 
            This example shows how to create a ThroughCurves feature: 
            <code title="Create a ThroughCurves feature" lang="VB.NET" source="ThroughCurves_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ThroughCurves">Snap.NX.ThroughCurves</seealso>
        </member>
        <member name="M:Snap.Create.ThroughCurves(Snap.NX.ICurve[],System.Boolean[])">
            <summary>Creates a Snap.NX.ThroughCurves feature</summary>
            <param name="curves">The curves through which the feature should pass (curves or edges)</param>
            <param name="reverse">The array of booleans which decide whether direction of respective curve in the curves array has to reversed.
            If true, direction of curve is reversed</param>
            <returns> A <see cref="T:Snap.NX.ThroughCurves">Snap.NX.ThroughCurves</see> object</returns>
            <remarks>
            <para>
            If <c>reverse</c> is False, the <c>v=0</c> isoparametric curve of the ruled surface
            passes through the start-point of curve0; if True, it passes through the end-point
            of this curve. So, by adjusting the values
            of <c>reverse</c> , you can control the twisting of the ThroughCurves surface.
            </para>
            </remarks>
            <example> 
            This example shows how to create a ThroughCurves feature: 
            <code title="Create a ThroughCurves feature" lang="VB.NET" source="ThroughCurves_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.ThroughCurves">Snap.NX.ThroughCurves</seealso>
        </member>
        <member name="M:Snap.Create.Torus(Snap.Position,Snap.Orientation,System.Double,System.Double,Snap.Geom.Box2d)">
            <summary>Creates a toroidal surface, given center, matrix, major radius, minor radius, uv box</summary>
            <param name="center">Center point</param>
            <param name="matrix">Orientation of the torus. AxisZ is the axis of revolution</param>
            <param name="majorRadius">Major radius (radius of "spine" circle)</param>
            <param name="minorRadius">Minor radius (radius of "section" circle)</param>
            <param name="boxUV">The UV parameter box of the surface (MinU, MinV, MaxU, MaxV)</param>
            <returns>A <see cref="T:Snap.NX.Torus">Snap.NX.Torus</see> NX.Torus object</returns>
            <example> 
            The following example creates several toroidal surfaces: 
            <code title="Create toroidal surfaces" lang="VB.NET" source="Torus_01.vb"> 
            </code>
            The following picture illustrates a donut-shaped sheet body:
            <para>
            <img src="../Images/Torus-sheet-donut_01.png"/>
            </para>
            The following picture illustrates an apple-shaped sheet body:
            <para>
            <img src="../Images/Torus-sheet-apple_01.png"/>
            </para>
            The following picture illustrates a barrel-shaped sheet body:
            <para>
            <img src="../Images/Torus-sheet-barrel_01.png"/>
            </para>
            </example>
            <seealso cref="T:Snap.NX.Torus">Snap.NX.Torus</seealso>
        </member>
        <member name="M:Snap.Create.Torus(Snap.Position,Snap.Vector,System.Double,System.Double)">
            <summary>Creates an NX.Torus solid body (complete 360 degrees), given center, major radius and minor radius</summary>
            <param name="axisPoint">Axis point</param>
            <param name="axisVector">Vector along axis of revolution (length doesn't matter)</param>
            <param name="majorRadius">Major radius (radius of "spine" circle)</param>
            <param name="minorRadius">Minor radius (radius of "section" circle)</param>
            <returns>A <see cref="T:Snap.NX.Torus">Snap.NX.Torus</see> NX.Torus object</returns>
            <example> 
            The following example creates a torus solid body: 
            <code title="Create a torus solid body" lang="VB.NET" source="Torus_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Torus">Snap.NX.Torus</seealso>
        </member>
        <member name="M:Snap.Create.TrimBody(Snap.NX.Body,Snap.NX.Face,System.Boolean)">
            <summary>Creates a TrimBody feature by trimming with a face</summary>
            <param name="targetBody">The target body to be trimmed</param>
            <param name="toolFace">The face used to trim the target body</param>
            <param name="direction">Trim direction. The default direction is the normal of the face.</param>
            <returns> A <see cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</see> object</returns>
            <example> 
            This example shows how to create a TrimBody feature: 
            <code title="Create a TrimBody feature" lang="VB.NET" source="Trim_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</seealso>
        </member>
        <member name="M:Snap.Create.TrimBody(Snap.NX.Body,Snap.NX.Body,System.Boolean)">
            <summary>Creates a TrimBody feature by trimming with a sheet body</summary>
            <param name="targetBody">The target body to be trimmed</param>
            <param name="toolBody">The sheet body used to trim the target body</param>
            <param name="direction">Trim direction. The default direction is the normal of the sheet body.</param>
            <returns> A <see cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</see> feature</returns>
            <example> 
            This example shows how to create a trim feature: 
            <code title="Create a trim feature" lang="VB.NET" source="Trim_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</seealso>
        </member>
        <member name="M:Snap.Create.TrimBody(Snap.NX.Body,Snap.NX.DatumPlane,System.Boolean)">
            <summary>Creates a TrimBody feature by trimming with a datum plane</summary>
            <param name="targetBody">The target body to be trimmed</param>
            <param name="toolDatumPlane">The datum plane used to trim the target body</param>
            <param name="direction">Trim direction. The default direction is the normal of the datum plane.</param>
            <returns> A <see cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</see> object</returns>
            <example> 
            This example shows how to create a TrimBody feature: 
            <code title="Create a TrimBody feature" lang="VB.NET" source="Trim_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</seealso>
        </member>
        <member name="M:Snap.Create.Tube(Snap.NX.Curve,System.Boolean,Snap.Number,Snap.Number)">
            <summary>Creates a Snap.NX.Tube feature, given spine and inner/outer diameters</summary>
            <param name="spine">The centerline (spine) of the tube</param>
            <param name="createBsurface">Controls the type of geometry created (see remarks below)</param>
            <param name="outerDiameter">Outer diameter</param>
            <param name="innerDiameter">Inner diameter. Optional. Default = <c>Nothing</c>, which gives a value of zero</param>
            <returns>A <see cref="T:Snap.NX.Tube">Snap.NX.Tube</see> object</returns>
            <remarks>
            <para>
            The createBsurface parameter controls the type of geometry created for the inner and outer surfaces of the tube:
            <list type = "bullet">
            <item>If true, a single b-surface is created for each</item>
            <item>If false, a collection of toroidal surfaces is created</item>
            </list>
            </para>
            </remarks>
            <example> 
            This example shows how to create a tube feature: 
            <code title="Create a tube feature" lang="VB.NET" source="Tube_02.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Tube">Snap.NX.Tube</seealso>
        </member>
        <member name="T:Snap.Compute">
            <summary>Computes arclengths, mass properties, intersections, and distances between objects</summary>
        </member>
        <member name="M:Snap.Compute.ArcLength(Snap.NX.ICurve[])">
            <summary>Computes the total arclength of a collection of curves or edges</summary>
            <param name="icurves">ICurve array (curves or edges)</param>
            <returns>The total arclength of the curves</returns>
            <remarks>
            <para>
            If you want calculate the arclength of a single curve, it may be more convenient to use the
            <see cref = "P:Snap.NX.Curve.ArcLength">Snap.NX.Curve.Arclength</see>  property, instead.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate the total arclength of a collection of curves: 
            <code title="Calculate lengths of curves" lang="VB.NET" source="ArcLength_01.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.ICurve.ArcLength">Snap.NX.ICurve.ArcLength</seealso>
        </member>
        <member name="M:Snap.Compute.DeviationInfo(Snap.NX.ICurve,Snap.NX.ICurve,System.Int32)">
            <summary>Computes the deviation between two curves</summary>
            <param name="icurve1">First curve to be used in the computation</param>
            <param name="icurve2">Second curve</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking.</param>
            <returns>The deviation information</returns>
            <remarks>
            <para>
            For a description of how Deviation Checking works, please see the documentation for the 
            interactive NX function. In particular, please note that specifying the two curves in a 
            different order may give different results. 
            </para>
            </remarks>            
            <example> 
            The following example demonstrates how to calculate the deviation between two curves: 
            <code title="Deviation between two curves" lang="VB.NET" source="Deviation_04.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.DeviationInfo(Snap.NX.Curve,Snap.NX.Face,System.Int32)">
            <summary>Computes the deviation between a curve and a face</summary>
            <param name="curve">The curve to be used in the computation</param>
            <param name="face">The face to be used in the computation</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking.</param>
            <returns>The deviation information</returns>
            <example> 
            The following example demonstrates how to calculate the deviation between a curve and a face: 
            <code title="Deviation between curve and face" lang="VB.NET" source="Deviation_05.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.DeviationInfo(Snap.NX.Edge,Snap.NX.Face,Snap.NX.Face,System.Int32)">
            <summary>Computes the deviation between an edge and a face</summary>
            <param name="edge">The edge to be used in the computation</param>
            <param name="faceNearEdge">A face to which the edge belongs</param>
            <param name="face">The face to be used in the computation</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking.</param>      
            <returns>The deviation information</returns>
            <remarks>
            <para>
            The function computes the deviation between two faces (distance and angle) along 
            an edge that belongs to one of the faces. In some cases, the edge will belong
            to the second face, too, but this is not required.
            </para>
            </remarks>
            <example> 
            The following example demonstrates how to compute the deviation between an edge and a face: 
            <code title="Deviation between an edge and a face" lang="VB.NET" source="Deviation_06.vb"> 
            </code> 
            <para>
            The following picture shows the result of the example:
            </para>
            <img src="../Images/Deviation_06.png"/>
            </example>      
        </member>
        <member name="M:Snap.Compute.DeviationInfo(Snap.NX.Face,Snap.NX.Face,System.Int32,System.Int32)">
            <summary>Computes the deviation between two faces</summary>
            <param name="face1">First face to be used in the computation</param>
            <param name="face2">Second face</param>
            <param name="numCheckPointsU">The number of check points in the u-direction (of the first face)</param>
            <param name="numCheckPointsV">The number of check points in the v-direction (of the first face)</param>
            <returns>The deviation information</returns>
            <remarks>
            <para>
            For a description of how Deviation Checking works, please see the documentation for the 
            interactive NX function. In particular, please note that specifying the two faces in a 
            different order may give different results. 
            </para>
            </remarks>            
            <example> 
            The following example demonstrates how to calculate the deviation between two faces: 
            <code title="Deviation between two faces" lang="VB.NET" source="Deviation_07.vb"> 
            </code> 
            <para>
            The following picture shows the result of the example:
            </para>
            <img src="../Images/Deviation_07.png"/>
            </example>      
        </member>
        <member name="M:Snap.Compute.DeviationInfo(Snap.NX.Edge,Snap.NX.Face,Snap.NX.Edge,Snap.NX.Face,System.Int32)">
            <summary>Computes the deviation between two edges (and their owning faces)</summary>
            <param name="edge1">First edge to be used in the computation</param>
            <param name="face1">A face to which the first edge belongs</param>
            <param name="edge2">Second edge to be used in the computation</param>
            <param name="face2">A face to which the second edge belongs</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking.</param>
            <returns>The deviation information</returns>
            <remarks>
            <para>
            For a description of how Deviation Checking works, please see the documentation for the 
            interactive NX function. In particular, please note that specifying the two edges in a 
            different order may give different results. 
            </para>
            </remarks>            
            <example> 
            The following example demonstrates how to calculate the deviation between two edges (and their owning faces): 
            <code title="Deviation between two edges" lang="VB.NET" source="Deviation_08.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.Deviation(Snap.NX.ICurve,Snap.NX.ICurve,System.Int32)">
            <summary>Computes the maximum distance deviation between two curves or edges</summary>
            <param name="icurve1">ICurve one</param>
            <param name="icurve2">ICurve two</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking</param>
            <returns>The maximum distance error between two curves</returns>
            <example> 
            The following example demonstrates how to calculate the deviation between two curves or edges: 
            <code title="Deviation between two curves" lang="VB.NET" source="Deviation_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.Deviation(Snap.NX.Curve,Snap.NX.Face,System.Int32)">
            <summary>Computes the maximum distance deviation between a curve and a face</summary>
            <param name="curve">A curve object</param>
            <param name="face">A face object</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking.</param>
            <returns>The maximum distance error between curve and face</returns>
            <example> 
            The following example demonstrates how to calculate the deviation between a curve and a face: 
            <code title="Deviation between a curve and a face" lang="VB.NET" source="Deviation_02.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.Deviation(Snap.NX.Face,Snap.NX.Face,System.Int32,System.Int32)">
            <summary>Computes the maximum distance deviation between two faces</summary>
            <param name="face1">First face to be used in the computation</param>
            <param name="face2">Second face</param>
            <param name="numCheckPointsU">The number of check points in the u-direction (of the first face)</param>
            <param name="numCheckPointsV">The number of check points in the v-direction (of the first face)</param>
            <remarks>
            <para>
            For a description of how Deviation Checking works, please see the documentation for the 
            interactive NX function. In particular, please note that specifying the two faces in a 
            different order may give different results. 
            </para>
            </remarks>
            <returns>The maximum distance error between two faces</returns>
            <example> 
            The following example demonstrates how to calculate the deviation between two faces: 
            <code title="Deviation between two faces" lang="VB.NET" source="Deviation_03.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.Deviation(Snap.NX.Edge,Snap.NX.Face,Snap.NX.Face,System.Int32)">
            <summary>Computes the deviation between an edge and a face</summary>
            <param name="edge">The edge to be used in the computation</param>
            <param name="faceNearEdge">A face to which the edge belongs</param>
            <param name="face">The face to be used in the computation</param>
            <param name="numCheckPoints">The number of check points to be used in the deviation checking.</param>      
            <returns>The maximum distance error between the edge and the face</returns>
            <example> 
            The following example demonstrates how to compute the deviation between an edge and a face: 
            <code title="Deviation between an edge and a face" lang="VB.NET" source="Deviation_09.vb"> 
            </code>
            </example>      
        </member>
        <member name="T:Snap.Compute.DeviationResult">
            <summary>The result of computing the deviation between two objects</summary>
        </member>
        <member name="P:Snap.Compute.DeviationResult.MaximumDistanceError">
            <summary>The maximum distance error between the two objects</summary>
        </member>
        <member name="P:Snap.Compute.DeviationResult.AverageDistanceError">
            <summary>The average distance error between the two objects</summary>
        </member>
        <member name="P:Snap.Compute.DeviationResult.MaximumAngleError">
            <summary>The maximum angle error between the two objects</summary>
        </member>
        <member name="P:Snap.Compute.DeviationResult.AverageAngleError">
            <summary>The average angle error between the two objects</summary>
        </member>
        <member name="P:Snap.Compute.DeviationResult.DistanceErrors">
            <summary>The distance errors at checking points</summary>
        </member>
        <member name="P:Snap.Compute.DeviationResult.AngleErrors">
            <summary>The angle errors at checking points</summary>
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.NX.NXObject,Snap.NX.NXObject)">
            <summary>Computes the closest points on two given objects (curves, edges, faces, or bodies)</summary>
            <param name="nxObject1">The first object (curve, edge, face, or body)</param>
            <param name="nxObject2">The second object (curve, edge, face, or body)</param>
            <returns>A Compute.DistanceResult object that contains the distance and the closest points</returns>
            <remarks>
            <para>
            The closest points on the two objects are returned in DistanceResult.Point1 and DistanceResult.Point2.
            If you only want to know the distance between the objects (and not the closest points),
            then the  <see cref= "M:Snap.Compute.Distance(Snap.NX.NXObject,Snap.NX.NXObject)">Snap.Compute.Distance</see>
            function may be more convenient.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">One of the input objects is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the closest points on two given objects: 
            <code title="Closest points on two objects" lang="VB.NET" source="Distance_01.vb"> 
            </code>
            </example>
            <seealso cref= "M:Snap.Compute.Distance(Snap.NX.NXObject,Snap.NX.NXObject)">Snap.Compute.Distance</seealso> 
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.Position,Snap.NX.NXObject)">
            <summary>Computes the point of an object (curve, edge, face, or body) closest to a given position</summary>
            <param name="point">Reference point</param>
            <param name="nxObject">The object (curve, edge, face, or body)</param>
            <returns>A Compute.DistanceResult object which contains the distance and the closest points</returns>
            <remarks>
            <para>
            The closest point of the object is returned in DistanceResult.Point2.
            </para>
            <para>
            If you only want to know the distance between the objects (and not the closest points),
            then the  <see cref= "M:Snap.Compute.Distance(Snap.Position,Snap.NX.NXObject)">Snap.Compute.Distance</see>
            function may be more convenient.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input object is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the point of an object that is closest to a given position: 
            <code title="Closest point on an object" lang="VB.NET" source="Distance_05.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Distance(Snap.Position,Snap.NX.NXObject)">Snap.Compute.Distance</seealso> 
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.Geom.Curve.Ray,Snap.NX.NXObject)">
            <summary>Computes the closest points on an object (curve, edge, face, or body) and a ray</summary>
            <param name="ray">The ray</param>
            <param name="nxObject">The object (curve, edge, face, or body)</param>
            <returns>A Compute.DistanceResult object that contains the distance and the closest points</returns>
            <remarks>
            <para>
            The closest point of the ray is returned in DistanceResult.Point1, and 
            the closest point of the object is returned in DistanceResult.Point2.
            </para>
            <para>
            If you only want to know the distance between the objects (and not the closest points),
            then the  <see cref= "M:Snap.Compute.Distance(Snap.Geom.Curve.Ray,Snap.NX.NXObject)">Snap.Compute.Distance</see>
            function may be more convenient.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">The input object is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the closest points on a ray and an object: 
            <code title="Closest points of ray and object" lang="VB.NET" source="Distance_04.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Distance(Snap.Geom.Curve.Ray,Snap.NX.NXObject)">Snap.Compute.Distance</seealso> 
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">
            <summary>Computes the closest points on an object (curve, edge, face, or body) and a plane</summary>
            <param name="plane">The plane</param>
            <param name="nxObject">The object (curve, edge, face, or body)</param>
            <returns>A Compute.DistanceResult object that contains the distance and the closest points</returns>
            <remarks>
            <para>
            The closest point of the plane is returned in DistanceResult.Point1, and 
            the closest point of the object is returned in DistanceResult.Point2.
            </para>
            <para>
            If you only want to know the distance between the objects (and not the closest points),
            then the  <see cref= "M:Snap.Compute.Distance(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">Snap.Compute.Distance</see>
            function may be more convenient.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">The input object is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the closest points on a plane and an object: 
            <code title="Closest points of plane and object" lang="VB.NET" source="Distance_03.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Distance(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">Snap.Compute.Distance</seealso> 
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.Position,Snap.Geom.Curve.Ray)">
            <summary>Computes the point on a ray closest to a given point</summary>
            <param name="point">Reference point</param>
            <param name="ray">Ray</param>
            <returns>A Compute.DistanceResult object that contains the distance and the closest points</returns>
            <remarks>
            <para>
            The closest point on the ray is returned in DistanceResult.Point2.
            </para>
            <para>
            If you only want to know the distance between the objects (and not the closest points),
            then the  <see cref= "M:Snap.Compute.Distance(Snap.Position,Snap.Geom.Curve.Ray)">Snap.Compute.Distance</see>
            function may be more convenient.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate the point on a ray closest to a given point: 
            <code title="Closest point on ray" lang="VB.NET" source="Distance_11.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Distance(Snap.Position,Snap.Geom.Curve.Ray)">Snap.Compute.Distance</seealso> 
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.Position,Snap.Geom.Surface.Plane)">
            <summary>Computes the point on a plane closest to a given point</summary>
            <param name="point">Reference point</param>
            <param name="plane">Plane</param>
            <returns>A Compute.DistanceResult object that contains the distance and the closest points</returns>
            <remarks>
            <para>
            The closest point on the plane is returned in DistanceResult.Point2.
            </para>
            <para>
            If you only want to know the distance between the objects (and not the closest points),
            then the  <see cref= "M:Snap.Compute.Distance(Snap.Position,Snap.Geom.Surface.Plane)">Snap.Compute.Distance</see>
            function may be more convenient.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate the point on a plane closest to a given point: 
            <code title="Closest point on ray" lang="VB.NET" source="Distance_08.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Distance(Snap.Position,Snap.Geom.Surface.Plane)">Snap.Compute.Distance</seealso>     
        </member>
        <member name="M:Snap.Compute.ClosestPoints(Snap.Geom.Curve.Ray,Snap.Geom.Curve.Ray)">
            <summary>Computes the closest points on two rays</summary>
            <param name="ray1">The first ray</param>
            <param name="ray2">The second ray</param>
            <returns>A Compute.DistanceResult object that contains the distance and the closest points</returns>
            <remarks>
            <para>
            If the two rays are parallel, then all pairs of points on the two rays are equally close.
            In this case, the two points that are returned are the ones that are closest to the origin.
            </para>
            </remarks>
            <example>
            The following example demonstrates how to calculate the closest points on two rays: 
            <code title="Closest points on two rays" lang="VB.NET" source="Distance_14.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.Distance(Snap.NX.NXObject,Snap.NX.NXObject)">
            <summary>Computes the distance between two given objects (curves, edges, faces, or bodies)</summary>
            <param name="nxObject1">The first object (curve, edge, face, or body)</param>
            <param name="nxObject2">The second object (curve, edge, face, or body)</param>
            <returns>The distance between two objects</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.NX.NXObject,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</see>
            function, instead.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">One of the input objects is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the distance between two given objects: 
            <code title="Distance between two objects" lang="VB.NET" source="Distance_02.vb"> 
            </code>
            </example>
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.NX.NXObject,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</seealso> 
        </member>
        <member name="M:Snap.Compute.Distance(Snap.Position,Snap.NX.NXObject)">
            <summary>Computes the distance between an object (curve, edge, face, or body) and a position</summary>
            <param name="point">Reference point</param>
            <param name="nxObject">The object (curve, edge, face, or body)</param>
            <returns>The distance between the position and the object</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.Position,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</see>
            function, instead.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input object is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the distance between a point (position) and an object: 
            <code title="Distance between point and object" lang="VB.NET" source="Distance_07.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.Position,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</seealso> 
        </member>
        <member name="M:Snap.Compute.Distance(Snap.Geom.Curve.Ray,Snap.NX.NXObject)">
            <summary>Computes the distance between an object (curve, edge, face, or body) and a ray</summary>
            <param name="ray">The ray</param>
            <param name="nxObject">The object (curve, edge, face, or body)</param>
            <returns>The distance between the ray and the object</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.Geom.Curve.Ray,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</see>
            function, instead.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">The input object is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the distance between a ray and an object: 
            <code title="Distance between ray and object" lang="VB.NET" source="Distance_13.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.Geom.Curve.Ray,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</seealso> 
        </member>
        <member name="M:Snap.Compute.Distance(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">
            <summary>Computes the distance between an object (curve, edge, face, or body) and a plane</summary>
            <param name="plane">The plane</param>
            <param name="nxObject">The object (curve, edge, face, or body)</param>
            <returns>The distance between the plane and the object</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</see>
            function, instead.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">The input object is not a curve, edge, face, or body</exception>
            <example> 
            The following example shows how to calculate the distance between a plane and an object: 
            <code title="Distance between plane and object" lang="VB.NET" source="Distance_12.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">Snap.Compute.ClosestPoints</seealso> 
        </member>
        <member name="M:Snap.Compute.Distance(Snap.Position,Snap.Geom.Curve.Ray)">
            <summary>Computes the distance between a point (position) and a ray</summary>
            <param name="point">Reference point (position)</param>
            <param name="ray">Ray</param>
            <returns>The distance between the point and the ray</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.Position,Snap.Geom.Curve.Ray)">Snap.Compute.ClosestPoints</see>
            function, instead.
            </para>
            </remarks>
            <example> 
            The following example shows you how to use point-to-ray distance calculations
            to estimate how far a theoretical curve deviates from its chord: 
            <code title="Distance between curve and chord" lang="VB.NET" source="Distance_10.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.Position,Snap.Geom.Curve.Ray)">Snap.Compute.ClosestPoints</seealso> 
        </member>
        <member name="M:Snap.Compute.Distance(Snap.Position,Snap.Geom.Surface.Plane)">
            <summary>Computes the distance between a point (position) and a plane</summary>
            <param name="point">Reference point (position)</param>
            <param name="plane">Plane</param>
            <returns>The distance between the point and the plane</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.Position,Snap.Geom.Surface.Plane)">Snap.Compute.ClosestPoints</see>
            function, instead.
            </para>
            </remarks>
            <example> 
            The following example shows you how to use point-to-plane distance calculations
            to estimate how far a surface deviates from a tangent plane:
            <code title="Distance between point and plane" lang="VB.NET" source="Distance_09.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.Position,Snap.Geom.Surface.Plane)">Snap.Compute.ClosestPoints</seealso>     
        </member>
        <member name="M:Snap.Compute.Distance(Snap.Geom.Curve.Ray,Snap.Geom.Curve.Ray)">
            <summary>Computes the distance between two rays</summary>
            <param name="ray1">The first ray</param>
            <param name="ray2">The second ray</param>
            <returns>The distance between the two rays</returns>
            <remarks>
            <para>
            If you want to know the points where the minimum distance is attained, in addition to the distance, then you should use 
            the  <see cref= "M:Snap.Compute.ClosestPoints(Snap.Geom.Curve.Ray,Snap.Geom.Curve.Ray)">Snap.Compute.Distance</see>
            function, instead.
            </para>
            </remarks>
            <example>
            The following example shows how calculating the distance between two rays 
            can give you the clearance distance between two pipes: 
            <code title="Distance between two rays (or pipes)" lang="VB.NET" source="Distance_06.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.ClosestPoints(Snap.Geom.Curve.Ray,Snap.Geom.Curve.Ray)">Snap.Compute.ClosestPoints</seealso>     
        </member>
        <member name="T:Snap.Compute.DistanceResult">
            <summary>The result of computing the distance between two objects</summary>
            <remarks>
            <para>
            A DistanceResult is returned from the 
            <see cref="O:Snap.Compute.ClosestPoints">Snap.Compute.ClosestPoints</see> functions.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Compute.DistanceResult.Point1">
            <summary>The point on the first object at which the minimum distance is attained</summary>
        </member>
        <member name="P:Snap.Compute.DistanceResult.Point2">
            <summary>The point on the second object at which the minimum distance is attained</summary>
        </member>
        <member name="P:Snap.Compute.DistanceResult.Distance">
            <summary>The minimum distance between the two objects</summary>
        </member>
        <member name="M:Snap.Compute.DistanceResult.#ctor(Snap.Position,Snap.Position,System.Double)">
            <summary>Construct a result object</summary>
            <param name="p1">The point on the first object</param>
            <param name="p2">The point on the second object</param>
            <param name="distance">The minimum distance</param>
            <exclude/>
        </member>
        <member name="M:Snap.Compute.CreateShadow(Snap.Geom.Surface.Plane,Snap.NX.NXObject)">
            <summary>
            Makes a rectangular sheet body for use in calculating ClosestPoint to plane
            </summary>
            <param name="plane">Plane on which rectangle should lie</param>
            <param name="nxObject">Object (curve, edge, face, or body)</param>
            <returns>Corners of rectangle containing projection of bounding box of object</returns>
        </member>
        <member name="M:Snap.Compute.Area(Snap.NX.Face[])">
            <summary>Computes the total area of a collection of faces</summary>
            <param name="faces">Array of faces</param>
            <returns>The total area of the given face array</returns>
            <example> 
            The following example shows how to calculate the area of a collection of faces: 
            <code title="Calculate the area of faces" lang="VB.NET" source="Face_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Compute.Perimeter(Snap.NX.Face[])">
            <summary>Computes the total perimeter of a collection of faces</summary>
            <param name="faces">Array of faces</param>
            <returns>The total perimeter of the given faces</returns>
            <remarks>
            <para>
            The perimeter of a face is the sum of the arclengths of its edges,
            including edges that represent holes in the face.
            </para>
            <para>
            The value returned is the sum of the perimeters of the individual faces.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate the perimeter of a collection of faces: 
            <code title="Perimeter of a collection of faces" lang="VB.NET" source="Face_07.vb"> 
            </code> 
            </example>      
        </member>
        <member name="T:Snap.Compute.IntersectionResult">
            <summary>Represents the result of an intersection calculation</summary>
        </member>
        <member name="P:Snap.Compute.IntersectionResult.Position">
            <summary>Location of the intersection point (or <c>Nothing</c> if no intersection was found)</summary>
        </member>
        <member name="P:Snap.Compute.IntersectionResult.CurveParameter">
            <summary>
            The parameter value of the intersection point on the first object (which is either a curve or a ray)
            </summary>
        </member>
        <member name="P:Snap.Compute.IntersectionResult.ObjectParameters">
            <summary>
            The parameter value(s) of the intersection point on the second object 
            </summary>
            <remarks>
            <para>
            The array always has length = 2, but its elements have different meaning, depending on the type of the second object:
            </para>
            <para>
            Face or body -- ObjectParameters[0,1] = the uv-values at the intersection point.
            </para>
            <para>
            Curve or edge -- ObjectParameters[0] = the curve parameter value at the intersection point.
            </para>
            <para>
            Plane or datum plane -- ObjectParameters has no meaningful information
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Compute.IntersectionResult.Create(NXOpen.UF.UFCurve.IntersectInfo)">
            <summary>
            Creates a Snap.Compute.IntersectionResult from an NXOpen.UF.UFCurve.IntersectInfo
            </summary>
            <param name="info">The NXOpen.UF.UFCurve.IntersectInfo</param>
            <remarks>
            <para>
            Just copies information. Leaves the ObjectParameters field set to <c>Nothing</c>
            (to be filled in later, by the caller)
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">
            <summary>Computes a single point of intersection of two curves or edges</summary>
            <param name="icurve1">The first curve or edge</param>
            <param name="icurve2">The second curve or edge</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersection is found)</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">this function</see> instead.
            </para>
            <para>
            If you only need the location of the intersection, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve)">Compute.Intersect</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect two curves: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_01.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">Snap.Compute.IntersectInfo -- all intersections</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Computes a single point of intersection of a curve (or edge) and a plane</summary>
            <param name="icurve">The curve or edge</param>
            <param name="plane">The plane</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersection is found)</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">this function</see> instead.
            </para>
            <para>
            If you only need the location of the intersection, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Compute.Intersect</see> function.
            </para>
            </remarks>      
            <example> 
            The following example shows how to intersect a curve and a plane: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_02.vb"> 
            </code> 
            </example>           
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Snap.Compute.IntersectInfo -- all intersections</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">
            <summary>Computes a single point of intersection of a curve (or edge) and a face</summary>
            <param name="icurve">The curve or edge</param>
            <param name="face">The face</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersection is found)</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face)">this function</see> instead.
            </para>
            <para>
            If you only need the location of the intersection, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Compute.Intersect</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and face: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_03.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face)">Snap.Compute.IntersectInfo -- all intersections</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">
            <summary>Computes a single point of intersection of a ray and a face</summary>
            <param name="ray">The ray</param>
            <param name="face">The face</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersection is found)</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face)">this function</see> instead.
            </para>
            <para>
            If you only need the location of the intersection, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Compute.Intersect</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a face: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_04.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face)">Snap.Compute.IntersectInfo -- all intersections</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">
            <summary>Computes all points of intersection of two curves or edges</summary>
            <param name="icurve1">The first curve or edge</param>
            <param name="icurve2">The second curve or edge</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersections are found)</returns>
            <remarks>
            <para>
            If you only want to calculate a single intersection point, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you only need the locations of the intersections, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve)">Compute.Intersect</see> function.
            </para>
            </remarks>      
            <example> 
            The following example shows how to intersect two curves: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_15a.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">
            <summary>Computes all points of intersection of a curve (or edge) and a plane</summary>
            <param name="icurve">The curve or edge</param>
            <param name="plane">The plane</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersections are found)</returns>
            <remarks>
            <para>
            If you only want to calculate a single intersection point, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you only need the locations of the intersections, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Compute.Intersect</see> functions.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and a plane: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_16.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face)">
            <summary>Computes all points of intersection of a curve (or edge) and a face</summary>
            <param name="icurve">The curve or edge</param>
            <param name="face">The face</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersections are found)</returns>
            <remarks>
            <para>
            If you only want to calculate a single intersection point, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you only need the locations of the intersections, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face)">Compute.Intersect</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and face: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_17.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face)">
            <summary>Computes all points of intersection of a ray and a face</summary>
            <param name="ray">The ray</param>
            <param name="face">The face</param>
            <returns>The result of the intersection calculation (or <c>Nothing</c> if no intersections are found)</returns>
            <remarks>
            <para>
            If you only want to calculate a single intersection point, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you only need the locations of the intersections, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face)">Compute.Intersect</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a face: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_18.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Body,Snap.Position)">
            <summary>Computes a single point of intersection of a ray and a body</summary>
            <param name="ray">The ray</param>
            <param name="body">The body</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>The result of the intersection calculation</returns>
            <remarks>
            <para>
            If you only need the location of the intersection, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Body,Snap.Position)">Compute.Intersect</see> function.
            </para>
            </remarks>      
            <example> 
            The following example shows how to intersect a ray and a body: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_05.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Body,Snap.Position)">Snap.Compute.Intersect</seealso>
        </member>
        <member name="M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.Geom.Surface.Plane)">
            <summary>Computes a single point of intersection of a ray and a plane</summary>
            <param name="ray">The ray</param>
            <param name="plane">The plane</param>
            <returns>Location of the intersection point, or <c>Nothing</c> if no intersection exists</returns>
            <remarks>
            <para>
            If the ray lies in the plane, then any point on the ray could be regarded
            as an intersection point. In this case, this function returns the point of the
            ray that is closest to the origin.
            </para>
            <para>
            If you only need the location of the intersection, it may be more convenient to use the 
            <see cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.Geom.Surface.Plane)">Compute.Intersect</see> functions.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a plane: 
            <code title="Get intersection information" lang="VB.NET" source="Intersection_14.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.Geom.Surface.Plane)">Snap.Compute.Intersect</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">
            <summary>Computes a single point of intersection of two curves or edges</summary>
            <param name="curve1">The first curve or edge</param>
            <param name="curve2">The second curve or edge</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>Location of intersection point, or <c>Nothing</c> if no intersection is found</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersection, in addition to its location, please use the 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect two curves: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_06.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Computes a single point of intersection of a curve (or edge) and a plane</summary>
            <param name="icurve">The curve or edge</param>
            <param name="plane">The plane</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>Location of intersection point, or <c>Nothing</c> if no intersection is found</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersection, in addition to its location, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and a plane: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_07.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">
            <summary>Computes a single point of intersection of a curve (or edge) and a face</summary>
            <param name="icurve">The curve or edge</param>
            <param name="face">The face</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>Location of intersection point, or <c>Nothing</c> if no intersection is found</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersection, in addition to its location, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and a face: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_08.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">
            <summary>Computes a single point of intersection of a ray and a face</summary>
            <param name="ray">The ray</param>
            <param name="face">The face</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>Location of intersection point, or <c>Nothing</c> if no intersection is found</returns>
            <remarks>
            <para>
            If you want to calculate all points of intersection (rather than just one), please use 
            <see cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersection, in addition to its location, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a face: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_09.vb"> 
            </code> 
            </example>       
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face)">Snap.Compute.Intersect -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve)">
            <summary>Computes all points of intersection of two curves or edges</summary>
            <param name="curve1">The first curve or edge</param>
            <param name="curve2">The second curve or edge</param>
            <returns>Locations of intersection points, or <c>Nothing</c> if no intersection was found</returns>
            <remarks>
            <para>
            If you want to calculate just one point of intersection, please use 
            <see cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersections, in addition to their locations, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect two curves: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_06.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.ICurve,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">
            <summary>Computes all points of intersection of a curve (or edge) and a plane</summary>
            <param name="icurve">The curve or edge</param>
            <param name="plane">The plane</param>
            <returns>Locations of intersection points, or <c>Nothing</c> if no intersection was found</returns>
            <remarks>
            <para>
            If you want to calculate just one point of intersection, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersections, in addition to their locations, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and a plane: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_07a.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.Geom.Surface.Plane,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face)">
            <summary>Computes all points of intersection of a curve (or edge) and a face</summary>
            <param name="icurve">The curve or edge</param>
            <param name="face">The face</param>
            <returns>Locations of intersection points, or <c>Nothing</c> if no intersection was found</returns>
            <remarks>
            <para>
            If you want to calculate just one point of intersection, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersections, in addition to their locations, please use the 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a curve and a face: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_21a.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.Intersect(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.NX.ICurve,Snap.NX.Face,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face)">
            <summary>Computes all points of intersection of a ray and a face</summary>
            <param name="ray">The ray</param>
            <param name="face">The face</param>
            <returns>Locations of intersection points, or <c>Nothing</c> if no intersection was found</returns>
            <remarks>
            <para>
            If you want to calculate just one point of intersection, please use 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">this function</see> instead.
            </para>
            <para>
            If you need more information about the intersections, in addition to their locations, please use the 
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a face: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_22.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Snap.Compute.Intersect -- one intersection</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face)">Snap.Compute.IntersectInfo -- all intersections</seealso>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Face,Snap.Position)">Snap.Compute.IntersectInfo -- one intersection</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.NX.Body,Snap.Position)">
            <summary>Computes a single point of intersection of a ray and a body</summary>
            <param name="ray">The ray</param>
            <param name="body">The body</param>
            <param name="nearPoint">A "help" point near the desired intersection</param>
            <returns>Location of intersection point, or <c>Nothing</c> if no intersection was found</returns>
            <remarks>
            <para>
            If you need more information about the intersection, in addition to its location, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Body,Snap.Position)">Compute.IntersectInfo</see> function.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a body: 
            <code title="Calculate an intersection point" lang="VB.NET" source="Intersection_10.vb"> 
            </code> 
            </example>      
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.NX.Body,Snap.Position)">Snap.Compute.IntersectInfo</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.Geom.Curve.Ray,Snap.Geom.Surface.Plane)">
            <summary>Computes a single point of intersection of a ray and a plane</summary>
            <param name="ray">The ray</param>
            <param name="plane">The plane</param>
            <returns>Location of the intersection point, or <c>Nothing</c> if no intersection exists</returns>
            <remarks>
            <para>
            If the ray lies in the plane, then any point on the ray could be regarded
            as an intersection point. In this case, this function returns the point of the
            ray that is closest to the origin.
            </para>
            <para>
            If you need more information about the intersection, in addition to its location, please use the  
            <see cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.Geom.Surface.Plane)">Compute.IntersectInfo</see> function.  
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect a ray and a plane: 
            <code title="Intersect a ray and a plane" lang="VB.NET" source="Intersection_11.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.IntersectInfo(Snap.Geom.Curve.Ray,Snap.Geom.Surface.Plane)">Snap.Compute.IntersectInfo</seealso>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.Geom.Surface.Plane,Snap.Geom.Surface.Plane,Snap.Geom.Surface.Plane)">
            <summary>Computes the point of intersection of three planes</summary>
            <param name="p1">First plane</param>
            <param name="p2">Second plane</param>
            <param name="p3">Third plane</param>
            <returns>Location of the intersection point, or <c>Nothing</c> if not found</returns>
            <remarks>
            <para>
            Mathematically, the intersection of three planes could be either a point,
            an infinite line, a plane, or nothing (the empty set). This function only handles the case where
            the intersection is a point. In all other cases, it returns <c>Nothing</c>.
            </para>
            </remarks>
            <example> 
            The following example shows how to intersect three planes: 
            <code title="Intersect three planes" lang="VB.NET" source="Intersection_12.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Compute.Intersect(Snap.Geom.Surface.Plane,Snap.Geom.Surface.Plane)">
            <summary>Computes the intersection of two planes (a ray)</summary>
            <param name="p1">First plane</param>
            <param name="p2">Second plane</param>
            <returns>The line of intersection, represented as a ray, or <c>Nothing</c> if not found</returns>
            <remarks>
            <para>
            Mathematically, the intersection of two planes could be either a line,
            a plane, or nothing (the empty set). This function only handles the case where
            the intersection is a line (i.e. the case where the two planes are
            </para>
            not parallel). If the planes are parallel, it returns <c>Nothing</c>.
            </remarks>
            <example> 
            The following example shows how to intersect two planes: 
            <code title="Intersect two planes" lang="VB.NET" source="Intersection_13.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Compute.ClipRay(Snap.Geom.Curve.Ray)">
            <summary>Clips a ray to the model bounding box (the 1 KM cube), giving a line</summary>
            <param name="ray">The ray</param>
            <returns>Line end-points</returns>
        </member>
        <member name="M:Snap.Compute.MassProperties(Snap.NX.Body[])">
            <summary>Calculates the mass properties of a given list of bodies</summary>
            <param name="bodies">Array of NX bodies</param>
            <returns>Mass property results</returns>
            <remarks>
            <para>
            The input can be a (mixed) array of solid bodies and sheet bodies. Sheet bodies are assumed
            to represent thin-walled objects, so they will have non-zero mass and moments of inertia.
            </para>
            <para>
            If the work part's unit is mm, then the return values will use the gram-mm system of units.
            </para>
            <para>
            If work part's unit is inch, then the return values will use the pound-inch system of units.
            </para>
            <para>
            As always in SNAP, the return values are relative to the absolute coordinate system.
            </para>
            <para>
            Before computing mass and moments of inertia, you must assign the correct density
            to the bodies, using the <see cref= "P:Snap.NX.Body.Density">Snap.NX.Body.Density</see> property.
            </para>
            <para>
            SNAP provides simpler functions for calculating mass, volume, and surface area specifically. 
            If you only need one or two of these quantities, these simpler functions might
            be easier for you to use. Links to these functions are provided in the "See Also" section below.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate mass properties: 
            <code title="Calculate mass properties" lang="VB.NET" source="MassProperties_04a.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.Mass(Snap.NX.Body[])">Snap.Compute.Mass</seealso>
            <seealso cref= "M:Snap.Compute.Volume(Snap.NX.Body[])">Snap.Compute.Volume</seealso>
            <seealso cref= "M:Snap.Compute.Area(Snap.NX.Face[])">Snap.Compute.Area</seealso>
            <seealso cref= "P:Snap.NX.Body.Density">Snap.NX.Body.Density</seealso>
        </member>
        <member name="M:Snap.Compute.Mass(Snap.NX.Body[])">
            <summary>Computes the total mass of a collection of bodies</summary>
            <param name="bodies">Array of bodies</param>
            <returns>The total mass of the given array of bodies</returns>
            <remarks>
            <para>
            The input can be a (mixed) array of solid bodies and sheet bodies. Sheet bodies are assumed
            to represent thin-walled objects, so they will have non-zero mass.
            </para>
            <para>
            If the work part's unit is mm, then the return values will be in grams.
            </para>
            <para>
            If work part's unit is inch, then the return values will be in pounds.
            </para>
            <para>
            Before computing mass, you must assign the correct density
            to the bodies, using the <see cref= "P:Snap.NX.Body.Density">Snap.NX.Body.Density</see> property.
            </para>
            <para>
            If you want to calculate several mass properties (rather than just mass), using the
            <see cref= "M:Snap.Compute.MassProperties(Snap.NX.Body[])">Snap.Compute.MassProperties</see> function
            will provide better performance.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate mass: 
            <code title="Calculate mass" lang="VB.NET" source="MassProperties_02a.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.MassProperties(Snap.NX.Body[])">Snap.Compute.MassProperties</seealso>
        </member>
        <member name="M:Snap.Compute.Volume(Snap.NX.Body[])">
            <summary>Computes the total volume of a collection of bodies</summary>
            <param name="bodies">Array of bodies</param>
            <returns>The total volume of the given array of bodies</returns>
            <remarks>
            <para>
            The input can be a (mixed) array of solid bodies and sheet bodies. However,
            the volume of a sheet body is always zero, of course.
            </para>
            <para>
            If the work part's unit is mm, then the return values will be in cubic mm.
            </para>
            <para>
            If work part's unit is inch, then the return values will be in cubic inches.
            </para>
            <para>
            If you want to calculate several mass properties (rather than just volume), using the
            <see cref= "M:Snap.Compute.MassProperties(Snap.NX.Body[])">Snap.Compute.MassProperties</see> function
            will provide better performance.
            </para>
            </remarks>
            <example> 
            The following example shows how to compute the volume of a collection of bodies.
            <code title="Compute the volume of bodies" lang="VB.NET" source="MassProperties_03a.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.MassProperties(Snap.NX.Body[])">Snap.Compute.MassProperties</seealso>
        </member>
        <member name="M:Snap.Compute.MomentOfInertia(Snap.Position,Snap.Vector,Snap.NX.Body[])">
            <summary>Calculates the moment of inertia of a collection of bodies around a given axis</summary>
            <param name="axisPoint">A point on the axis line</param>
            <param name="axisVector">A vector along the axis line (length doesn't matter)</param>
            <param name="bodies">The collection of bodies</param>
            <returns>The moment of inertia around the given axis</returns>
            <remarks>
            <para>
            The input can be a (mixed) array of solid bodies and sheet bodies. Sheet bodies are assumed
            to represent thin-walled objects, so they will have non-zero moments of inertia.
            </para>
            <para>
            If the work part's unit is mm, then the return values will use the gram-mm system of units.
            </para>
            <para>
            If work part's unit is inch, then the return values will use the pound-inch system of units.
            </para>
            <para>
            Before computing moments of inertia, you must assign the correct density
            to the bodies, using the <see cref= "P:Snap.NX.Body.Density">Snap.NX.Body.Density</see> property.
            </para>
            <para>
            If you want to calculate several mass properties (rather than just moments of inertia), using the
            <see cref= "M:Snap.Compute.MassProperties(Snap.NX.Body[])">Snap.Compute.MassProperties</see> function
            will provide better performance.
            </para>
            </remarks>      
            <example> 
            The following example shows how to calculate moment of inertia: 
            <code title="Calculate moment of inertia" lang="VB.NET" source="MassProperties_05a.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Compute.MassProperties(Snap.NX.Body[])">Snap.Compute.MassProperties</seealso>
        </member>
        <member name="T:Snap.Compute.MassPropertiesResult">
            <summary>Holds the results of a mass properties calculation for a collection of bodies</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.Area">
            <summary>The total surface area of the collection of bodies</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.Volume">
            <summary>The total volume of the collection of bodies</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.Mass">
            <summary>The total mass of the collection of bodies</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.Centroid">
            <summary>The centroid of the collection of bodies</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.PrincipalAxes">
            <summary>The principal axes of the collection of bodies at the centroid, in same order as principal moments</summary>
            <remarks>
            <para>
            </para>
            The axes are unit vectors
            </remarks>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.PrincipalMoments">
            <summary>The principal moments of the collection of bodies at the centroid, in order, largest first</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.RadiusOfGyration">
            <summary>The radius of gyration of the collection of bodies</summary>
            <remarks>This is returned only when the input is an array of solid bodies</remarks>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.Density">
            <summary>The density of the overall collection of bodies (total mass divided by total volume or area)</summary>
            <remarks>
            <para>
            The meaning and units of this property depend on the types of bodies being measured:
            <list type = "bullet">
            <item>If the given bodies are all solids, the unit is gm/mm^3;</item>
            <item>If the given bodies are all sheets, the unit is gm/mm^2;</item>
            <item>If the given bodies are a mixture of solids and sheets, this value has no meaning.</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.InertiaTensor">
            <summary>The inertia tensor at the centroid</summary>
            <remarks>
            <para>
            The inertia tensor is a symmetric 3&#215;3 matrix whose entries are moments
            and products of inertia. It can be used to compute the moment of inertia
            around any axis through the centroid of the collection of bodies, although the
            <see cref= "M:Snap.Compute.MomentOfInertia(Snap.Position,Snap.Vector,Snap.NX.Body[])">"Snap.Compute.MomentOfInertia"</see> function
            provides an easier way to do this.
            </para>
            <para>
            If we denote the inertia tensor by M, then we can immediately obtain moments of 
            inertia around certain specific lines through the centroid:
            <list type = "bullet">
            <item>M[0,0] is the moment of inertia around a line parallel to the x-axis</item>
            <item>M[1,1] is the moment of inertia around a line parallel to the y-axis</item>
            <item>M[2,2] is the moment of inertia around a line parallel to the z-axis</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.MomentsOfInertia">
            <summary>Moments of inertia about X, Y, Z axes (Ixx, Iyy, Izz)</summary>
        </member>
        <member name="P:Snap.Compute.MassPropertiesResult.ProductsOfInertia">
            <summary>Products of inertia about X, Y, Z axes (Myz, Mzx, Mzy, in that order)</summary>
        </member>
        <member name="F:Snap.Compute.MassPropertiesResult.Units">
            <summary>Type of units used to express these results</summary>
        </member>
        <member name="M:Snap.Compute.MassPropertiesResult.CompleteResults">
            <summary>Fills in missing information for principal moments and principal axes</summary>
            <returns>Results with principal moments and principal axes added/corrected</returns>
        </member>
        <member name="M:Snap.Compute.MassProperties2(Snap.NX.Body[])">
            <summary>Calculates the mass properties of a given list of bodies</summary>
            <param name="bodies">Array of NX bodies</param>
            <returns>Mass property results</returns>
            <remarks>
            <para>
            Input can either be an array of solid bodies or a single sheet body
            If work part's unit is mm, then the return values will use the gram-mm system of units.
            </para>
            <para>
            If work part's unit is inch, then the return values will use the pound-inch system of units.
            </para>
            <para>
            As always in SNAP, the return values are relative to the absolute coordinate system.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Compute.MakeResult(System.Double[])">
            <summary>Creates a MassPropertiesResult from array of doubles returned from AskMassProps3d</summary>
            <param name="mp">Results array from AskMassProps3d</param>
            <returns>A MassPropertiesResult object</returns>
        </member>
        <member name="M:Snap.Compute.Combine(Snap.Compute.MassPropertiesResult[])">
            <summary>Combine several mass properties results to get an overall total result</summary>
            <param name="inputResults">Results for individual bodies</param>
            <returns>Combined result</returns>
            <remarks>
            <para>
            This function only handles mass, area, volume, centroid, and moments and products of inertia.
            It doesn't combine principal axes, principal moments, or radii of gyration.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Compute.MinimumRadius(Snap.NX.Face)">
            <summary>Computes the minimum radius of curvature of a face</summary>
            <param name="face">An NX.Face object</param>
            <returns>An array of MinimumRadiusResult objects</returns>
            <remarks>
            <para>
            Gets the minimum radius of curvature on each side of the given face, 
            where one exists, and its position and u-v parameters.  
            </para>
            <para>
            A minimum radius of curvature is deemed not to exist on one side of 
            the surface if it is nowhere concave on that side. So the function can
            return 0 (in the case of a plane), 1 (in the case of a cylinder, for example) or 2 minima.      
            </para>
            <para>
            The radius of curvature has a positive sign if the surface is 
            concave with respect to its normal and a negative sign if the surface is 
            convex with respect to its normal.      
            </para>
            </remarks>
            <example> 
            The following example shows how to compute the minimum radius of a face: 
            <code title="Compute the minimum radius of a face" lang="VB.NET" source="MinimumRadius_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="T:Snap.Compute.MinimumRadiusResult">
            <summary>An object that contains the results of a minimum radius calculation</summary>
        </member>
        <member name="P:Snap.Compute.MinimumRadiusResult.Length">
            <summary>The value of the minimum radius of curvature</summary>
            <remarks>
            <para>
            This value will be positive if the face is concave with respect to 
            its normal and negative if the surface is convex with respect to its normal.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Compute.MinimumRadiusResult.Position">
            <summary>The location of the minimum radius</summary>
        </member>
        <member name="P:Snap.Compute.MinimumRadiusResult.U">
            <summary>The U parameter at the location of the minimum radius</summary>
        </member>
        <member name="P:Snap.Compute.MinimumRadiusResult.V">
            <summary>The V parameter at the location of the minimum radius</summary>
        </member>
        <member name="T:Snap.Geom.Box2d">
            <summary>Represents a 2D box (rectangle)</summary>
            <remarks>
            <para>
            Usually used to represent a parameter rectangle on a surface. 
            The box corners are at the points (MinU, MinV) and (MaxU, MaxV).
            </para>
            </remarks>   
            <example>
            This example shows how to use the properties of the Geom.Box2d class:
            <code title="Properties of a Geom.Box2d object: " lang="VB.NET" source="Box_01.vb"> 
            </code>
            </example>
        </member>
        <member name="P:Snap.Geom.Box2d.MinU">
            <summary>The lower u-value</summary>
        </member>
        <member name="P:Snap.Geom.Box2d.MinV">
            <summary>The lower v-value</summary>
        </member>
        <member name="P:Snap.Geom.Box2d.MaxU">
            <summary>The upper u-value</summary>
        </member>
        <member name="P:Snap.Geom.Box2d.MaxV">
            <summary>The upper v-value</summary>
        </member>
        <member name="M:Snap.Geom.Box2d.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates a 2D box from min and max values</summary>
            <param name="minU">Minimum u-value</param>
            <param name="minV">Minimum v-value</param>
            <param name="maxU">Maximum u-value</param>
            <param name="maxV">Maximum v-value</param>      
        </member>
        <member name="T:Snap.Geom.Box3d">
            <summary>Represents a 3D box, with sides aligned with the ACS axes.</summary>
            <remarks>
            <para>
            Usually used to represent a region of space that encloses some object. Every NX
            object of type curve, edge, face, body, feature, or component has a
            Box property that returns its bounding box.
            </para>
            <para>
            The rectangle corners are at the points (MinX, MinY, MinZ) and (MaxX, MaxY, MaxZ).
            </para>
            </remarks>   
            <example>
            This example shows how to use the properties of the Geom.Box3d class:
            <code title="Properties of a Geom.Box3d object: " lang="VB.NET" source="Box_02.vb"> 
            </code>
            </example>
        </member>
        <member name="P:Snap.Geom.Box3d.MinX">
            <summary>The lower x-value</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MinY">
            <summary>The lower y-value</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MinZ">
            <summary>The lower z-value</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MaxX">
            <summary>The upper x-value</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MaxY">
            <summary>The upper y-value</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MaxZ">
            <summary>The upper z-value</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MinXYZ">
            <summary>The lower corner of the box (min X, Y, Z values)</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.MaxXYZ">
            <summary>The upper corner of the box (max X, Y, Z values)</summary>
        </member>
        <member name="P:Snap.Geom.Box3d.Corners">
            <summary>The eight corners of the box</summary>
            <remarks>
            <para>
            The corners are returned in the following order:
            <list type = "bullet">
            <item>Corners[0] is the point ( MinX, MinY, MinZ)</item>
            <item>Corners[1] is the point ( MinX, MinY, MaxZ)</item>
            <item>Corners[2] is the point ( MinX, MaxY, MinZ)</item>
            <item>Corners[3] is the point ( MinX, MaxY, MaxZ)</item>
            <item>Corners[4] is the point ( MaxX, MinY, MinZ)</item>
            <item>Corners[5] is the point ( MaxX, MinY, MaxZ)</item>
            <item>Corners[6] is the point ( MaxX, MaxY, MinZ)</item>
            <item>Corners[7] is the point ( MaxX, MaxY, MaxZ)</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Geom.Box3d.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs a Box3D from minimum and maximum x, y, z values</summary>
            <param name="minX">Minimum x-value</param>
            <param name="minY">Minimum y-value</param>
            <param name="minZ">Minimum z-value</param>
            <param name="maxX">Maximum x-value</param>
            <param name="maxY">Maximum y-value</param>
            <param name="maxZ">Maximum z-value</param>      
        </member>
        <member name="M:Snap.Geom.Box3d.#ctor(Snap.Position,Snap.Position)">
            <summary>Constructs a Box3D from given corner positions</summary>
            <param name="minXYZ">The "lower" corner position (MinX, MinY, MinZ)</param>
            <param name="maxXYZ">The "upper" corner position (MaxX, MaxY, MaxZ)</param>      
        </member>
        <member name="M:Snap.Geom.Box3d.Combine(Snap.Geom.Box3d[])">
            <summary>Combines several 3D boxes (giving the largest overall enclosing box)</summary>
            <param name="inputBoxes">The input boxes that are to be combined</param>
            <returns>Box enclosing all the input boxes</returns>
        </member>
        <member name="T:Snap.Geom.Surface">
            <summary>
            Represents a non-persistent infinite surface -- not stored in NX
            </summary>
            <remarks>
            <para>
            The most common use for Geom.Surface objects is to return
            information about the geometry of faces. Specifically, the
            Geometry property of an NX.Face returns a Geom.Surface
            object of the appropriate type, which you can then use
            to obtain geometric information. Examples of this
            usage are given in the many of the derived classes, such as
            <see cref="T:Snap.Geom.Surface.Plane">Geom.Surface.Plane</see>, 
            <see cref="T:Snap.Geom.Surface.Cone">Geom.Surface.Cone</see>, and
            <see cref="T:Snap.Geom.Surface.Bsurface">Geom.Surface.Bsurface</see>,
            and others.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Geom.Surface.Bsurface">
            <summary>Represents a non-persistent B-surface object -- not stored in NX</summary>
            <remarks>
            <para>
            A Snap.Geom.Surface.Bsurface is very similar to a Snap.NX.Bsurface, of course.
            The big difference is that the latter is an object in an NX part file, whereas
            the former is a non-persistent object that only exists in memory while your
            program is running. Geom objects are completely independent of the NX database,
            and can even be used outside of NX sessions. For this reason, computations on Geom
            objects are often much faster than similar computations on NX objects.
            </para>
            <para>
            The representation used here consists of
            <list type="bullet">
                <item>Poles    -- A 2D array of nu x nv 3D poles (control vertices)</item>
                <item>KnotsU   -- An array of nu+ku knot values : u[0], ... , u[nu+ku-1]</item>
                <item>KnotsV   -- An array of nv+kv knot values : v[0], ... , u[nv+kv-1]</item>
                <item>Weights  -- A 2D array of nu x nv weight values</item>
            </list>
            </para>
            <para>
            The degrees of the surface in the u and v directions are determined by the sizes of the given arrays:
            <list type="bullet">
                <item><c>DegreeU  = knotsU.Length - Poles.GetLength(0) - 1</c></item>
                <item><c>DegreeV  = knotsV.Length - Poles.GetLength(1) - 1</c></item>
            </list>
            </para>
            <para>
            Poles p[0,0], p[0,1], ... ,p[0,nv-1] lie along edge u = 0  (0 &lt; v &lt; 1)
            </para>
            <para>
            Poles p[0,0], p[1,0], ... ,p[nu-1,0] lie along edge v = 0  (0 &lt; u &lt; 1)
            </para>
            So, in particular
            <list type = "bullet">
            <item>p[0,0]   = S(0,0)</item>
            <item>p[0,nv-1]  = S(0,1)</item>
            <item>p[nu-1,0]  = S(1,0)</item>
            <item>p[nu-1,nv-1] = S(1,1)</item>
            </list>
            </remarks>      
            <example> 
            This example shows how to use the properties of the Geom.Surface.Bsurface class:
            <code title="Properties of a Geom.Surface.Bsurface object: " lang="VB.NET" source="GeomBsurface_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.Poles">
            <summary> Array of poles (3D) </summary>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.Weights">
            <summary> Array of weight values</summary>
            <remarks>
            <para>
            </para>
            The weights must be positive. This is not checked.
            </remarks>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.KnotsU">
            <summary> Array of knot values in u-direction </summary>
            <remarks> There will be nu + ku knots, with indices 0,1,2,...,nu + ku - 1, where ku = Order </remarks>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.KnotsV">
            <summary> Array of knot values in v-direction </summary>
            <remarks> There will be nv + kv knots, with indices 0,1,2,...,nv + kv - 1, where kv = Order </remarks>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.OrderU">
            <summary>The order of the b-surface in the u-direction</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.OrderV">
            <summary>The order of the b-surface in the v-direction</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.DegreeU">
            <summary>The degree of the b-surface in the u-direction</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Bsurface.DegreeV">
            <summary>The degree of the b-surface in the v-direction</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.#ctor(Snap.Position[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a polynomial Geom.Bsurface from poles and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D positions representing poles</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <remarks>
            <para>
            The degrees of the surface in the u and v directions are determined by the sizes of the given arrays:
                DegreeU  = knotsU.Length - Poles.GetLength(0) - 1
                DegreeV  = knotsV.Length - Poles.GetLength(1) - 1
            </para>
            <para>
            Poles p[0,0], p[0,1], ... ,p[0,mv] lie along edge u = 0  (0 &lt; v &lt; 1)
            Poles p[0,0], p[1,0], ... ,p[mu,0] lie along edge v = 0  (0 &lt; u &lt; 1)
            </para>
            </remarks>       
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.#ctor(Snap.Position[0:,0:],System.Double[0:,0:],System.Double[],System.Double[])">
             <summary>Constructs a rational Geom.Bsurface from poles, weights, and knot sequences</summary>
             <param name="poles">A 2D array of nu x nv 3D vectors representing poles</param>
             <param name="weights">A 2D array of nu x nv values representing weights</param>
             <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
             <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
             <remarks>
             <para>
             The order ku in the u-direction can be inferred from the sizes of the given arrays:
                 nu  = number of poles in u-direction = Poles.GetLength(0) 
                 npku = nu + ku = number of u-knots = knotsU.Length
             Then ku = npku - ku. Also, as usual, degree is given by mu = ku - 1. Similarly for the v-direction.
            
             Poles p[0,0], p[0,1], ... ,p[0,mv] lie along edge u = 0  (0 &lt; v &lt; 1)
             Poles p[0,0], p[1,0], ... ,p[mu,0] lie along edge v = 0  (0 &lt; u &lt; 1)
             </para>
             </remarks>       
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.Create(Snap.Position[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a polynomial Geom.Bsurface from poles and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D positions representing poles</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <returns>A polynomial Geom.Bsurface</returns>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.Create(Snap.Position[0:,0:],System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a rational Geom.Bsurface from poles, weights, and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D vectors representing poles</param>
            <param name="weights">A 2D array of nu x nv values representing weights</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>       
            <returns>A rational Geom.Bsurface</returns>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.CreateBezier(Snap.Position[0:,0:],System.Double[0:,0:])">
            <summary>Creates a Geom.Bsurface that is a rational Bezier patch</summary>
            <param name="poles">A 2D array of (mu+1) x (mv+1) 3D positions representing poles</param>
            <param name="weights">A 2D array of (mu+1) x (mv+1) values representing weights</param>
            <returns>A rational Bezier patch of degree mu x mv</returns>
            <seealso cref="M:Snap.Create.BezierPatch(Snap.Position[0:,0:],System.Double[0:,0:])">Snap.Create.BezierPatch</seealso>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.CreateBezier(Snap.Position[0:,0:])">
            <summary>Creates a Geom.Bsurface that is polynomial Bezier patch</summary>
            <param name="poles">A 2D array of (mu+1) x (mv+1) 3D positions representing poles</param>
            <returns>A polynomial Bezier patch of degree mu x mv</returns>
            <seealso cref="M:Snap.Create.BezierPatch(Snap.Position[0:,0:])">Snap.Create.BezierPatch</seealso>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.Position(System.Int32,System.Int32,System.Double[])">
            <summary>Evaluates a point on a Snap.Geom.Surface.Bsurface at given (u,v) parameter values</summary>
            <param name="spanU">Span index in u-direction</param>
            <param name="spanV">Span index in v-direction</param>
            <param name="uv">The (u,v) parameter values</param>
            <returns>Point on surface at the given (u,v) parameter values</returns>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception> 
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
            <seealso cref="M:Snap.NX.Face.Parameters(Snap.Position)">Snap.NX.Face.Parameters</seealso>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.Position(System.Double[])">
            <summary>Evaluates a point on a Snap.Geom.Surface.Bsurface at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values</param>
            <returns>Point on surface at the given (u,v) parameter values</returns>
            <remarks>
            <para>
            You can get exactly the same results by using the
            <see cref="M:Snap.NX.Face.Position(System.Double[])">Snap.NX.Face.Position</see>.
            However, this function is much faster (often by a factor of 20x or so).
            </para>
            </remarks>
            <example> 
            This example shows how to use the Geom.Surface.Bsurface.Position function:
            <code title="Calculating points on a Geom.Surface.Bsurface object: " lang="VB.NET" source="GeomBsurface_02.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception> 
            <seealso cref="M:Snap.NX.Face.Position(System.Double[])">Snap.NX.Face.Position</seealso>
        </member>
        <member name="M:Snap.Geom.Surface.Bsurface.UnitWeights(System.Int32,System.Int32)">
            <summary>
            Constructs weights array full of 1's (for polynomial surfaces)
            </summary>
            <param name="m">First dimension</param>
            <param name="n">Second dimension</param>
            <returns>Array of weights all equal to 1</returns>
        </member>
        <member name="T:Snap.Geom.Surface.Blend">
            <summary>Represents a non-persistent blending surface -- not stored in NX</summary>
            <example>
            This example shows how to use the properties of the Geom.Surface.Blend class:
            <code title="Properties of a Geom.Surface.Blend object: " lang="VB.NET" source="GeomBlend_01.vb">
            </code>
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Blend.Radius">
            <summary>Radius of the blending surface</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Blend.#ctor(System.Double)">
            <summary>Constructs a blending surface</summary>
            <param name="radius">The radius of blending surface</param>
        </member>
        <member name="T:Snap.Geom.Surface.Cone">
            <summary>Represents a non-persistent conical surface -- not stored in NX</summary>        
            <example> 
            This example shows how to use the properties of the Geom.Surface.Cone class:
            <code title="Properties of a Geom.Surface.Cone object: " lang="VB.NET" source="GeomCone_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Cone.AxisVector">
            <summary>Axis vector of the conical surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Cone.AxisPoint">
            <summary>Axis point of the conical surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Cone.Radius">
            <summary>Radius at axis point</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Cone.HalfAngle">
            <summary>Half-angle, in degrees</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Cone.#ctor(Snap.Position,Snap.Vector,System.Double,System.Double)">
            <summary>Constructs a conical surface</summary>
            <param name="axisPoint">The cone base position of base arc</param>
            <param name="axisVector">The cone axis vector from base to top</param>
            <param name="radius">The radius at axis point</param>
            <param name="halfAngle">The cone half-angle in degree which is half of the coning angle. The cone half-angle cannot greater than Atan(baseDiameter / (2.0 * height))</param>
        </member>
        <member name="T:Snap.Geom.Surface.Cylinder">
            <summary>Represents a non-persistent cylindrical surface -- not stored in NX</summary>         
            <example> 
            This example shows how to use the properties of the Geom.Surface.Cylinder class:
            <code title="Properties of a Geom.Surface.Cylinder object: " lang="VB.NET" source="GeomCylinder_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Cylinder.AxisVector">
            <summary>Axis vector of the cylindrical surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Cylinder.AxisPoint">
            <summary>Axis point of the cylindrical surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Cylinder.Diameter">
            <summary>Diameter of the cylindrical surface</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Cylinder.#ctor(Snap.Position,Snap.Vector,System.Double)">
            <summary>Constructs a cylindrical surface</summary>
            <param name="axisPoint">The point at base of cylinder</param>
            <param name="axisVector">The cylinder axis vector (length doesn't matter)</param>
            <param name="diameter">The cylinder diameter</param>
        </member>
        <member name="T:Snap.Geom.Surface.Extrude">
            <summary>Represents a non-persistent extruded surface -- not stored in NX</summary>
            <example> 
            This example shows how to use the properties of the Geom.Surface.Extrude class:
            <code title="Properties of a Geom.Surface.Extrude object: " lang="VB.NET" source="GeomExtrude_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Extrude.Direction">
            <summary>Axis vector of the extruded surface</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Extrude.#ctor(Snap.Vector)">
            <summary>Constructs an extruded surface through given vector</summary>
            <param name="direction">Extruded direction</param>
        </member>
        <member name="T:Snap.Geom.Surface.Offset">
            <summary>Represents a non-persistent offset surface -- not stored in NX</summary>
            <example> 
            This example shows how to use the properties of the Geom.Surface.Offset class:
            <code title="Properties of a Geom.Surface.Offset object: " lang="VB.NET" source="GeomOffset_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Offset.Distance">
            <summary>Offset Distance</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Offset.#ctor(System.Double)">
            <summary>Constructs an offset surface</summary>
            <param name="distance">Offset distance</param>
        </member>
        <member name="T:Snap.Geom.Surface.Plane">
            <summary>Represents a non-persistent infinite plane -- not stored in NX</summary>
            <remarks>
            <para>
            The plane equation is X*Normal = D.
            </para>
            <para>
            The point D*Normal lies on the plane.
            </para>
            </remarks>      
            <example> 
            This example shows how to use the properties of the Geom.Surface.Plane class:
            <code title="Properties of a Geom.Surface.Plane object: " lang="VB.NET" source="GeomPlane_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Plane.Normal">
            <summary> Normal vector (a unit vector) </summary>
            <remarks>
            <para>
            When you set this property, the vector you use does not need to be
            a unit vector; the input vector will be unitized internally.
            On the other hand, when you get the value of this property, you will
            always receive a unit vector. This means that the vector you get 
            may not be the same one you used when setting.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Geom.Surface.Plane.D">
            <summary> Signed distance from origin to plane, measured along the plane normal</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Plane.Origin">
            <summary>Origin of plane : the point at D*Normal</summary>
            <remarks>
            <para>
            </para>
            This is the point on the plane that is closest to the origin.
            </remarks>
        </member>
        <member name="M:Snap.Geom.Surface.Plane.#ctor(Snap.Position,Snap.Vector)">
            <summary>Constructs a plane through a given point and normal</summary>
            <param name="point">Point lying on plane</param>
            <param name="normal">Normal vector</param>
            <remarks>
            <para>
            </para>
            The normal vector does not need to have unit length.
            </remarks>
        </member>
        <member name="M:Snap.Geom.Surface.Plane.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs a plane from algebraic coefficients (a*x + b*y + c*z = d)</summary>
            <param name="a">Coefficient of x</param>
            <param name="b">Coefficient of y</param>
            <param name="c">Coefficient of z</param>
            <param name="d">Constant term (on right-hand side)</param>
            <remarks>The plane has equation  ax + by + cz = d</remarks>         
        </member>
        <member name="M:Snap.Geom.Surface.Plane.#ctor(Snap.Position,Snap.Position,Snap.Position)">
            <summary>Constructs a plane through three points</summary>
            <param name="p0">First point</param>
            <param name="p1">Second point</param>
            <param name="p2">Third point</param>         
        </member>
        <member name="M:Snap.Geom.Surface.Plane.#ctor(Snap.Vector,System.Double)">
            <summary>
            Constructs a plane given normal and distance
            </summary>
            <param name="normal">Normal vector of plane</param>
            <param name="distance">Signed distance from origin to plane, along the normal vector</param>
            <remarks>
            <para>
            The plane equation is X*Normal = distance.
            </para>
            <para>The point distance*Normal lies on the plane.</para>
            <para>The input vector is not required to have unit length; it will
            be unitized inside this function.</para>
            </remarks>         
        </member>
        <member name="T:Snap.Geom.Surface.Revolve">
            <summary>Represents a non-persistent revolved surface -- not stored in NX</summary>         
            <example> 
            This example shows how to use the properties of the Geom.Surface.Revolve class:
            <code title="Properties of a Geom.Surface.Revolve object: " lang="VB.NET" source="GeomRevolve_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Revolve.AxisVector">
            <summary>Axis vector of the revolved surface </summary>
        </member>
        <member name="P:Snap.Geom.Surface.Revolve.AxisPoint">
            <summary>Axis point of the revolved surface</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Revolve.#ctor(Snap.Vector,Snap.Position)">
            <summary>Constructs a revolved surface</summary>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
        </member>
        <member name="T:Snap.Geom.Surface.Sphere">
            <summary>Represents a non-persistent spherical surface -- not stored in NX</summary>         
            <example> 
            This example shows how to use the properties of the Geom.Surface.Sphere class:
            <code title="Properties of a Geom.Surface.Sphere object: " lang="VB.NET" source="GeomSphere_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Sphere.Diameter">
            <summary>Diameter of the spherical surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Sphere.Center">
            <summary>Center of the spherical surface</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Sphere.#ctor(Snap.Position,System.Double)">
            <summary>Constructs a spherical surface through a point and the radius</summary>
            <param name="center">Center of spherical surface</param>
            <param name="diameter">Diameter of spherical surface</param>
        </member>
        <member name="T:Snap.Geom.Surface.Torus">
            <summary>Represents a non-persistent toroidal surface -- not stored in NX</summary>      
            <example> 
            This example shows how to use the properties of the Geom.Surface.Torus class:
            <code title="Properties of a Geom.Surface.Torus object: " lang="VB.NET" source="GeomTorus_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Surface.Torus.AxisVector">
            <summary>Axis Vector of the toroidal surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Torus.AxisPoint">
            <summary>Axis point of the toroidal surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Torus.MajorRadius">
            <summary>Major radius of the toroidal surface</summary>
        </member>
        <member name="P:Snap.Geom.Surface.Torus.MinorRadius">
            <summary>Minor radius of the toroidal surface</summary>
        </member>
        <member name="M:Snap.Geom.Surface.Torus.#ctor(Snap.Vector,Snap.Position,System.Double,System.Double)">
            <summary>Constructs a toroidal surface through a vector, a point , major radius and minor radius</summary>
            <param name="axisPoint">Axis point</param>
            <param name="axisVector">Vector along axis of revolution (length doesn't matter)</param>
            <param name="majorRadius">Major radius (radius of "spine" circle)</param>
            <param name="minorRadius">Minor radius (radius of "section" circle)</param>
        </member>
        <member name="T:Snap.Geom.Curve">
            <summary>
            Represents a non-persistent curve -- not stored in NX
            </summary>
            <remarks>
            <para>
            The most common use for Geom.Curve objects is to return
            information about the geometry of edges. Specifically, the
            Geometry property of an NX.Edge returns a Geom.Curve
            object of the appropriate type, which you can then use
            to obtain geometric information. Examples of this
            usage are given in the 
            <see cref="T:Snap.Geom.Curve.Line">Geom.Curve.Line</see>, 
            <see cref="T:Snap.Geom.Curve.Arc">Geom.Curve.Arc</see>, and
            <see cref="T:Snap.Geom.Curve.Ellipse">Geom.Curve.Ellipse</see> classes.   
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Geom.Curve.Ray">
            <summary>Represents a non-persistent infinite line -- not stored in NX</summary>      
            <example> 
            This example shows how to use the properties of a Geom.Curve.Ray object: 
            <code title="Geom.Curve.Ray properties" lang="VB.NET" source="GeomRay_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="P:Snap.Geom.Curve.Ray.Axis">
            <summary> A vector along the ray (a unit vector) </summary>
            <remarks>
            <para>
            When you set this property, the vector you use does not need to be
            a unit vector; the input vector will be unitized internally.
            On the other hand, when you get the value of this property, you will
            always receive a unit vector. This means that the vector you get 
            may not be the same one you used when setting.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Geom.Curve.Ray.Origin">
            <summary> A position on the ray</summary>
        </member>
        <member name="M:Snap.Geom.Curve.Ray.#ctor(Snap.Position,Snap.Vector)">
            <summary>Constructs a ray from a given position and vector</summary>
            <param name="origin">Point lying on ray</param>
            <param name="axis">Vector along ray</param>
            <remarks>
            <para>
            </para>
            The input axis vector is not required to have unit length; it is unitized within this function. 
            </remarks>
            <example> 
            This example shows how to create a ray: 
            <code title="Create a ray" lang="VB.NET" source="GeomRay_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.Geom.Curve.Line">
            <summary>Represents a non-persistent line -- not stored in NX</summary>      
            <example> 
            This example shows how to use the properties of a Geom.Curve.Line object: 
            <code title="Geom.Curve.Line properties" lang="VB.NET" source="GeomLine_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Curve.Line.StartPoint">
            <summary>The start point of the line</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Line.EndPoint">
            <summary>The end point of the line</summary>
        </member>
        <member name="M:Snap.Geom.Curve.Line.#ctor(Snap.Position,Snap.Position)">
            <summary>Constructs a line from two points</summary>
            <param name="startPoint">Position for start of line</param>
            <param name="endPoint">Position for end of line</param>
        </member>
        <member name="T:Snap.Geom.Curve.Arc">
            <summary>Represents a non-persistent circular arc -- not stored in NX</summary>
            <example> 
            This example shows how to use the properties of a Geom.Curve.Arc object 
            <code title="Geom.Curve.Arc properties" lang="VB.NET" source="GeomArc_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="P:Snap.Geom.Curve.Arc.Center">
            <summary> The center of the arc (in absolute coordinates) </summary>
        </member>
        <member name="P:Snap.Geom.Curve.Arc.AxisX">
            <summary> A unit vector along the X-axis of the arc (where angle = 0)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Arc.AxisY">
            <summary> A unit vector along the Y-axis of the arc (where angle = 90)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Arc.Radius">
            <summary> The radius of the arc</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Arc.StartAngle">
            <summary> The start angle of the arc (in degrees) </summary>
        </member>
        <member name="P:Snap.Geom.Curve.Arc.EndAngle">
            <summary> The end angle of the arc (in degrees) </summary>
        </member>
        <member name="M:Snap.Geom.Curve.Arc.#ctor(Snap.Position,Snap.Vector,Snap.Vector,System.Double,System.Double,System.Double)">
            <summary>Constructs an arc from center, axes, radius, angles in degrees</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="radius">Radius</param>
            <param name="startAngle">Start angle (in degrees)</param>
            <param name="endAngle">End angle (in degrees)</param>
        </member>
        <member name="M:Snap.Geom.Curve.Arc.Fillet(Snap.Position,Snap.Position,Snap.Position,System.Double)">
            <summary>Constructs a fillet arc from three points</summary>
            <param name="p0">First point</param>
            <param name="pa">Apex point</param>
            <param name="p1">Last point</param>
            <param name="radius">Radius</param>
            <returns>A Geom.Arc representing the fillet</returns>
            <remarks>
            <para>
            The fillet will be tangent to the lines p0-pa and pa-p1.
            Its angular span will we be less than 180 degrees.
            </para>
            </remarks>
            <example> 
            This example shows how to create an fillet arc: 
            <code title="Create an fillet arc" lang="VB.NET" source="Arc_09.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.Geom.Curve.Ellipse">
            <summary>Represents a non-persistent ellipse -- not stored in NX</summary>      
            <example> 
            This example shows how to use the properties of a Geom.Curve.Ellipse object 
            <code title="Geom.Curve.Ellipse properties" lang="VB.NET" source="GeomEllipse_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.RadiusX">
            <summary>The half-width of the ellipse in its X-direction</summary>
            <remarks>
            <para>
            This is the "a" parameter in the standard ellipse equation 
            <c>(x^2)/(a^2) + (y^2)/(b^2) = 1</c>.
            </para>
            <para>
            It is sometimes known as the "major" radius, but this name is somewhat misleading since 
            it is not necessarily true that RadiusX &gt; RadiusY.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.RadiusY">
            <summary>The half-width of the ellipse in its Y-direction</summary>
            <remarks>
            <para>
            This is the "b" parameter in the standard ellipse equation 
            <c>(x^2)/(a^2) + (y^2)/(b^2) = 1</c>.         
            </para>
            <para>
            It is sometimes known as the "minor" radius, but this name is somewhat misleading since 
            it is not necessarily true that RadiusY &lt; RadiusX.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.Center">
            <summary> Center of ellipse (in absolute coordinates)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.AxisX">
            <summary>A unit vector along the X-axis of the ellipse (where angle = 0)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.AxisY">
            <summary>A unit vector along the Y-axis of the ellipse (where angle = 90)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.StartAngle">
            <summary>Start angle (in degrees)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Ellipse.EndAngle">
            <summary>End angle (in degrees)</summary>
        </member>
        <member name="M:Snap.Geom.Curve.Ellipse.#ctor(Snap.Position,Snap.Vector,Snap.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates an NX.Ellipse from center, axes, radius, angles in degrees</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="majorRadius">The major radius</param>
            <param name="minorRadius">The minor radius</param>
            <param name="startAngle">Start angle (in degrees)</param>
            <param name="endAngle">End angle (in degrees)</param>
            <returns>An NX.Ellipse object</returns>
        </member>
        <member name="T:Snap.Geom.Curve.Spline">
            <summary>Represents a non-persistent spline curve -- not stored in NX</summary>      
            <example> 
            This example shows how to use the properties of a Geom.Curve.Spline object: 
            <code title="Geom.Curve.Spline properties" lang="VB.NET" source="GeomSpline_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Geom.Curve.Spline.Poles">
            <summary> Array of poles</summary>
            <remarks> There will be n poles, with indices 0,1,2,...,n-1 </remarks>
        </member>
        <member name="P:Snap.Geom.Curve.Spline.Weights">
            <summary> Array of weight values</summary>
            <remarks>
            <para>
            </para>
            The weights must be positive. This is not checked.
            </remarks>
        </member>
        <member name="P:Snap.Geom.Curve.Spline.Knots">
            <summary> Array of knot values </summary>
            <remarks> There will be n+k knots, with indices 0,1,2,...,n+k-1, where k = Order </remarks>
        </member>
        <member name="P:Snap.Geom.Curve.Spline.Degree">
            <summary>The degree of the spline, m (equal to order - 1)</summary>
        </member>
        <member name="P:Snap.Geom.Curve.Spline.Order">
            <summary>The order of the spline, k (equal to degree + 1)</summary>        
        </member>
        <member name="M:Snap.Geom.Curve.Spline.#ctor(System.Double[],Snap.Position[],System.Double[])">
            <summary>Creates a rational Geom.Curve.Spline from knots, poles, and weights</summary>
            <param name="knots">Knots -- an array of n+k knot values : t[0], ... , t[n+k-1]</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <param name="weights">An array of n weight values</param>
        </member>
        <member name="M:Snap.Geom.Curve.Spline.Create(System.Double[],Snap.Position[],System.Double[])">
            <summary>Creates a rational Geom.Curve.Spline from knots, poles, and weights</summary>
            <param name="knots">Knots -- an array of n+k knot values : t[0], ... , t[n+k-1]</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <param name="weights">An array of n weight values</param>
            <returns>A Snap.Geom.Curve.Spline object</returns>
            <remarks>
            <para>
            To create a Bezier curve (which is a spline having only a single segment), you can use the
            <see cref= "O:Snap.Geom.Curve.Spline.CreateBezier">CreateBezier</see> functions.
            </para>
            </remarks>
            <seealso cref= "O:Snap.Create.Spline">Snap.Create.Spline</seealso> 
            <seealso cref= "O:Snap.Create.BezierCurve">Snap.Create.BezierCurve</seealso> 
        </member>
        <member name="M:Snap.Geom.Curve.Spline.Create(System.Double[],Snap.Position[])">
            <summary>Creates a polynomial Geom.Curve.Spline from knots and poles</summary>
            <param name="knots">Knots -- an array of n+k knot values : t[0], ... , t[n+k-1]</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <returns>A Snap.Geom.Curve.Spline object</returns>
            <remarks>
            <para>
            To create a Bezier curve (which is a spline having only a single segment), you can use the
            <see cref= "O:Snap.Geom.Curve.Spline.CreateBezier">CreateBezier</see> functions.
            </para>
            </remarks> 
            <seealso cref= "O:Snap.Create.SplineThroughPoints">SplineThroughPoints</seealso>
        </member>
        <member name="M:Snap.Geom.Curve.Spline.CreateBezier(Snap.Position[],System.Double[])">
            <summary>Creates a rational Bezier curve from given poles and weights</summary>
            <param name="poles">Array of m+1 poles (3D)</param>
            <param name="weights">Array of m+1 weights</param>
            <returns>A Snap.Geom.Curve.Spline object that is a rational Bezier curve of degree m</returns>
        </member>
        <member name="M:Snap.Geom.Curve.Spline.CreateBezier(Snap.Position[])">
            <summary>Creates a polynomial Bezier curve from given poles</summary>
            <param name="poles">Array of m+1 poles (3D)</param>
            <returns>A Snap.Geom.Curve.Spline object that is a polynomial Bezier curve of degree m</returns>
        </member>
        <member name="M:Snap.Geom.Curve.Spline.Position(System.Int32,System.Double)">
            <summary>Calculates a point on the curve at a given parameter value</summary>
            <param name="r">The index of the span on which the given parameter value lies</param>
            <param name="t">Parameter value</param>
            <returns>The point corresponding to the given parameter value</returns>
            <remarks>
            <para>
            The span index is the number r such that t[r] &#8804; t &lt; t[r+1].
            Legal values are Degree &#8804; r &#8804; Knots.Length - 1.
            </para>
            <para>
            If you don't know the span index, you can use the other Position function,
            which does not require it as input. But, if you're going to do multiple
            evaluations on a known span, this function is faster.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Geom.Curve.Spline.Position(System.Double)">
            <summary>Calculates a point on the curve at a given parameter value</summary>
            <param name="t">Parameter value</param>
            <returns>The point corresponding to the given parameter value</returns>
            <remarks>
            <para>
            You can get exactly the same results by using the
            <see cref="M:Snap.NX.Curve.Position(System.Double)">Snap.NX.Curve.Position</see> function.
            However, this function is typically much faster.
            </para>
            </remarks> 
            <seealso cref="M:Snap.NX.Curve.Position(System.Double)">Snap.NX.Curve.Position</seealso>
        </member>
        <member name="T:Snap.Geom.NamespaceDoc">
            <summary> 
            Contains classes representing temporary abstract geometric objects
            that are not part of the NX model.
            </summary>
            <remarks>
            <para>
            Geom objects are completely independent of the NX database,
            and can even be used outside of NX sessions. For this reason, computations 
            on Geom objects are often much faster than similar computations on NX objects.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Geom.Transform">
            <summary>
            Class for building and applying NX transformations
            </summary>
            <remarks>
            <para>
            The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.
            </para>
            </remarks>
            <example>
            This example shows how to construct and use transformations.
            <code title="Transformations" lang="VB.NET" source="Transform_01.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.Geom.Transform.#ctor(System.Double[])">
            <summary>Constructor, given an array of doubles (the matrix elements)</summary>
            <param name="array">Array of 12 doubles (the matrix elements)</param>
            <remarks>
            <para>
            The transform moves a given point (x, y, z) to a new location (xnew, ynew, znew) as follows:
            </para>
            <para>       
            &#xA0;&#xA0;&#xA0; xnew &#xA0; = &#xA0; x*m[0] &#xA0; + &#xA0; y*m[1] &#xA0; + &#xA0; z*m[2]  &#xA0;&#xA0; + m[3]
            </para>
            <para>
            &#xA0;&#xA0;&#xA0; ynew &#xA0; = &#xA0; x*m[4] &#xA0; + &#xA0; y*m[5] &#xA0; + &#xA0; z*m[6]  &#xA0;&#xA0; + m[7]
            </para>
            <para>
            &#xA0;&#xA0;&#xA0; znew &#xA0; = &#xA0; x*m[8] &#xA0; + &#xA0; y*m[9] &#xA0; + &#xA0; z*m[10]  &#xA0;&#xA0; + m[11]
            </para> 
            </remarks>
        </member>
        <member name="M:Snap.Geom.Transform.CreateTranslation(Snap.Vector)">
            <summary>Creates a transform that performs translation</summary>
            <param name="v">Translation vector</param>
            <returns>Transform that performs the translation</returns>
            <remarks>
            <para>
            The transform can be applied to Positions and NX objects by calling the appropriate Move or Copy functions.
            Note that translating vectors doesn't really make sense.
            </para>
            </remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Translation transformation" lang="VB.NET" source="Transform_01.vb"> 
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateTranslation(System.Double,System.Double,System.Double)">
            <summary>Creates a transform that performs translation</summary>
            <param name="dx">Displacement in the X-direction</param>
            <param name="dy">Displacement in the Y-direction</param>
            <param name="dz">Displacement in the Z-direction</param>
            <returns>Transform that performs the translation</returns>
            <remarks>
            <para>
            The transform can be applied to Positions and NX objects by calling the appropriate Move or Copy functions.
            Note that translating vectors doesn't really make sense.
            </para>
            </remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Translation transformations" lang="VB.NET" source="Transform_02.vb"> 
            </code>
            </example>
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateTranslation">
            <summary>Creates an identify translation</summary>
            <returns>Transform that performs an identity (null) translation</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Identity transformation" lang="VB.NET" source="Transform_03.vb"> 
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateRotation(Snap.Position,Snap.Vector,System.Double)">
            <summary>Creates a transform that performs rotation around a given axis</summary>
            <param name="basePoint">Point on the axis</param>
            <param name="axis">Vector along the axis</param>
            <param name="angle">Angle of rotation (in degrees)</param>
            <returns>Transform that performs the rotation</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Rotation transformations " lang="VB.NET" source="Transform_04.vb"> 
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateRotation(Snap.Position,System.Double)">
            <summary>Creates a transform that performs 2D rotation around a point in the XY-plane</summary>
            <param name="basePoint">Point (presumably on the XY-plane</param>
            <param name="angle">Angle of rotation (in degrees)</param>
            <returns>Transform that performs the rotation</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use transformations: 
            <code title="transformations this function" lang="VB.NET" source="Transform_05.vb">
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateRotation(Snap.Orientation)">
            <summary>Creates a transform that performs rotation defined by an orientation</summary>
            <param name="orientation">The orientation</param>
            <returns>Transform that performs the rotation</returns>
            <remarks>
            <para>
            The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.
            </para>
            <para>
            The transform returned is a rotation around a line through the origin that would move the ACS axes so as to align them with the
            axes of the given orientation. In NX terms, this is a "reposition" transformation.
            </para>
            </remarks>
            <returns>Transform that performs the rotation</returns>
            <example> 
            The following example shows how to use this function: 
            <code title="Reposition transformations" lang="VB.NET" source="Transform_06.vb">
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateScale(Snap.Position,System.Double[])">
            <summary>Creates a transform that performs a (non-uniform) scaling operation</summary>
            <param name="basePoint">The basePoint for the scaling operation</param>
            <param name="scaleFactors">The scaling factors for the X, Y, Z directions</param>
            <returns>Transform that performs the scaling operation</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Non-uniform scaling transformations" lang="VB.NET" source="Transform_07.vb">
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateScale(Snap.Position,System.Double)">
            <summary>Creates a transform that performs a (uniform) scaling operation</summary>
            <param name="basePoint">The basePoint for the scaling operation</param>
            <param name="scaleFactor">The scaling factor</param>
            <returns>Transform that performs the scaling operation</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Uniform scale transformations" lang="VB.NET" source="Transform_08.vb">
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateReflection(Snap.Geom.Surface.Plane)">
            <summary>Creates a transform that performs reflection through a given plane</summary>
            <param name="plane">The plane of reflection</param>
            <returns>Transform that performs the reflection</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Reflection transformations" lang="VB.NET" source="Transform_09.vb">
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.CreateReflection(Snap.Vector,System.Double)">
            <summary>Creates a transform that performs reflection through a given plane</summary>
            <param name="normal">The normal of the plane (unit vector)</param>
            <param name="d">Signed distance from origin to plane (plane equation is X*Normal = d)</param>
            <returns>Transform that performs the reflection</returns>
            <remarks>The transform can be applied to Positions, Vectors, and NX objects by calling the appropriate Move or Copy functions.</remarks>  
            <example> 
            The following example shows how to use this function: 
            <code title="Reflection transformations" lang="VB.NET" source="Transform_10.vb">
            </code>
            </example>      
            <seealso cref="O:Snap.NX.NXObject.Move">Snap.NX.NXObject.Move</seealso>
            <seealso cref="O:Snap.NX.NXObject.Copy">Snap.NX.NXObject.Copy</seealso>
            <seealso cref="O:Snap.Position.Move">Snap.Position.Move</seealso>
            <seealso cref="O:Snap.Position.Copy">Snap.Position.Copy</seealso>
            <seealso cref="O:Snap.Vector.Move">Snap.Vector.Move</seealso>
            <seealso cref="O:Snap.Vector.Copy">Snap.Vector.Copy</seealso>
        </member>
        <member name="M:Snap.Geom.Transform.Composition(Snap.Geom.Transform,Snap.Geom.Transform)">
            <summary>Forms the composition of two transforms (one followed by the other)</summary>
            <param name="xform1">First transform</param>
            <param name="xform2">Second transform</param>
            <returns>Composition of two transforms (first one followed by second one)</returns>
            <remarks>
            <para>
            The order of the transforms matters. Composition(xform1, xform2) is not the
            </para>
            same as Composition(xform2, xform1) 
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Composition of transformations" lang="VB.NET" source="Transform_11.vb">
            </code>
            </example>      
        </member>
        <member name="P:Snap.Geom.Transform.Matrix">
            <summary>Array of 12 doubles (the matrix elements)</summary>
            <remarks>
            <para>
            The matrix is an array of 12 doubles. 
            Applying the transform works as follows:
            </para>
            <para>
            <c>&#160;&#160;&#160;   xnew = x*m[0] + y*m[1] + z*m[2]   + m[3]</c><br/>
            <c>&#160;&#160;&#160;   ynew = x*m[4] + y*m[5] + z*m[6]   + m[7]</c><br/>
            <c>&#160;&#160;&#160;   znew = x*m[8] + y*m[9] + z*m[10]  + m[11]</c><br/>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Orientation">
            <summary>
            Represents an orientation in 3D space  (interchangeable with <see cref="T:NXOpen.Matrix3x3">NXOpen.Matrix3x3</see>)
            </summary>
            <remarks>
            <para>
            An orientation can be regarded either as a 3 &#215; 3 orthogonal matrix, or
            as a set of three orthogonal unit vectors.
            </para>
            <para>
            An orientation is a temporary non-persistent object that does not get stored in
            any NX part file. If you want to create a permanent object, you should
            use a <see cref= "T:Snap.NX.Matrix">Snap.NX.Matrix</see> object, instead.
            </para>
            </remarks>
            <example>
            The following example shows how to use the orientation class: 
            <code title="Orientations" lang="VB.NET" source="Orientation_01.vb"> 
            </code> 
            </example>   
        </member>
        <member name="P:Snap.Orientation.Identity">
            <summary>Returns the identity Orientation</summary>
        </member>
        <member name="P:Snap.Orientation.AxisX">
            <summary>The X-axis of the orientation (unit vector)</summary>  
        </member>
        <member name="P:Snap.Orientation.AxisY">
            <summary>The Y-axis of the orientation (unit vector)</summary>  
        </member>
        <member name="P:Snap.Orientation.AxisZ">
            <summary>The Z-axis of the orientation (unit vector)</summary>  
        </member>
        <member name="P:Snap.Orientation.Array">
            <summary>
            The array representation of the orientation
            </summary>
            <remarks>
            <para>
            The array elements are organized as follows:
            </para>
            <para>
            &#xA0;&#xA0;&#xA0; array[0,0] = axisX.X &#xA0;&#xA0; ; &#xA0;&#xA0; array[0,1] = axisX.Y &#xA0;&#xA0; ; &#xA0;&#xA0; array[0,2] = axisX.Z 
            </para>
            <para>
            &#xA0;&#xA0;&#xA0; array[1,0] = axisY.X &#xA0;&#xA0; ; &#xA0;&#xA0; array[1,1] = axisY.Y &#xA0;&#xA0; ; &#xA0;&#xA0; array[1,2] = axisY.Z 
            </para>
            <para>
            &#xA0;&#xA0;&#xA0; array[2,0] = axisZ.X &#xA0;&#xA0; ; &#xA0;&#xA0; array[2,1] = axisZ.Y &#xA0;&#xA0; ; &#xA0;&#xA0; array[2,2] = axisZ.Z 
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Orientation.#ctor">
            <summary>Constructor for the identity Orientation</summary>      
        </member>
        <member name="M:Snap.Orientation.#ctor(Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Constructor, given three orthogonal unit vectors</summary>
            <param name="axisX">Unit vector to be used as X-axis</param>
            <param name="axisY">Unit vector to be used as Y-axis</param>
            <param name="axisZ">Unit vector to be used as Z-axis</param>
            <remarks>The three vectors should be orthonormal (unit length
            <para>
            </para>
            and mutually perpendicular). This function does not check this.
            </remarks>
        </member>
        <member name="M:Snap.Orientation.#ctor(Snap.Vector,Snap.Vector)">
            <summary>Constructor, given X and Y axes</summary>
            <param name="axisX">The X-axis vector</param>
            <param name="axisY">The Y-axis vector</param>
            <remarks>
            <para>
            </para>
            <para>
            The input X-axis vector does not have to be a unit vector.       
            </para>
            <para>
            The input Y-axis vector does not have be a unit vector, and 
            it does not have to be perpendicular to the X-axis. It just has to
            be in the correct plane and on the correct "side" of the X-axis.
            </para> 
            </remarks>      
        </member>
        <member name="M:Snap.Orientation.#ctor(Snap.Vector)">
            <summary>Constructor, given a Z-axis vector</summary>
            <param name="axisZ">Vector to be used as the Z-axis of the orientation (length doesn't matter)</param>
            <returns>Orientation having the given vector as its Z-axis</returns>
            <remarks>
            <para>
            The X and Y axes are constructed arbitrarily, so use this constructor only
            when you don't care about these other axes.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.Orientation.#ctor(NXOpen.Matrix3x3)">
            <summary>Constructor, given an NXOpen.Matrix3x3 object</summary>
            <param name="matrix">An NXOpen.Matrix3x3 object</param>      
        </member>
        <member name="M:Snap.Orientation.op_Implicit(NXOpen.Matrix3x3)~Snap.Orientation">
            <summary>Implicit conversion from NXOpen.Matrix3x3 to Orientation</summary>
            <param name="matrix">The NXOpen.Matrix3x3 object to be converted</param>
            <returns>New Snap.Orientation created from the input NXOpen.Matrix3x3</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Orientation.op_Implicit(Snap.Orientation)~NXOpen.Matrix3x3">
            <summary>Implicit conversion from Orientation to NXOpen.Matrix3x3</summary>
            <param name="matrix">The Snap.Orientation object to be converted</param>
            <returns>New NXOpen.Matrix3x3 created from the input Snap.Orientation</returns>    
            <exclude/>
        </member>
        <member name="T:Snap.Position">
            <summary>
            Represents a position in 3D space (interchangeable with <see cref="T:NXOpen.Point3d">NXOpen.Point3d</see>)
            </summary>
            <remarks>
            <para>
            Provides functions for creating positions, and for operations
            like sum, difference, and scalar multiplication using the 
            normal arithmetic (in-fix) notation. 
            </para>
            <para>
            The concept is similar to the NX Point3d object, but
            the implementation here provides more capability.
            </para>
            </remarks>    
            <example> 
            The following example shows how to use the Position class: 
            <code title="Use the Position class" lang="VB.NET" source="Position_01.vb"> 
            </code> 
            </example>   
        </member>
        <member name="F:Snap.Position.X">
            <summary>The x-coordinate of the position</summary>
        </member>
        <member name="F:Snap.Position.Y">
            <summary>The y-coordinate of the position</summary>
        </member>
        <member name="F:Snap.Position.Z">
            <summary>The z-coordinate of the position</summary>
        </member>
        <member name="F:Snap.Position.Origin">
            <summary>A position corresponding to the origin -- (0,0,0)</summary>
        </member>
        <member name="P:Snap.Position.Array">
            <summary>Array of the coordinates of the position</summary>
        </member>
        <member name="P:Snap.Position.PolarTheta">
            <summary>The polar angle "theta" -- angle of rotation in the XY-plane</summary>
            <remarks>
            <para>
            The function returns Math.Atan2(y, x) * 180/Math.PI. 
            So, the returned angle is always between -180 and 180.
            See the .NET documentation for Math.Atan2 for further details.
            </para>
            <para>
            The <see cref="T:Snap.Vector">Snap.Vector</see> class has a similar property,
            and its description includes an explanatory picture.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Position.PolarPhi">
            <summary>The polar angle "phi" -- the angle between the position and the XY-plane</summary>
            <remarks>
            <para>
            The function returns <c>Snap.Math.Atan2( Sqrt(x*x + y*y), z)</c>. 
            So, the returned angle is always between -180 and 180.
            See the .NET documentation for Math.Atan2 for further details.
            </para>
            <para>
            The <see cref="T:Snap.Vector">Snap.Vector</see> class has a similar property,
            and its description includes an explanatory picture.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Position.op_Implicit(System.Double[])~Snap.Position">
            <summary>Conversion of double array to Position</summary>
            <param name="doubleArray">Array of three double coordinates</param>
            <returns>New position </returns>
            <exclude/>
        </member>
        <member name="M:Snap.Position.op_Implicit(System.Int32[])~Snap.Position">
            <summary>Conversion of Integer array to Position</summary>
            <param name="intArray">Array of three integer coordinates</param>
            <returns>New position </returns>
            <exclude/>
        </member>
        <member name="M:Snap.Position.op_Implicit(NXOpen.Point3d)~Snap.Position">
            <summary>Implicit conversion of NXOpen.Point3d to Position</summary>
            <param name="pt">The NXOpen.Point3d to be converted</param>
            <returns>The corresponding Position object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Position.op_Implicit(Snap.Position)~NXOpen.Point3d">
            <summary>Implicit conversion of Position to NXOpen.Point3d</summary>
            <param name="p">The position to be converted</param>
            <returns>The corresponding NXOpen.Point3d object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Position.op_Explicit(Snap.Vector)~Snap.Position">
            <summary>Explicit conversion of Vector to Position</summary>
            <param name="v">Vector to be converted</param>
            <returns>New Position created from Vector</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Position.op_Explicit(Snap.Position)~Snap.Vector">
            <summary>Explicit conversion of Position to Vector</summary>
            <param name="p">Position to be converted</param>
            <returns>New Vector created from Position</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Position.op_Addition(Snap.Position,Snap.Position)">
            <summary>Adds two positions using the "+" notation</summary>
            <param name="p">First position</param>
            <param name="q">Second position</param>
            <returns>Sum of two positions: p + q</returns>
            <remarks>Not really legal. Present only to support convex combinations</remarks>
        </member>
        <member name="M:Snap.Position.op_Addition(Snap.Position,Snap.Vector)">
            <summary>Adds a position and a vector using the "+" notation</summary>
            <param name="p">Position</param>
            <param name="v">Vector</param>
            <returns>Sum of position and vector: p + v</returns>
        </member>
        <member name="M:Snap.Position.op_Subtraction(Snap.Position,Snap.Position)">
            <summary>Subtracts two positions using the "-" notation</summary>
            <param name="p">First position</param>
            <param name="q">Second position</param>
            <returns>Vector representing difference of two positions: p - q</returns> 
        </member>
        <member name="M:Snap.Position.op_Subtraction(Snap.Position,Snap.Vector)">
            <summary>Subtracts a vector from a position using the "-" notation</summary>
            <param name="p">Position</param>
            <param name="v">Vector</param>
            <returns>Position minus vector: p  - v</returns>
        </member>
        <member name="M:Snap.Position.op_UnaryNegation(Snap.Position)">
            <summary>Negates (reverses) a position using the "-" notation</summary>
            <param name="p">The position</param>
            <returns>Negative of the given position</returns>
        </member>
        <member name="M:Snap.Position.op_Multiply(System.Double,Snap.Position)">
            <summary>Multiplies a position by a scalar using "*" notation</summary>
            <param name="s">Scalar (double)</param>
            <param name="p">Position</param>
            <returns>Scalar multiple: s*p</returns>
        </member>
        <member name="M:Snap.Position.op_Multiply(System.Int32,Snap.Position)">
            <summary>Multiplies a position by a scalar using "*" notation</summary>
            <param name="s">Scalar (int)</param>
            <param name="p">Position</param>
            <returns>Scalar multiple: s*p</returns>
        </member>
        <member name="M:Snap.Position.op_Division(Snap.Position,System.Double)">
            <summary>Divides a position by a scalar using "/" notation</summary>
            <param name="p">Position</param>
            <param name="s">Scalar (double)</param>
            <returns>Scalar multiple: p/s</returns>   
        </member>
        <member name="M:Snap.Position.#ctor(System.Double,System.Double,System.Double)">
            <summary>Creates a position from three rectangular coordinates</summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>      
        </member>
        <member name="M:Snap.Position.#ctor(System.Double,System.Double)">
            <summary>Creates a position from x and y coordinates (z assumed = 0)</summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>      
        </member>
        <member name="M:Snap.Position.#ctor(System.Double[])">
            <summary>Creates a position from an array of three coordinates</summary>
            <param name="coords">Array of three coordinates</param>      
        </member>
        <member name="M:Snap.Position.#ctor(Snap.NX.Point)">
            <summary>Creates a position from an NX.Point object</summary>
            <param name="pt">An NX.Point object (or an NXOpen.Point)</param>      
        </member>
        <member name="M:Snap.Position.#ctor(NXOpen.Point)">
            <summary>Creates a position from an NXOpen.Point object</summary>
            <param name="pt">An NXOpen.Point object</param>      
        </member>
        <member name="M:Snap.Position.#ctor(NXOpen.Point3d)">
            <summary>Creates a position from an NXOpen.Point3d object</summary>
            <param name="pt">An NXOpen.Point3d object</param>      
        </member>
        <member name="M:Snap.Position.ToString">
            <summary>Produces a string representation of a Position object</summary>
            <returns>String in the form (X, Y, Z)</returns>
            <remarks>
            <para>
            The string representation is in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. 
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Position.ToString(System.String)">
            <summary>Produces a string representation of a Position object using a given format</summary>
            <param name="format">A numeric format specifier</param>
            <returns>String in the form (X, Y, Z)</returns> 
            <remarks>
            <para>
            The X, Y, Z coordinates are converted to strings using the given format
            and the standard .NET Double.ToString function. This means that the string
            depends on your Windows "culture" settings. In particular, the decimal point might be represented
            by either a period or a comma, depending on your settings.
            </para>
            </remarks>
            <example> 
            The following example shows how to represent a Position object with given formats: 
            <code title="Represent a Position object with given formats" lang="VB.NET" source="Position_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Position.Distance2(Snap.Position,Snap.Position)">
            <summary>Calculates the squared distance between two positions</summary>
            <param name="p">First position</param>
            <param name="q">Second position</param>
            <returns>Square of distance between the positions</returns>
            <remarks>
            <para>
            Calculating squared distance does not require a square root operation,
            </para>
            so it is sometimes useful for performance reasons.
            </remarks>
            <example> 
            The following example shows how to calculate the squared distance between two positions: 
            <code title="Calculates squared distance" lang="VB.NET" source="Position_02.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Position.Distance(Snap.Position,Snap.Position)">
            <summary>Calculates the distance between two positions</summary>
            <param name="p">First position</param>
            <param name="q">Second position</param>
            <returns>Distance between the positions</returns>
            <remarks>
            <para>
            </para>
            Calculating squared distance is faster, which is sometimes significant.
            </remarks>
            <example> 
            The following example shows how to calculate the distance between two positions: 
            <code title="Calculate distance" lang="VB.NET" source="Position_02.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Position.GetX(Snap.Position[])">
            <summary>Generates an array of X-coordinates from an array of positions</summary>
            <param name="positions">Array of positions p0, p1, ..., pn</param>
            <returns>Array of X-coordinates p0.X, p1.X, ... , pn.X</returns>         
        </member>
        <member name="M:Snap.Position.GetX(Snap.Position[0:,0:])">
            <summary>Generates a 2D array of X-coordinates from a 2D array of positions</summary>
            <param name="positions">Array of positions p00, p01, ..., pmn</param>
            <returns>Array of coordinates p00.X, p01.X, ... , pmn.X</returns>      
        </member>
        <member name="M:Snap.Position.GetY(Snap.Position[])">
            <summary>Generates an array of Y-coordinates from an array of positions</summary>
            <param name="positions">Array of vectors p0, p1, ..., pn</param>
            <returns>Array of Y-coordinates p0.Y, p1.Y, ... , pn.Y</returns>      
        </member>
        <member name="M:Snap.Position.GetY(Snap.Position[0:,0:])">
            <summary>Generates a 2D array of Y-coordinates from a 2D array of positions</summary>
            <param name="positions">Array of positions p00, p01, ..., pmn</param>
            <returns>Array of Y-coordinates p00.Y, p01.Y, ... , pmn.Y</returns>      
        </member>
        <member name="M:Snap.Position.GetZ(Snap.Position[])">
            <summary>Generates an array of Z-coordinates from an array of positions</summary>
            <param name="positions">Array of positions p0, p1, ..., pn</param>
            <returns>Array of Z-coordinates p0.Z, p1.Z, ... , pn.Z</returns>      
        </member>
        <member name="M:Snap.Position.GetZ(Snap.Position[0:,0:])">
            <summary>Generates a 2D array of Z-coordinates from a 2D array of positions</summary>
            <param name="positions">Array of positions p00, p01, ..., pmn</param>
            <returns>Array of coordinates p00.Z, p01.Z, ... , pmn.Z</returns>      
        </member>
        <member name="M:Snap.Position.GetXYZ(Snap.Position[])">
            <summary>Generates an array of XYZ coordinates from an array of positions</summary>
            <param name="positions">Array of positions p0, p1, ..., pn</param>
            <returns>Array of coordinates p0.X, p0.Y, p0.Z, p1.X, p1.Y, p1.Z, ... , pn.Z</returns>     
        </member>
        <member name="M:Snap.Position.PositionsFromCoordinates(System.Double[])">
            <summary>Builds an array of positions from an array of coordinates</summary>
            <param name="coords">Array of coordinates x0, y0, z0, x1, y1, z1, ... , xn, yn, zn</param>
            <returns>Array of positions p0, p1, ..., pn, where pi = (xi, yi, zi)</returns>
            <remarks>
            <para>
            The function will construct as many positions as it can from the input array.
            One or two elements from the end of the input array will not be used, if its length is not exactly divisible by three.
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Positions from coordinates" lang="VB.NET" source="Position_03.vb"> 
            </code>
            </example>      
        </member>
        <member name="M:Snap.Position.PositionsFromCoordinates(System.Double[],System.Double[],System.Double[])">
            <summary>Builds an array of positions from three arrays of coordinates</summary>
            <param name="x">Array of x-coordinates x00, x01, ... , xmn</param>
            <param name="y">Array of y-coordinates y00, y01, ... , ymn</param>
            <param name="z">Array of z-coordinates z00, z01, ... , zmn</param>
            <returns>Array of positions p0, p1, ..., pn, where p[i] = ( x[i], y[i] z[i] )</returns>
            <remarks>The length of the output array will be equal to the minimum of the lengths of the three input arrays</remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Positions from coordinates" lang="VB.NET" source="Position_04.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Position.PositionsFromCoordinates(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Builds a 2D array of positions from three 2D arrays of coordinates</summary>
            <param name="x">2D array of x-coordinates x00, x01, ... , xmn</param>
            <param name="y">2D array of y-coordinates y00, y01, ... , ymn</param>
            <param name="z">2D array of z-coordinates z00, z01, ... , zmn</param>
            <returns>2D array of positions p00, p01, ..., pmn, where p[i,j] = ( x[i,j], y[i,j] z[i,j] )</returns>
            <remarks>In each dimension, the length of the output array will be the minimum of the lengths of the three input arrays</remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Positions from coordinates" lang="VB.NET" source="Position_05.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Position.Copy(Snap.Position[])">
            <summary>Copies a position array to another position array</summary>
            <param name="original">Original position array</param>
            <returns>A copy of the original input array of positions</returns> 
        </member>
        <member name="M:Snap.Position.Copy">
            <summary>Copies a position</summary>
            <returns>A copy of the original input position</returns>      
        </member>
        <member name="M:Snap.Position.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies a position</summary>
            <param name="xform">The transformation to apply</param>
            <returns>A transformed copy of the original input position</returns>      
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Position.Copy(Snap.Geom.Transform,Snap.Position[])">
            <summary>Transforms/copies an array of positions to another array of positions</summary>
            <param name="xform">The transformation to apply</param>
            <param name="original">Original array of positions</param>
            <returns>The array of transformed positions</returns>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Position.Move(Snap.Geom.Transform)">
            <summary>Transforms a position</summary>
            <param name="xform">The transformation to apply</param>
            <returns>A transformed version of the original input position</returns>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Position.Move(Snap.Geom.Transform,Snap.Position[])">
            <summary>Transforms an array of positions</summary>
            <param name="xform">The transformation to apply</param>
            <param name="original">Original position array</param>
            <returns>A transformed version of the original input array of positions</returns>      
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Position.Project(Snap.Geom.Surface.Plane)">
            <summary>Projects a position onto a plane (along the plane normal)</summary>
            <param name="plane">The plane onto which we want to project</param>
            <returns>The projected position</returns>
        </member>
        <member name="M:Snap.Position.Project(Snap.Geom.Curve.Ray)">
            <summary>Projects a position onto a ray (along a ray normal)</summary>
            <param name="ray">The ray onto which we want to project</param>
            <returns>The projected position</returns>
        </member>
        <member name="T:Snap.Vector">
            <summary>
            Represents a vector in 3D space (interchangeable with <see cref="T:NXOpen.Vector3d">NXOpen.Vector3d</see>)
            </summary>
            <remarks>
            <para>
            Provides functions for creating vectors, and for doing operations
            like sum, difference, and scalar multiplication using the 
            normal arithmetic (in-fix) notation. Also provides dot and cross 
            products, unitizing, and measuring angles.
            The concept is similar to the NX/Open Vector3d object, but
            the implementation here provides far more capability.
            </para>
            </remarks>
            <example> 
            The following example shows how to use the Vector class: 
            <code title="Using the Vector class" lang="VB.NET" source="Vector_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="F:Snap.Vector.X">
            <summary>The x-component (or coordinate) of the vector</summary>
        </member>
        <member name="F:Snap.Vector.Y">
            <summary>The y-component (or coordinate) of the vector</summary>
        </member>
        <member name="F:Snap.Vector.Z">
            <summary>The z-component (or coordinate) of the vector</summary>
        </member>
        <member name="P:Snap.Vector.Array">
            <summary>Array of the components of the vector</summary>
        </member>
        <member name="M:Snap.Vector.op_Addition(Snap.Vector,Snap.Vector)">
            <summary>Adds two vectors using the "+" notation</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>Sum of two vectors: u + v</returns> 
        </member>
        <member name="M:Snap.Vector.op_Subtraction(Snap.Vector,Snap.Vector)">
            <summary>Subtracts two vectors using the "-" notation</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>Difference of two vectors: u - v</returns> 
        </member>
        <member name="M:Snap.Vector.op_UnaryNegation(Snap.Vector)">
            <summary>Negates (reverses) a vector using the "-" notation</summary>
            <param name="u">The vector</param>
            <returns>Negative of the given vector</returns>
        </member>
        <member name="M:Snap.Vector.op_Multiply(System.Double,Snap.Vector)">
            <summary>Multiplies a vector by a scalar using "*" notation</summary>
            <param name="s">Scalar (double)</param>
            <param name="u">Vector</param>
            <returns>Scalar multiple: s*u</returns>
        </member>
        <member name="M:Snap.Vector.op_Multiply(System.Int32,Snap.Vector)">
            <summary>Multiplies a vector by a scalar using "*" notation</summary>
            <param name="s">Scalar (int)</param>
            <param name="u">Vector</param>
            <returns>Scalar multiple: s*u</returns>
        </member>
        <member name="M:Snap.Vector.op_Division(Snap.Vector,System.Double)">
            <summary>Divides a vector by a scalar using "/" notation</summary>
            <param name="u">Vector</param>
            <param name="s">Scalar (double)</param>
            <returns>Scalar multiple: u/s</returns>
            <remarks>
            <para>
            If s = 0, then each component of the returned vector will  
            be either Infinity, -Infinity, or NaN (not a number).
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Vector.op_Multiply(Snap.Vector,Snap.Vector)">
            <summary>Calculates the dot product (scalar product) of two vectors</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>Dot product: u*v</returns>
        </member>
        <member name="M:Snap.Vector.#ctor(System.Double,System.Double,System.Double)">
            <summary>Creates a vector from three rectangular coordinates</summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Snap.Vector.#ctor(System.Double,System.Double)">
            <summary>Creates a vector from x and y coordinates (z assumed = 0)</summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="M:Snap.Vector.#ctor(System.Double[])">
            <summary>Creates a vector from an array of three coordinates</summary>
            <param name="coords">Array of three coordinates</param>
        </member>
        <member name="M:Snap.Vector.#ctor(Snap.NX.Point)">
            <summary>Creates a vector from an NX.Point object</summary>
            <param name="pt">An NX.Point object (or an NXOpen.Point)</param>
        </member>
        <member name="M:Snap.Vector.#ctor(NXOpen.Point)">
            <summary>Creates a vector from an NXOpen.Point object</summary>
            <param name="pt">An NXOpen.Point object</param>
        </member>
        <member name="M:Snap.Vector.#ctor(NXOpen.Point3d)">
            <summary>Creates a vector from an NXOpen.Point3d object</summary>
            <param name="pt">An NXOpen.Point3d object</param>      
        </member>
        <member name="M:Snap.Vector.#ctor(NXOpen.Vector3d)">
            <summary>Creates a vector from an NXOpen.Vector3d object</summary>
            <param name="v">An NXOpen.Vector3d object</param>      
        </member>
        <member name="M:Snap.Vector.op_Implicit(System.Double[])~Snap.Vector">
            <summary>Conversion of double array to Vector</summary>
            <param name="doubleArray">Array of three double coordinates</param>
            <returns>New vector </returns>
            <exclude/>
        </member>
        <member name="M:Snap.Vector.op_Implicit(System.Int32[])~Snap.Vector">
            <summary>Conversion of Integer array to Vector</summary>
            <param name="intArray">Array of three integer coordinates</param>
            <returns>New vector </returns>
            <exclude/>
        </member>
        <member name="M:Snap.Vector.op_Explicit(Snap.Vector)~System.Double[]">
            <summary>Conversion of vector to array</summary>
            <param name="v">Vector</param>
            <returns>Array containing three coordinates</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Vector.op_Implicit(NXOpen.Vector3d)~Snap.Vector">
            <summary>Implicit conversion from NXOpen.Vector3d to Vector</summary>
            <param name="vec">The NXOpen.Vector3d object to be converted</param>
            <returns>New Vector created from the input Vector3d</returns>
            <exclude/>
        </member>
        <member name="M:Snap.Vector.op_Implicit(Snap.Vector)~NXOpen.Vector3d">
            <summary>Implicit conversion from Vector to NXOpen.Vector3d</summary>
            <param name="v">The Vector object to be converted</param>
            <returns>New NXOpen.Vector3d created from the input Vector</returns>    
            <exclude/>
        </member>
        <member name="M:Snap.Vector.ToString">
            <summary>Produces a string representation of a Vector object</summary>
            <returns>String in the form (X, Y, Z)</returns>
            <remarks>
            <para>
            The string representation is in either fixed-point or scientific
            (exponential) form, whichever is more compact, and with the decimal point
            represented by a period symbol. 
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Vector.ToString(System.String)">
            <summary>Produces a string representation of a Vector object using a given format</summary>
            <param name="format">A numeric format specifier</param>
            <returns>String in the form (X, Y, Z)</returns> 
            <remarks>
            <para>
            The X, Y, Z components are converted to strings using the given format
            and the standard .NET Double.ToString function. This means that the string
            depends on your Windows "culture" settings. In particular, the decimal point might be represented
            by either a period or a comma, depending on your settings.
            </para>
            </remarks>
            <example> 
            The following example shows how to represent a Vector object with given formats: 
            <code title="Represent a Vector object with given formats" lang="VB.NET" source="Vector_10.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Vector.Cross(Snap.Vector,Snap.Vector)">
            <summary>Calculates the cross product (vector product) of two vectors</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>Cross product</returns>
            <remarks>
            <para>
            As is well known, order matters: Cross(u,v) = - Cross(v,u)
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Calculate a cross product" lang="VB.NET" source="Vector_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Vector.UnitCross(Snap.Vector,Snap.Vector)">
            <summary>Calculates the unitized cross product (vector product) of two vectors</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>Unitized cross product</returns>
            <remarks>
            <para>
            If the cross product is the zero vector, then each component
            of the returned vector will be NaN (not a number).
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Calculate a unitized cross product" lang="VB.NET" source="Vector_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Vector.Unit(Snap.Vector)">
            <summary>Unitizes a given vector</summary>
            <param name="u">Vector to be unitized</param>
            <returns>Unit vector in same direction</returns>
            <remarks>
            <para>
            If the input is the zero vector is zero, then each component
            of the returned vector will be NaN (not a number).
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Unitize a vector" lang="VB.NET" source="Vector_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Vector.Norm2(Snap.Vector)">
            <summary>Calculates the norm squared (length squared) of a vector</summary>
            <param name="u">The vector</param>
            <returns>Norm (length) squared of vector</returns>
            <example> 
            The following example shows how to use this function: 
            <code title="Calculate the norm squared of a vector" lang="VB.NET" source="Vector_04.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Vector.Norm(Snap.Vector)">
            <summary>Calculates the norm (length) of a vector</summary>
            <param name="u">The vector</param>
            <returns>Norm (length) of vector</returns>
            <example> 
            The following example shows how to use this function: 
            <code title="Calculate the norm of a vector" lang="VB.NET" source="Vector_04.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Vector.Angle(Snap.Vector,Snap.Vector)">
            <summary>Calculates the angle in degrees between two vectors</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>The angle, theta, in degrees, where 0 &#8804; theta &#8804; 180</returns>
            <example> 
            The following example shows how to use this function: 
            <code title="Calculates the angle between two vectors" lang="VB.NET" source="Vector_05.vb"> 
            </code> 
            </example>      
        </member>
        <member name="F:Snap.Vector.AxisX">
            <summary>A unit vector in the direction of the X-axis -- (1,0,0)</summary>
        </member>
        <member name="F:Snap.Vector.AxisY">
            <summary>A unit vector in the direction of the Y-axis -- (0,1,0)</summary>
        </member>
        <member name="F:Snap.Vector.AxisZ">
            <summary>A unit vector in the direction of the Z-axis -- (0,0,1)</summary>
        </member>
        <member name="P:Snap.Vector.PolarTheta">
            <summary>The polar angle "theta" -- the angle of rotation in the XY-plane, in degrees</summary>
            <remarks>
            <para>
            The function returns Snap.Math.Atan2(y, x). 
            So, the returned angle is always between -180 and 180.
            See the .NET documentation for Math.Atan2 for further details.            
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Get the polar theta angle" lang="VB.NET" source="Vector_06.vb"> 
            </code> 
            <para>
            The following picture explains the polar angle theta of a vector: 
            </para>
            <img src="../Images/Vector.png"/>
            </example>
        </member>
        <member name="P:Snap.Vector.PolarPhi">
            <summary>The polar angle "phi" -- angle between the vector and the XY-plane, in degrees</summary>
            <remarks>
            <para>
            The function returns <c>Snap.Math.Atan2(Sqrt(x*x + y*y), z)</c>. 
            So, the returned angle is always between -180 and 180.
            See the .NET documentation for Math.Atan2 for further details.
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Get the polar phi angle" lang="VB.NET" source="Vector_06.vb"> 
            </code> 
            <para>
            The following picture explains the polar angle phi of a vector: 
            </para>
            <img src="../Images/Vector.png"/>
            </example>
        </member>
        <member name="M:Snap.Vector.Components(Snap.Vector,Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Calculates components with respect to three given basis vectors</summary>
            <param name="r">The vector whose components we want</param>
            <param name="u">First basis vector</param>
            <param name="v">Second basis vector</param>
            <param name="w">Third basis vector</param>
            <returns>The components of r with respect to the basis u, v, w</returns>
            <remarks>
            <para>
            The components are three numbers a, b, c such that:
            </para>
            <para><c>&#160;&#160;&#160;   r = a*u + b*v + c*w</c></para>
            </remarks>
            <example> 
            The following example shows how to calculate components 
            <code title="Calculating components" lang="VB.NET" source="Vector_11.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Vector.Components(Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Calculates components with respect to two given basis vectors</summary>
            <param name="r">The vector whose components we want</param>
            <param name="u">First basis vector</param>
            <param name="v">Second basis vector</param>
            <returns>The components of r with respect to the basis u, v, n (see remarks)</returns>
            <remarks>
            <para>
            The components are three numbers a, b, c, such that:
            </para>
            <para>
            <c>&#160;&#160;&#160;   r = a*u + b*v + c*n</c> 
            </para>
            <para>
            where n is a unit vector in the direction of u &#215; v.
            </para>
            <para>
            The vector a*u + b*v is the projection of the given vector r
            onto the plane containing u and v. 
            </para>
            <para>
            If r, u, v are coplanar, then r = a*u + b*v.
            </para>
            </remarks>
            <example> 
            The following example shows how to calculate components in 2D
            <code title="Calculating components in 2D" lang="VB.NET" source="Vector_12.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Vector.GetX(Snap.Vector[])">
            <summary>Generates an array of X-coordinates from an array of vectors</summary>
            <param name="vectors">Array of vectors v0, v1, ..., vn</param>
            <returns>Array of coordinates v0.X, v1.X, ... , vn.X</returns>      
        </member>
        <member name="M:Snap.Vector.GetX(Snap.Vector[0:,0:])">
            <summary>Generates a 2D array of X-coordinates from a 2D array of vectors</summary>
            <param name="vectors">Array of vectors v00, v01, ..., vmn</param>
            <returns>Array of coordinates v00.X, v01.X, ... , vmn.X</returns>      
        </member>
        <member name="M:Snap.Vector.GetY(Snap.Vector[])">
            <summary>Generates an array of Y-coordinates from an array of vectors</summary>
            <param name="vectors">Array of vectors v0, v1, ..., vn</param>
            <returns>Array of coordinates v0.Y, v1.Y, ... , vn.Y</returns>      
        </member>
        <member name="M:Snap.Vector.GetY(Snap.Vector[0:,0:])">
            <summary>Generates a 2D array of Y-coordinates from a 2D array of vectors</summary>
            <param name="vectors">Array of vectors v00, v01, ..., vmn</param>
            <returns>Array of coordinates v00.Y, v01.Y, ... , vmn.Y</returns>      
        </member>
        <member name="M:Snap.Vector.GetZ(Snap.Vector[])">
            <summary>Generates an array of Z-coordinates from an array of vectors</summary>
            <param name="vectors">Array of vectors v0, v1, ..., vn</param>
            <returns>Array of coordinates v0.Z, v1.Z, ... , vn.Z</returns>      
        </member>
        <member name="M:Snap.Vector.GetZ(Snap.Vector[0:,0:])">
            <summary>Generates a 2D array of Z-coordinates from a 2D array of vectors</summary>
            <param name="vectors">Array of vectors v00, v01, ..., vmn</param>
            <returns>Array of coordinates v00.Z, v01.Z, ... , vmn.Z</returns>      
        </member>
        <member name="M:Snap.Vector.GetXYZ(Snap.Vector[])">
            <summary>Generates an array of XYZ coordinates from an array of vectors</summary>
            <param name="vectors">Array of vectors v0, v1, ..., vn</param>
            <returns>Array of coordinates v0.X, v0.Y, v0.Z, v1.X, v1.Y, v1.Z, ... , vn.Z</returns>      
        </member>
        <member name="M:Snap.Vector.VectorsFromCoordinates(System.Double[])">
            <summary>Builds an array of vectors from an array of coordinates</summary>
            <param name="coords">Array of coordinates x0, y0, z0, x1, y1, z1, ... , xn, yn, zn</param>
            <returns>Array of vectors v0, v1, ..., vn, where vi = (xi, yi, zi)</returns>
            <remarks>
            <para>
            The function will construct as many vectors as it can from the input array.
            One or two elements from the end of the input array will not be used, if its length is not exactly divisible by three.
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Vectors from coordinates" lang="VB.NET" source="Vector_07.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Vector.VectorsFromCoordinates(System.Double[],System.Double[],System.Double[])">
            <summary>Builds an array of vectors from three arrays of coordinates</summary>
            <param name="x">Array of x-coordinates x0, x1, ... , xn</param>
            <param name="y">Array of y-coordinates y0, y1, ... , yn</param>
            <param name="z">Array of z-coordinates z0, z1, ... , zn</param>
            <returns>Array of vectors v0, v1, ..., vn, where v[i] = ( xi, yi, zi )</returns>
            <remarks>The length of the output array will be equal to the minimum of the lengths of the three input arrays</remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Vectors from coordinates" lang="VB.NET" source="Vector_08.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Vector.VectorsFromCoordinates(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Builds a 2D array of vectors from three 2D arrays of coordinates</summary>
            <param name="x">2D array of x-coordinates x00, x01, ... , xmn</param>
            <param name="y">2D array of y-coordinates y00, y01, ... , ymn</param>
            <param name="z">2D array of z-coordinates z00, z01, ... , zmn</param>
            <returns>2D array of vectors v00, v01, ..., vmn, where v[i,j] = ( x[i,j], y[i,j] z[i,j] )</returns>
            <remarks>In each dimension, the length of the output array will be the minimum of the lengths of the three input arrays</remarks>
            <example> 
            The following example shows how to use this function: 
            <code title="Vectors from coordinates" lang="VB.NET" source="Vector_09.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.Vector.Copy">
            <summary>Copies a vector</summary>
            <returns>A copy of the original input vector</returns>      
        </member>
        <member name="M:Snap.Vector.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies a vector</summary>
            <param name="xform">The transformation to apply</param>
            <returns>A transformed copy of the original input vector</returns>      
        </member>
        <member name="M:Snap.Vector.Move(Snap.Geom.Transform)">
            <summary>Transforms a vector</summary>
            <param name="xform">The transformation to apply</param>
            <returns>A transformed version of the original input vector</returns>      
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Vector.Copy(Snap.Vector[])">
            <summary>Copies a vector array to another vector array</summary>
            <param name="original">Original vector array</param>
            <returns>Vector array</returns>      
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Vector.Copy(Snap.Geom.Transform,Snap.Vector[])">
            <summary>Transforms/copies an array of vectors</summary>
            <param name="xform">The transformation to apply</param>
            <param name="original">Original vector array</param>
            <returns>A transformed copy of the original input array of vectors</returns>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Vector.Move(Snap.Geom.Transform,Snap.Vector[])">
            <summary>Transforms an array of vector</summary>
            <param name="xform">The transformation to apply</param>
            <param name="original">Original vector array</param>
            <returns>A transformed version of the original input array of vector</returns>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.Vector.Unitize">
            <summary>Unitizes a given vector</summary>
            <returns>Unit vector in same direction</returns>
            <remarks>
            <para>
            If the input is the zero vector, then each component
            of the returned vector will be NaN (not a number).
            </para>
            </remarks>      
        </member>
        <member name="T:Snap.ChebyshevPoles">
            <summary>
            Poles of constrained Chebyshev polynomials whose leading coefficients are 1. 
            </summary>
            <remarks>
            <para>
            These poles are useful for degree reduction.
            These are actually the leading coefficients of the
            Chebyshev polynomials defined on [-1,1]. To get the
            leading coefficients of polynomials on [0,1], divide 
            by (-2)^m. 
            </para>
            </remarks>
        </member>
        <member name="F:Snap.ChebyshevPoles.poles">
            <summary>
            The pole values (one dimensional)
            </summary>
        </member>
        <member name="T:Snap.Math">
            <summary>Mostly trigonometric functions that handle angles in degrees, rather than radians</summary>   
        </member>
        <member name="T:Snap.Math.LinearAlgebra">
            <summary>Performs simple linear algebra computations</summary>      
        </member>
        <member name="T:Snap.Math.LinearAlgebra.EigenSystemResult">
            <summary>Represents the results of an eigenvalue/eigenvector calculation</summary>
        </member>
        <member name="P:Snap.Math.LinearAlgebra.EigenSystemResult.Eigenvalue">
            <summary>An eigenvalue</summary>
        </member>
        <member name="P:Snap.Math.LinearAlgebra.EigenSystemResult.Eigenvector">
            <summary>The corresponding eigenvector</summary>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.EigenSystem(System.Double[0:,0:])">
            <summary>
            Computes the eigensystem (eigenvalues and eigenvectors) of a matrix
            </summary>
            <param name="A">The matrix</param>
            <returns>Array of results (pairs of eigenvalue and eigenvector)</returns>
            <remarks>
            <para>
            The matrix must be square (obviously). This is not checked.
            </para>
            <para>
            Currently, this function works only if the input matrix is 3 &#215; 3 and symmetric.
            This makes it useful for moment of inertia calculations, but not much else.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.EigenSolver3.ComputeRoots(System.Double[0:,0:],System.Double[])">
            <summary>Compute the eigenvalues of a given 3x3 symmetric matrix</summary>
            <param name="A">The matrix (assumed symmetric)</param>
            <param name="root">The eigenvalues, in increasing order</param>
            <remarks>
            <para>
            The eigenvalues are the roots of the characteristic equation.
            Since the matrix is 3 &#215; 3, this equation is cubic.
            Since the matrix is symmetric, the eigenvalues are guaranteed to all be real.
            Since the matrix is positive semi-definite, the eigenvalues are guaranteed to be positive.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.EigenSolver3.IsPositiveRank(System.Double[0:,0:],System.Double@,Snap.Vector@)">
            <summary>Determine if a matrix has positive rank</summary>
            <param name="M">The matrix</param>
            <param name="maxEntry">The matrix entry with maximum magnitude</param>
            <param name="maxRow">The row of the matrix in which the maximum-magnitude entry resides</param>
            <returns>True if the matrix has positive rank</returns>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.LUDecomposition(System.Double[0:,0:],System.Int32[],System.Double)">
            <summary>Modifies a square matrix to LU decomposition form</summary>
            <param name="a">Square matrix (input and output) -- modified upon output</param>
            <param name="index">Permutation info, for use by back substitution</param>
            <param name="d">Even/odd indicator. Used to calculate determinant.</param>
            <remarks>
            <para>
            Given a square matrix <c>a[0..n-1][0..n-1]</c>, this routine replaces it by 
            the LU decomposition of a row-wise permutation of itself. 
            </para>
            <para>
            The output <c>index[0..n-1]</c> records the row permutation 
            effected by the partial pivoting. 
            </para>
            <para>
            This function is used in combination with BackSubstitution to solve 
            linear equations or to invert a matrix.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input matrix is singular.</exception>            
        </member>
        <member name="M:Snap.Math.LinearAlgebra.BackSubstitution(System.Double[0:,0:],System.Int32[],System.Double[])">
            <summary>Performs "back substitution" to solve a linear system, given an LU decomposition</summary>
            <param name="a">An LU decomposition of matrix a, as produced by LUDecomposition</param>
            <param name="index">Permutation vector produced by LUDecomposition</param>
            <param name="b">On input, the right-hand side. On output, the solution vector</param>
            <remarks>
            <para>
            This function solves a set of n linear equations a.x = b.
            </para>
            <para>
            The coefficient matrix a[0..n-1][0..n-1] must be input in LU decomposition form, 
            as output from the functions LUDecomposition. 
            </para>
            <para>
            The permutation vector index[0..n-1] is also obtained from the function LUDecomposition. 
            </para>
            <para>
            The vector b[0..n-1] is used for both input and output. On input, it contains the 
            right-hand side of the set of equations, and on output, it contains the
            solution vector.
            </para>
            <para>
            The variables a and index are not modified by this function, so you can re-use them
            in successive calls with different values of the right-hand side b.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.BackSolve(System.Double[0:,0:],System.Int32[],System.Double[])">
            <summary>Performs "back substitution" to solve a linear system, given an LU decomposition</summary>
            <param name="a">An LU decomposition of matrix a, as produced by LUDecomposition</param>
            <param name="index">Permutation vector produced by LUDecomposition</param>
            <param name="b">The right-hand side vector</param>
            <returns>The solution vector</returns>
            <remarks>
            <para>
            This function solves a set of n linear equations a.x = b.
            </para>
            <para>
            The coefficient matrix a[0..n-1][0..n-1] must be input in LU decomposition form, 
            as output from the functions LUDecomposition. 
            </para>
            <para>
            The permutation vector index[0..n-1] is also obtained from the function LUDecomposition. 
            </para>
            <para>
            The variables a and index are not modified by this function, so you can re-use them
            in successive calls with different values of the right-hand side b.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.LinearSystemSolve(System.Double[0:,0:],System.Double[])">
            <summary>Solves the linear system of equations a*x = b</summary>
            <param name="a">Coefficient matrix, of size n &#215; n.</param>
            <param name="b">Right-hand-side vector, of length n.</param>
            <returns>Solution vector, again of length n</returns>
            <remarks>
            <para>
            In more detail, with k = n-1, the system solved is:
            </para>
            <para>
            <img src="../Images/LinearSystem.png"/>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.LinearSystemSolve(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Solves a system of two linear equations</summary>
            <param name="a">Coefficient of x in the first equation</param>
            <param name="b">Coefficient of y in the first equation</param>
            <param name="c">Coefficient of x in the second equation</param>
            <param name="d">Coefficient of y in the second equation</param>
            <param name="h">Constant term (on right-hand side) in first equation</param>
            <param name="k">Constant term (on right-hand side) in second equation</param>
            <returns>Solutions for x and y</returns>
            <remarks>
            <para>
            The system solved is:
            </para>
            <para>
            <c>&#160;&#160;&#160;   a*x + b*y = h</c><br/>
            <c>&#160;&#160;&#160;   c*x + d*y = k</c>
            </para>
            <para>
            If <c>a*d - b*c = 0</c>, no exception will be raised, but
            each of the solutions returned will be either 
            <see cref = "F:System.Double.PositiveInfinity">Double.PositiveInfinity</see> or
            <see cref = "F:System.Double.NegativeInfinity">Double.NegativeInfinity</see>.
            </para>
            </remarks>
            <example> 
            The following example shows how to solve two linear equations 
            <code title="Solving two linear equations" lang="VB.NET" source="LinearSolve_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.LinearSystemSolve(Snap.Vector,Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Solves a system of three linear equations in vector form</summary>
            <param name="r">The right-hand side vector</param>
            <param name="u">First reference vector</param>
            <param name="v">Second reference vector</param>
            <param name="w">Third reference vector</param>
            <returns>The components of r with respect to the basis u, v, w</returns>
            <remarks>
            <para>
            From an algebraic point of view, this function
            simply solves a system of three equations in three unknowns. It finds
            numbers x, y, z such that:
            </para>
            <para><c>&#160;&#160;&#160;   x*u + y*v + z*w = r</c></para>
            <para>
            From a geometric point of view, the solution
            gives the components of the vector r with respect to the basis
            vectors u, v, w (which are not necessarily orthonormal).
            </para>
            </remarks>
            <example> 
            The following example shows how to solve vector equations 
            <code title="Solving vector equations" lang="VB.NET" source="LinearSolve_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.Inverse(System.Double[0:,0:])">
            <summary>Computes the inverse of a square matrix a</summary>
            <param name="a">The matrix (not modified by this function)</param>
            <returns>The inverse</returns>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.Determinant3(System.Double[0:,0:])">
            <summary>
            Calculates the determinant of a 3 &#215; 3 matrix
            </summary>
            <param name="u">The matrix</param>
            <returns>The determinant of the given matrix</returns>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.Adjugate3(System.Double[0:,0:])">
            <summary>
            Calculates the adjugate matrix of a 3&#215;3 matrix
            </summary>
            <param name="a">The matrix</param>
            <returns>The adjugate matrix</returns>
        </member>
        <member name="M:Snap.Math.LinearAlgebra.Inverse3(System.Double[0:,0:])">
            <summary>
            Calculates the inverse of a 3 &#215; 3 matrix
            </summary>
            <param name="a">Input matrix</param>
            <returns>Inverse matrix</returns>
            <remarks>
            <para>
            Will raise an exception if the input matrix is singular (has determinant = 0)
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Math.MatrixMath">
            <summary>Provides simple manipulations of general matrices and vectors</summary>      
        </member>
        <member name="M:Snap.Math.MatrixMath.RowCount(System.Double[0:,0:])">
            <summary>Return the number of rows in a given matrix of doubles</summary>
            <param name="a">The matrix</param>
            <returns>Number of rows</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.RowCount(Snap.Vector[0:,0:])">
            <summary>Return the number of rows in a given matrix of Vectors</summary>
            <param name="a">The matrix</param>
            <returns>Number of rows</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.RowCount(Snap.Position[0:,0:])">
            <summary>Return the number of rows in a given matrix of Positions</summary>
            <param name="a">The matrix</param>
            <returns>Number of rows</returns>
        </member>
        <member name="M:Snap.Math.MatrixMath.ColumnCount(System.Double[0:,0:])">
            <summary>Return the number of columns in a given matrix of doubles</summary>
            <param name="a">The matrix</param>
            <returns>Number of columns</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.ColumnCount(Snap.Vector[0:,0:])">
            <summary>Return the number of columns in a given matrix of Vectors</summary>
            <param name="a">The matrix</param>
            <returns>Number of columns</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.ColumnCount(Snap.Position[0:,0:])">
            <summary>Return the number of columns in a given matrix of Positions</summary>
            <param name="a">The matrix</param>
            <returns>Number of columns</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.GetRow(System.Double[0:,0:],System.Int32)">
            <summary>Obtain a row from a matrix of doubles</summary>
            <param name="a">The matrix</param>
            <param name="i">Index of row required (zero-based)</param>
            <returns>The requested row</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.GetRow(Snap.Vector[0:,0:],System.Int32)">
            <summary>Obtain a row from a matrix of Vectors</summary>
            <param name="a">The matrix</param>
            <param name="i">Index of row required (zero-based)</param>
            <returns>The requested row</returns>             
        </member>
        <member name="M:Snap.Math.MatrixMath.GetRow(Snap.Position[0:,0:],System.Int32)">
            <summary>Obtain a row from a matrix of Positions</summary>
            <param name="a">The matrix</param>
            <param name="i">Index of row required (zero-based)</param>
            <returns>The requested row</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.GetColumn(System.Double[0:,0:],System.Int32)">
            <summary>Obtain a column from a matrix of doubles</summary>
            <param name="a">The matrix</param>
            <param name="j">Index of row required (zero-based)</param>
            <returns>The requested column</returns>            
        </member>
        <member name="M:Snap.Math.MatrixMath.GetColumn(Snap.Vector[0:,0:],System.Int32)">
            <summary>Obtain a column from a matrix of Vectors</summary>
            <param name="a">The matrix</param>
            <param name="j">Index of row required (zero-based)</param>
            <returns>The requested column</returns>             
        </member>
        <member name="M:Snap.Math.MatrixMath.GetColumn(Snap.Position[0:,0:],System.Int32)">
            <summary>Obtain a column from a matrix of Positions</summary>
            <param name="a">The matrix</param>
            <param name="j">Index of row required (zero-based)</param>
            <returns>The requested column</returns>             
        </member>
        <member name="M:Snap.Math.MatrixMath.Copy(System.Double[])">
            <summary>Copies an array of doubles</summary>
            <param name="original">Original array</param>
            <returns>New array with elements equal to input</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Copy(System.Double[0:,0:])">
            <summary>Copies a 2-D array of doubles</summary>
            <param name="original">Original array</param>
            <returns>New array with elements equal to input</returns>                 
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Multiply two general matrices of doubles</summary>
            <param name="a">Matrix of size m &#215; n</param>
            <param name="b">Matrix of size n &#215; p</param>
            <returns>Product matrix, of size m &#215; p</returns>
            <remarks>
            <para>
            Does not check that the two matrices are of compatible sizes
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function : 
            <code title="Multiply two general matrices " lang="VB.NET" source="MatrixMath_01.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Add two general matrices of doubles</summary>
            <param name="a">Matrix of size m &#215; n</param>
            <param name="b">Matrix of same size m &#215; n</param>
            <returns>Sum matrix, also of size m &#215; n</returns>
            <remarks>
            <para>
            Does not check that the two matrices are of compatible sizes
            </para>
            </remarks> 
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(System.Double[0:,0:],System.Double[])">
            <summary>Multiplies a matrix of doubles times a vector of doubles</summary>
            <param name="a">Matrix of size m &#215; n</param>
            <param name="b">Vector of length n</param>
            <returns>Product = a*b (in that order); a vector of length m</returns>
            <remarks>
            <para>
            Does not check that the inputs are of compatible sizes
            </para>
            </remarks>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(System.Double[],System.Double[])">
            <summary>Calculates the dot product of two arrays of doubles</summary>
            <param name="u">First array (of length n)</param>
            <param name="v">Second array (of same length, n)</param>
            <returns>Dot product</returns>
            <remarks>
            <para>
            Does not check that the two input arrays have the same length
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function : 
            <code title="Dot product of two arrays " lang="VB.NET" source="MatrixMath_02.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(System.Double[],Snap.Vector[])">
            <summary>Calculates the dot product of array of doubles and array of Vectors</summary>
            <param name="u">Array of doubles (of length n)</param>
            <param name="v">Array of Vectors (of same length, n)</param>
            <returns>Dot product</returns>
            <remarks>
            <para>
            Does not check that the arrays have the same length
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function : 
            <code title="Dot product of arrays " lang="VB.NET" source="MatrixMath_03.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(Snap.Vector[],System.Double[])">
            <summary>Calculates the dot product of array of doubles and array of Vectors</summary>
            <param name="u">Array of Vectors (of length n)</param>
            <param name="v">Array of doubles (of same length, n)</param>
            <returns>Dot product</returns>
            <remarks>
            <para>
            Does not check that the arrays have the same length
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function : 
            <code title="Dot product of arrays " lang="VB.NET" source="MatrixMath_03.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(System.Double[0:,0:],Snap.Vector[0:,0:])">
            <summary>Calculates the product of matrix of doubles and matrix of Vectors</summary>
            <param name="a">Matrix of doubles (of size m &#215; n)</param>
            <param name="b">Matrix of Vectors (of size n &#215; p)</param>
            <returns>Product matrix -- a matrix of Vectors of size m &#215; p</returns>
            <remarks>
            <para>
            Does not check that the input matrices have compatible sizes
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function : 
            <code title="Matrix-vector product " lang="VB.NET" source="MatrixMath_04.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(Snap.Vector[0:,0:],System.Double[0:,0:])">
            <summary>Calculates the product of matrix of doubles and matrix of Vectors</summary>
            <param name="a">Matrix of Vectors (of size m &#215; n)</param>
            <param name="b">Matrix of doubles (of size n &#215; p)</param>
            <returns>Product matrix -- a matrix of Vectors of size m &#215; p</returns>
            <remarks>
            <para>
            Does not check that the input matrices have compatible sizes
            </para>
            </remarks>
            <example> 
            The following example shows how to use this function : 
            <code title="Matrix-vector product " lang="VB.NET" source="MatrixMath_04.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Multiply(System.Double[0:,0:],System.Double)">
            <summary>Multiplies a matrix by a scalar</summary>
            <param name="a">Matrix of doubles (of size m &#215; n)</param>
            <param name="s">Scalar</param>
            <returns>Product matrix</returns>
            <example> 
            The following example shows how to use this function : 
            <code title="Multiply a matrix by a scalar " lang="VB.NET" source="MatrixMath_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.Math.MatrixMath.ZeroMatrix(System.Int32)">
            <summary>Returns a square zero matrix of size n</summary>
            <param name="n">Required size, n</param>
            <returns>Zero matrix of size n &#215; n</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.IdentityMatrix(System.Int32)">
            <summary>Returns an identity matrix of size n</summary>
            <param name="n">Required size, n</param>
            <returns>Identity matrix of size n &#215; n</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Transpose(System.Double[0:,0:])">
            <summary>Transposes a given matrix of doubles</summary>
            <param name="a">Input matrix</param>
            <returns>Transpose</returns>
            <example> 
            The following example shows how to use this function : 
            <code title="Transpose a matrix " lang="VB.NET" source="MatrixMath_06.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.Transpose(Snap.Position[0:,0:])">
            <summary>Transposes a given matrix of positions</summary>
            <param name="a">Input matrix</param>
            <returns>Transpose</returns>
            <example> 
            The following example shows how to use this function : 
            <code title="Transpose a matrix" lang="VB.NET" source="MatrixMath_06.vb"> 
            </code> 
            </example>         
        </member>
        <member name="M:Snap.Math.MatrixMath.VectorToMatrix(System.Int32[],System.Int32,System.Int32)">
            <summary>Rearranges an Integer vector (1-D array) into a matrix (2-D array)</summary>
            <param name="vector">The vector</param>
            <param name="nrows">Number of rows in output matrix</param>
            <param name="ncols">Number of columns in output matrix</param>
            <returns>Matrix</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.VectorToMatrix(System.Double[],System.Int32,System.Int32)">
            <summary>Rearranges a Double vector (1-D array) into a matrix (2-D array)</summary>
            <param name="vector">The vector</param>
            <param name="nrows">Number of rows in output matrix</param>
            <param name="ncols">Number of columns in output matrix</param>
            <returns>Matrix</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.MatrixToVector(System.Int32[0:,0:])">
            <summary>Rearranges an Integer matrix (2-D array) into a vector (1-D array)</summary>
            <param name="matrix">Matrix</param>
            <returns>Vector</returns>         
        </member>
        <member name="M:Snap.Math.MatrixMath.MatrixToVector(System.Double[0:,0:])">
            <summary>Rearranges a Double matrix (2-D array) into a vector (1-D array)</summary>
            <param name="matrix">Matrix</param>
            <returns>Vector</returns>         
        </member>
        <member name="T:Snap.Math.DoubleFunction">
            <summary>A real-valued function, for use in root-finding</summary>
            <param name="data">Data item to be used in evaluation</param>
            <param name="x">Argument at which to evaluate</param>
            <returns>The function value f(x) at the given argument value</returns>
            <remarks>
            You use a DoubleFunction when finding roots using 
            the <see cref="M:Snap.Math.Roots.FindRealRoot(Snap.Math.DoubleFunction,System.Object,System.Double,System.Double,System.Double,System.Int32)">FindRealRoot</see> function.
            </remarks>
            <seealso cref="M:Snap.Math.Roots.FindRealRoot(Snap.Math.DoubleFunction,System.Object,System.Double,System.Double,System.Double,System.Int32)">FindRealRoot</seealso>
        </member>
        <member name="T:Snap.Math.Roots">
            <summary>Tools for finding roots (zeros) of real-valued functions</summary>      
        </member>
        <member name="M:Snap.Math.Roots.FindRealRoot(Snap.Math.DoubleFunction,System.Object,System.Double,System.Double,System.Double,System.Int32)">
            <summary>Finds a single real root of a given function f in an interval [x1, x2] </summary>
            <param name="f">The function whose root we want to find</param>
            <param name="data">Data to be passed to the function f</param>
            <param name="x1">Lower limit of interval</param>
            <param name="x2">Upper limit of interval</param>
            <param name="rootError">The desired accuracy of the root</param>
            <param name="maxIterations">Maximum number of iterations allowed (optional)</param>
            <returns>A root x with x1 &lt; x &lt; x2</returns>
            <remarks>
            <para>
            The function must have different signs at the end-points of the given interval.
            In other words, f(x1) and f(x2) must have different signs.
            If there are several roots in the interval [x1,x2], this function will find one of them,
            but we can't say which one.
            </para>
            <para>
            The returned root is guaranteed to differ from a true root by at most rootError.
            </para>
            <para>
            When calling this function, you can omit the maxIterations argument, in which case
            a value of 20 is used. Reasonable values are in the range 20 to 50. More iterations will be needed
            if the interval [x1, x2] is very wide or the specified rootError is very small. 
            If the algorithm doesn't converge within 100
            iterations, then it probably won't converge at all, which might mean that you 
            need to find a different way to express your problem.</para>
            </remarks>
             <example> 
            The following example uses the FindRealRoot function to find the parameter value
            where a curve has a certain given radius of curvature.
            <code title="Using FindRealRoot" lang="VB.NET" source="Roots_02.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">Function values f(x1) and f(x2) have the same sign</exception>
            <exception cref="T:System.InvalidOperationException">Maximum number of iterations exceeded</exception>
        </member>
        <member name="M:Snap.Math.Roots.Negate(System.Double,System.Double)">
            <summary>
            Returns a or -a, depending on whether a and b have same sign
            </summary>
            <param name="a">Value to be (possibly) negated</param>
            <param name="b">Value determining whether or not to negate</param>
            <returns>a or -a, depending on whether a and b have same or different sign</returns>
            <remarks>
            Returns a if a and b are either both non-negative or both negative. Returns -a otherwise.
            </remarks>
        </member>
        <member name="M:Snap.Math.Roots.FindRealRoots(System.Double,System.Double,System.Double)">
            <summary>Find the real roots of a quadratic equation a*x^2 + b*x + c = 0</summary>
            <param name="a">Coefficient of x^2</param>
            <param name="b">Coefficient of x</param>
            <param name="c">Constant term</param>
            <returns>The real roots</returns>
            <remarks>
            The returned array may have length zero, one, or two. 
            <para>
            One root will be returned only if the coefficient a is zero. In other cases, either zero
            or two roots will be returned. If the equation has two equal roots, then these will 
            be returned as two individual elements of the array.
            </para>
            <para>
            When two roots are returned, the first one will be less than or equal to the second one.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The coefficients a and b are both zero</exception>
        </member>
        <member name="M:Snap.Math.DegreesToRadians(System.Double)">
            <summary>Converts degrees to radians</summary>
            <param name="angle">An angle measured in degrees</param>
            <returns>The same angle measured in radians</returns>
        </member>
        <member name="M:Snap.Math.RadiansToDegrees(System.Double)">
            <summary>Converts radians to degrees</summary>
            <param name="angle">An angle measured in radians</param>
            <returns>The same angle measured in degrees</returns>
        </member>
        <member name="M:Snap.Math.SinD(System.Double)">
            <summary>
            Calculates the sine of an angle given in degrees
            </summary>
            <param name="angle">The angle, in degrees</param>
            <returns>The sine of the given angle</returns>
            <remarks>
            <para>
            To calculate the sine of an angle given in radians, use <see cref="M:System.Math.Sin(System.Double)">System.Math.Sin</see>
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.CosD(System.Double)">
            <summary>
            Calculates the cosine of an angle given in degrees
            </summary>
            <param name="angle">The angle, in degrees</param>
            <returns>The cosine of the given angle</returns>
            <remarks>
            <para>
            To calculate the cosine of an angle given in radians, use <see cref="M:System.Math.Cos(System.Double)">System.Math.Cos</see>
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.TanD(System.Double)">
            <summary>
            Calculates the tangent of an angle given in degrees
            </summary>
            <param name="angle">The angle, in degrees</param>
            <returns>The tangent of the given angle</returns>
            <remarks>
            <para>
            To calculate the tangent of an angle given in radians, use <see cref="M:System.Math.Tan(System.Double)">System.Math.Tan</see>
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.AsinD(System.Double)">
            <summary>
            Calculates the arcsine (in degrees) of a given number
            </summary>
            <param name="x">The given number, which must be in the range -1 &#8804; x &#8804; 1</param>
            <returns>An angle, theta, such that sin(theta) = x, and 0 &#8804; theta &#8804; 180</returns>
            <remarks>
            <para>
            To calculate the arcsine in radians of a given number, use <see cref="M:System.Math.Asin(System.Double)">System.Math.Asin</see>
            </para>
            <para>
            If x &lt; -1 or x &gt; 1, then the returned value is NaN (Not A Number)</para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.AcosD(System.Double)">
            <summary>
            Calculates the arccosine (in degrees) of a given number
            </summary>
            <param name="x">The given number, which must be in the range -1 &#8804; x &#8804; 1</param>
            <returns>An angle, theta, such that cos(theta) = x, and 0 &#8804; theta &#8804; 180</returns>
            <remarks>
            <para>
            To calculate the arccosine in radians of a given number, use <see cref="M:System.Math.Acos(System.Double)">System.Math.Acos</see>
            </para>
            <para>
            If x &lt; -1 or x &gt; 1, then the returned value is NaN (Not A Number)</para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.AtanD(System.Double)">
            <summary>
            Calculates the arctangent (in degrees) of a given number
            </summary>
            <param name="x">The given number, which must be in the range -1 &#8804; x &#8804; 1</param>
            <returns>An angle, theta, such that tan(theta) = x, and 0 &#8804; theta &#8804; 180</returns>
            <remarks>
            <para>
            To calculate the arctangent in radians of a given number, use <see cref="M:System.Math.Atan(System.Double)">System.Math.Atan</see>
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.Atan2D(System.Double,System.Double)">
            <summary>
            Calculates the arctangent (in degrees) of a ratio of two given numbers
            </summary>
            <param name="y">The first given number (which can be regarded as a y-coordinate in the plane)</param>
            <param name="x">The second given number (which can be regarded as an x-coordinate in the plane)</param>
            <returns>An angle, theta, such that tan(theta) = y/x, sign(theta) = sign(y), and -180 &#8804; theta &#8804; 180</returns>
            <remarks>
            <para>
            To obtain the same result in radians, use <see cref="M:System.Math.Atan2(System.Double,System.Double)">System.Math.Atan2</see>.
            </para>
            <para>
            For limiting cases where either x or y is zero, please see the standard documentation for <see cref="M:System.Math.Atan2(System.Double,System.Double)">System.Math.Atan2</see>.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.Math.MaxIndex(System.Double[])">
            <summary>Find the index of the maximum element in an array</summary>
            <param name="values">The array of values</param>
            <returns>The index of the largest value in the array</returns> 
            <remarks>
            <para>
            Note that "largest" means closest to plus-infinity, not furthest from zero.
            </para>
            <para>
            So, MaxIndex(-5, 1, 3) is 2, not 0.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.Max(System.Double[])">
            <summary>Find the maximum element in an array</summary>
            <param name="values">The array of values</param>
            <returns>The largest value in the array</returns>      
            <remarks>
            <para>
            Note that "largest" means closest to plus-infinity, not furthest from zero.
            </para>
            <para>
            So, Max(-5, 1, 3) is 3, not 5.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.MinIndex(System.Double[])">
            <summary>Find the index of the minimum element in an array</summary>
            <param name="values">The array of values</param>
            <returns>The index of the smallest value in the array</returns>      
            <remarks>
            <para>
            Note that "smallest" means closest to minus-infinity, not closest to zero.
            </para>
            <para>
            So, MinIndex(-5, 1, 3) is 0, not 1.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.Min(System.Double[])">
            <summary>Find the minimum element in an array</summary>
            <param name="values">The array of values</param>
            <returns>The smallest value in the array</returns>
            <remarks>
            <para>
            Note that "smallest" means closest to minus-infinity, not closest to zero.
            </para>
            <para>
            So, Min(-5, 1, 3) is -5, not 1.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.Mean(System.Double[])">
            <summary>Find the mean (average) of an array of values</summary>
            <param name="values">The array of values</param>
            <returns>The mean of the values in the array</returns>      
        </member>
        <member name="M:Snap.Math.Sum(System.Double[])">
            <summary>Find the sum of an array of values</summary>
            <param name="values">The array of values</param>
            <returns>The sum of the values in the array</returns>          
        </member>
        <member name="T:Snap.Math.SplineMath">
            <summary>Low-level tools for b-spline calculations</summary>      
        </member>
        <member name="M:Snap.Math.SplineMath.ChordalNodes(Snap.Position[])">
            <summary>Calculates nodes (parameter values for interpolation) based on chordal distances</summary>
            <param name="intPoints">Data points to be interpolated</param>
            <returns>Chordal distances, normalized to the range [0,1]</returns>
        </member>
        <member name="M:Snap.Math.SplineMath.CentripedalNodes(Snap.Position[])">
            <summary>Calculates nodes (parameter values for interpolation) based on the centripedal idea</summary>
            <param name="intPoints">Data points to be interpolated</param>
            <returns>Centripedal node values, normalized to the range [0,1]</returns>
            <remarks>
            <para>
            Using centripedal nodes, rather than chordal ones, sometimes gives curves with a "nicer" shape.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.ChordalNodesU(Snap.Position[0:,0:])">
            <summary>Calculates nodes (parameter values for interpolation) based on chordal distances</summary>
            <param name="intPoints">Data points to be interpolated</param>
            <returns>Chordal distances, normalized to the range [0,1]</returns>
        </member>
        <member name="M:Snap.Math.SplineMath.ChordalNodes(Snap.Position[0:,0:])">
            <summary>Calculates nodes (parameter values for interpolation) based on chordal distances</summary>
            <param name="intPoints">Two-dimensional grid of data points to be interpolated</param>
            <returns>Chordal distances, normalized to the range [0,1]</returns>
            <remarks>
            <para>
            If <c>nodes</c> denotes the array returned from this function, then <c>nodes(0)</c>
            is the array of nodes for the u-direction, and <c>nodes(1)</c> is the array
            of nodes for the v-direction.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.GrevilleKnots(System.Double[],System.Int32)">
            <summary>Calculates Greville knots based on given node values</summary>
            <param name="nodes">Node values</param>
            <param name="m">Degree of curve</param>
            <returns>Knot values</returns>
            <remarks>
            <para>
            Greville knots give good numerical stability, and also guarantee that the
            Schoenberg-Whitney condition is satisfied, so interpolation will work.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.BezierKnots(System.Int32)">
            <summary>Builds Bezier knot sequence for degree m (m+1 zeros and m+1 1's)</summary>
            <param name="m">Degree</param>
            <returns>Array of knot values</returns>
        </member>
        <member name="M:Snap.Math.SplineMath.BsplineInterpolation(System.Double[],System.Double[],System.Double[])">
            <summary>B-spline interpolation (1D -- real-valued)</summary>
            <param name="intValues">The n values to interpolate, q[0],...,q[n-1]</param>
            <param name="nodes">The n parameter values at which to interpolate, tau[0],...,tau[n-1]</param>
            <param name="knots">Knot sequence : n-k values t[0], ... , t[n+k-1]</param>
            <returns>The n "poles" (ordinate values) p[0],...,p[n-1] of the interpolating b-spline</returns>
            <remarks>
            <para>
             This function does 1-D (i.e. real-valued) interpolation. 
             To do 3D interpolation, you would have to call it three times -- for x, y, and z.
             However, it is much more efficient to call 
            <see cref= "M:Snap.Math.SplineMath.BsplineInterpolation(Snap.Position[],System.Double[],System.Double[])">the other BsplineInterpolation overload</see>, 
             which receives positions as input.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.BsplineInterpolation(Snap.Position[],System.Double[],System.Double[])">
            <summary>B-spline Interpolation (3D -- vector-valued)</summary>
            <param name="intPoints">n 3D points to interpolate, q[0],...,q[n-1]</param>
            <param name="nodes">n parameter values at which to interpolate, tau[0],...,tau[n-1]</param>
            <param name="knots">knot sequence : n+k values t[0], ... , t[n+k-1]</param>
            <returns>The n 3D poles p[0],...,p[n-1] of the interpolating b-spline curve</returns>
        </member>
        <member name="M:Snap.Math.SplineMath.ChebyshevInterpolation(Snap.Position[],Snap.Vector,Snap.Vector)">
            <summary>Bezier Chebyshev interpolation of points and end derivatives</summary>
            <param name="q">Points at Chebyshev zeros -- m-1 of them for a degree m curve</param>
            <param name="u">First derivative at t=0 (wrt a parameter that varies from 0 to 1)</param>
            <param name="v">First derivative at t=1 (wrt a parameter that varies from 0 to 1)</param>
            <returns>Poles of a degree m Bezier curve interpolating given points and end derivatives</returns>
        </member>
        <member name="M:Snap.Math.SplineMath.BasisMatrix(System.Double[],System.Int32,System.Double[])">
            <summary>Evaluates a matrix of basis function values</summary>
            <param name="knots">Knot sequence : n+k values t[0], ... , t[n+k-1]</param>
            <param name="k">Order of the b-spline</param>
            <param name="nodes">Parameter (n) values at which to evaluate, tau[0],...,tau[n-1]</param>
            <returns>Matrix (n x n) of basis function values, B(i,k)(nodes[j])</returns>
            <remarks>
            <para>
            There are n basis functions, numbered <c>B(0,k), B(1,k), ... , B(n-1,k)</c>.
            </para>
            <para>The i-th basis function B(i,k) is non-zero only for t[i] &lt; t &lt; t[i+k]</para>
            <para>In the matrix A : <c>A[j][i] = B(i,k)(tau[j])</c>  (i = 0,1,...,n-1 ; j = 0,1,...,n-1)</para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.EvaluateBasisFunction(System.Double[],System.Int32,System.Int32,System.Double)">
            <summary>Evaluates value of a b-spline basis function</summary>
            <param name="knots">Knot sequence : n+k values t[0], ... , t[n+k-1]</param>
            <param name="i">Index of basis function (see below)</param>
            <param name="k">Order of the b-spline</param>
            <param name="t">Parameter value at which to evaluate</param>
            <returns>Value of i-th basis function B(i,k)(t)</returns>
            <remarks>
            <para>
            There are n basis functions, numbered <c>B(0,k), B(1,k), ... , B(n-1,k)</c>.
            </para>
            <para>The i-th basis function B(i,k) is non-zero only for t[i] &lt; t &lt; t[i+k]</para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.EvaluateBasisFunction(System.Double[],System.Int32,System.Int32,System.Double,System.Int32)">
            <summary>
            Evaluates a b-spline basis function and/or optional derivatives
            </summary>
            <param name="knots">The knot sequence : n+k values t[0], ... , t[n+k-1]</param>
            <param name="i">Index of basis function (see below)</param>
            <param name="k">Order of the b-spline</param>
            <param name="tau">Parameter value at which to evaluate</param>        
            <param name="derivs">Number of derivatives requested (0 for position alone)</param>
            <returns>Position and derivatives</returns>
            <remarks>
            <para>
            </para>
            <para>Copied from h0916, which in turn came from deBoor's book.</para>
            <para>There are n basis functions, numbered <c>B(0,k), B(1,k), ... , B(n-1,k)</c>.</para>
            <para>The i-th basis function B(i,k) is non-zero only for t[i] &lt; tau &lt; t[i+k]</para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.FindSpan(System.Double[],System.Int32,System.Double)">
            <summary>
            Finds the knot vector span containing a given value
            </summary>
            <param name="knots">The knot sequence : n+k+1 values t[0], ... , t[n+k]</param>
            <param name="k">Order of the basis functions (k = m+1 = degree+1)</param>
            <param name="tau">Parameter value whose span we want to find</param>
            <returns>The span index; a number r such that t[r] &#8804; tau &lt; t[r+1]</returns>
            <remarks>
            <para>
            The span index r returned by this function is always in the range m &#8804; r &#8804; n.
            </para>
            <para>
            If tau &lt; t[m], we return m, so subsequent evaluations of a basis function at tau
            will actually be using the polynomial that agrees with this basis function 
            on the first span t[m] &#8804; t &lt; t[m+1].
            </para>
            <para>
            If tau &gt; t[n], we return n. So, subsequent evaluations of a basis function at tau
            will actually be using the polynomial that agrees with this basis function 
            on the last span t[n-1] &#8804; t &lt; t[n].
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.EvaluateBasisFunctions(System.Double[],System.Int32,System.Double,System.Int32)">
            <summary>
            Evaluates the k b-spline basis functions that are non-zero on a given span
            </summary>
            <param name="knots">The knot sequence : n+k+1 values t[0], ... , t[n+k]</param>
            <param name="k">Order of the basis functions (k = m+1 = degree+1)</param>
            <param name="tau">Parameter value at which to evaluate</param>        
            <param name="r">The span number: t[r] &#8804; tau &lt; t[r+1]</param>
            <returns>Values at tau of the k basis functions that are non-zero on the span t[r] &#8804; tau &lt; t[r+1]</returns>
            <remarks>
            <para>
            This is based on the function "BasisFuncs" in Tiller's book. Algorithm 2.2, page 70.
            </para>
            <para>
            There are k basis functions that are non-zero on the span where t[r] &#8804; tau &lt; t[r+1]. 
            In fact these basis functions are <c>B(r-m,k), B(r-m+1,k), ... , B(r,k)</c>,
            where <c>B(i,k)</c> is the basis function of order k that is non-zero on the interval
            t[i] &#8804; tau &lt; t[i+k]
            </para>
            <para>
            The span number r must lie in the range m &#8804; r &#8804; n.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.Math.SplineMath.EvaluateBasisFunctions(System.Double[],System.Int32,System.Double,System.Int32,System.Int32)">
            <summary>
            Calculates the value and derivatives of the k b-spline basis functions that are non-zero on a given span
            </summary>
            <param name="knots">The knot sequence : n+k+1 values t[0], ... , t[n+k]</param>
            <param name="order">Order of the basis functions (k = m+1 = degree+1)</param>
            <param name="tau">Parameter value at which to evaluate</param>  
            <param name="span">The span number r such that t[r] &#8804; tau &lt; t[r+1]</param>
            <param name="numDerivs">How many derivatives to compute. Set numDerivs = 0 for function values alone</param>
            <returns>Values at tau of the k basis functions that are non-zero there.</returns>
            <remarks>
            <para>
            This is based on the function "xxx" in Tiller's book. Algorithm 2.2, page 70.
            </para>
            <para>
            There are k basis functions that are non-zero on the span where t[r] &#8804; tau &lt; t[r+1]. 
            In fact these basis functions are <c>B(r-m,k), B(r-m+1,k), ... , B(r,k)</c>,
            where <c>B(i,k)</c> is the basis function of order k that is non-zero on the interval
            t[i] &#8804; tau &lt; t[i+k]
            </para>
            <para>
            The span number r must lie in the range m &#8804; r &#8804; n.
            </para>
            <para>
            derivs[i,j] is the i-th derivative of the j-th basis function
            </para>
            <para>
            If you don't know the span corresponding to the given tau value, you can get
            it by calling FindSpan.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Arc">
            <summary>
            Represents an NX arc/circle object (interchangeable with <see cref="T:NXOpen.Arc">NXOpen.Arc</see>)
            </summary>
            <remarks>
            <para>
            The following picture explains the properties of an NX.Arc object: 
            </para>
            <para>
            <img src="../Images/Arc.png"/>
            </para>
            <para>
            To create an NX.Arc object, use the <see cref="O:Snap.Create.Arc">Snap.Create.Arc</see> functions.
            </para> 
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Arc class:
            <code title="Properties of an NX.Arc object: " lang="VB.NET" source="Arc_08.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Arc">Snap.Create.Arc</seealso>   
            <seealso cref="O:Snap.Create.Circle">Snap.Create.Circle</seealso>
            <seealso cref="O:Snap.Create.Fillet">Snap.Create.Fillet</seealso>
            <seealso cref="O:Snap.NX.Arc.Divide">Snap.NX.Arc.Divide</seealso>
            <seealso cref="M:Snap.NX.Arc.Trim(System.Double,System.Double)">Snap.NX.Arc.Trim</seealso>
        </member>
        <member name="P:Snap.NX.Arc.NXOpenArc">
            <summary>The enclosed <see cref="T:NXOpen.Arc">NXOpen.Arc</see> object</summary>
        </member>
        <member name="P:Snap.NX.Arc.Geometry">
            <summary>The geometric data of the arc</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an arc" lang="VB.NET" source="GeomArc_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Arc.Radius">
            <summary>The radius of the arc</summary>
        </member>
        <member name="P:Snap.NX.Arc.Diameter">
            <summary>The diameter of the arc</summary>
        </member>
        <member name="P:Snap.NX.Arc.Center">
            <summary> The center of the arc (in absolute coordinates)</summary>
        </member>
        <member name="P:Snap.NX.Arc.AxisX">
            <summary>A unit vector along the X-axis of the arc (where angle = 0)</summary>
        </member>
        <member name="P:Snap.NX.Arc.AxisY">
            <summary>A unit vector along the Y-axis of the arc (where angle = 90)</summary>
        </member>
        <member name="P:Snap.NX.Arc.AxisZ">
            <summary>A unit vector along the Z-axis of the arc (normal to the plane of the arc)</summary>
            <remarks>
            <para>
            The vector AxisZ is the cross product AxisX * AxisY. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Arc.Orientation">
            <summary>The orientation of the arc</summary>
        </member>
        <member name="P:Snap.NX.Arc.Matrix">
            <summary>The matrix of the arc (an <see cref="T:NXOpen.NXMatrix">NXOpen.NXMatrix</see> object)</summary>
        </member>
        <member name="P:Snap.NX.Arc.StartAngle">
            <summary> The start angle of the arc (in degrees) </summary>
        </member>
        <member name="P:Snap.NX.Arc.EndAngle">
            <summary> The end angle of the arc (in degrees) </summary>
        </member>
        <member name="P:Snap.NX.Arc.Factor">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapValue = nxopenValue * Factor</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenValue = snapValue / Factor</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Arc.Prototype">
            <summary>
            Returns the prototype arc of this one (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if this arc is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Arc.#ctor(NXOpen.Arc)">
            <summary> Constructor, given an NXOpen.Arc object</summary>
            <param name="arc">An NXOpen.Arc object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Arc.op_Implicit(NXOpen.Arc)~Snap.NX.Arc">
            <summary>Implicit conversion of NXOpen.Arc to NX.Arc</summary>
            <param name="arc">The NXOpen.Arc to be converted (enclosed)</param>
            <returns>A new NX.Arc object enclosing the given NXOpen.Arc</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Arc.op_Implicit(Snap.NX.Arc)~NXOpen.Arc">
            <summary>Implicit conversion of NX.Arc to NXOpen.Arc</summary>
            <param name="arc">The NX.Arc to be converted</param>
            <returns>The NXOpen.Arc object enclosed by the given NX.Arc</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Arc.CreateArc(Snap.Position,Snap.Vector,Snap.Vector,System.Double,System.Double,System.Double)">
            <summary>Creates an NX.Arc from center, axes, radius, angles in degrees</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="radius">Radius</param>
            <param name="angle1">Start angle (in degrees)</param>
            <param name="angle2">End angle (in degrees)</param>
            <returns>An NX.Arc object</returns>
        </member>
        <member name="M:Snap.NX.Arc.CreateArcFillet(Snap.Position,Snap.Position,Snap.Position,System.Double)">
            <summary>Constructs a fillet arc from three points</summary>
            <param name="p0">First point</param>
            <param name="pa">Apex point</param>
            <param name="p1">Last point</param>
            <param name="radius">Radius</param>
            <returns>An NXOpen.Arc representing the fillet</returns>
            <remarks>
            <para>
            The fillet will be tangent to the lines p0-pa and pa-p1.
            Its angular span will we be less than 180 degrees.
            </para>
            </remarks>        
        </member>
        <member name="M:Snap.NX.Arc.CreateArcFillet(Snap.NX.Curve,Snap.NX.Curve,System.Double,Snap.Position,System.Boolean)">
            <summary>Creates a fillets with two given curves</summary>
            <param name="curve1">First curve for the fillet</param>
            <param name="curve2">Second curve for the fillet</param>
            <param name="radius">Radius of the fillet</param>
            <param name="center">Approximate fillet center expressed as absolute coordinates</param>
            <param name="doTrim">If true, indicates that the input curves should get trimmed by the fillet</param>
            <returns>An NX.Arc object</returns>
            <example> 
            This example shows how to create a fillet object: 
            <code title="Create a fillet object" lang="VB.NET" source="FilletArc_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Arc">Snap.NX.Arc</seealso>
        </member>
        <member name="M:Snap.NX.Arc.CreateArc(Snap.Position,Snap.Position,Snap.Position)">
            <summary>Creates an NX.Arc from three points</summary>
            <param name="startPoint">Start point</param>
            <param name="pointOn">Point that the arc passes through</param>
            <param name="endPoint">End point</param>
            <returns>An NX.Arc object</returns>
        </member>
        <member name="M:Snap.NX.Arc.Copy">
            <summary>Copies an NX.Arc (with a null transform)</summary>
            <returns>A copy of the input arc</returns>
            <remarks>
            <para>
            The new arc will be on the same layer as the original one.      
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Arc.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Arc</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Arc</returns>      
            <exception cref="T:System.ArgumentException">The transform would convert the arc to an ellipse. Please use Curve.Copy instead</exception>
        </member>
        <member name="M:Snap.NX.Arc.Copy(Snap.NX.Arc[])">
            <summary>Copies an array of NX.Arc objects (with no transform)</summary>
            <param name="original">Original NX.Arc array</param>
            <returns>A copy of the input arcs</returns>
            <remarks>
            <para>
            The new arcs will be on the same layers as the original ones.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Arc.Copy(Snap.Geom.Transform,Snap.NX.Arc[])">
            <summary>Transforms/copies an array of NX.Arc objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Arc array</param>
            <returns>A copy of the input arcs</returns>
            <exception cref="T:System.ArgumentException">The transform would convert the arc to an ellipse. Please use Curve.Copy instead</exception>
        </member>
        <member name="M:Snap.NX.Arc.Trim(System.Double,System.Double)">
            <summary>Trim an arc to a parameter interval</summary>
            <param name="lowerParam">The lower-limit parameter value</param>
            <param name="upperParam">The upper-limit parameter value</param>
            <example> 
            This example shows how to trim an arc:
            <code title="Trim an arc" lang="VB.NET" source="TrimCurve_02.vb">
            </code>
            </example>
            <seealso cref="O:Snap.NX.Arc.Divide">Snap.NX.Arc.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Arc.Divide(System.Double[])">
            <summary>Divide an arc at an array of parameter values</summary>
            <param name="parameters">The parameter values at which the arc should be divided</param>
            <returns>An array of <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> objects</returns>
            <remarks>The function will create new arcs by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Arc.Trim(System.Double,System.Double)">Snap.NX.Arc.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Arc.Divide(Snap.NX.ICurve,Snap.Position)">
            <summary>Divide an arc at an intersection with another curve</summary>
            <param name="boundingCurve">Bounding curve to be used to divide the given arc</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> objects</returns>
            <remarks>The function will create two new arcs by dividing the original one.</remarks>
            <example> 
            This example shows how to divide an arc: 
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_03.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Arc.Trim(System.Double,System.Double)">Snap.NX.Arc.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Arc.Divide(Snap.NX.Face,Snap.Position)">
            <summary>Divide an arc at an intersection with a given face</summary>
            <param name="face">A face to be used to divide the given arc</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> objects</returns>
            <remarks>The function will create two new arcs by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Arc.Trim(System.Double,System.Double)">Snap.NX.Arc.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Arc.Divide(Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Divide an arc at an intersection with a given plane</summary>
            <param name="geomPlane">A plane to be used to divide the given arc</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Arc">Snap.NX.Arc</see> objects</returns>
            <remarks>The function will create two new arcs by dividing the original one</remarks>
            <example> 
            This example shows how to divide an arc:
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_05.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Arc.Trim(System.Double,System.Double)">Snap.NX.Arc.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Arc.ArcArray(Snap.NX.Curve[])">
            To avoid having four identical copies of the same code
        </member>
        <member name="M:Snap.NX.Arc.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Arc tag to a Snap.NX.Arc</summary>
            <param name="nxopenArcTag">The tag of an NXOpen.Arc object to be converted</param>
            <returns>The Snap.NX.Arc object formed by wrapping the NXOpen.Arc having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Arc object</exception>
            <example> 
            This example shows how to convert an NXOpen.Arc tag to a Snap.NX.Arc:
            <code title="Convert an NXOpen.Arc tag to Snap.NX.Arc" lang="VB.NET" source="Arc_10.vb"> 
            </code>
            </example>
        </member>
        <member name="T:Snap.NX.Block">
            <summary>
            Represents a Snap.NX.Block feature (interchangeable with <see cref="T:NXOpen.Features.Block">NXOpen.Features.Block</see>)
            </summary>
            <remarks>
            <para>
            The following picture explains the properties of an NX.Block object: 
            </para>
            <para>
            <img src="../Images/Block.png"/>
            </para>
            <para>
            To create an NX.Block object, use the <see cref="O:Snap.Create.Block">Snap.Create.Block</see> functions.
            </para> 
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Block class:
            <code title="Properties of an NX.Block object: " lang="VB.NET" source="Block_05.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Block">Snap.Create.Block</seealso>
        </member>
        <member name="P:Snap.NX.Block.NXOpenBlock">
            <summary>The enclosed NXOpen.Features.Block object</summary>
        </member>
        <member name="P:Snap.NX.Block.Origin">
            <summary>The position of the origin point of the block</summary>
        </member>
        <member name="P:Snap.NX.Block.Length">
            <summary>The length of the block (length in the x-direction)</summary>
        </member>
        <member name="P:Snap.NX.Block.Width">
            <summary>The width of the block (length in the y-direction)</summary>
        </member>
        <member name="P:Snap.NX.Block.Height">
            <summary>The height of the block  (length in the z-direction)</summary>
        </member>
        <member name="P:Snap.NX.Block.BlockBuilder">
            <summary>The NXOpen.Features.BlockFeatureBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Block feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.BlockFeatureBuilder">NXOpen.Features.BlockFeatureBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Block.#ctor(NXOpen.Features.Block)">
            <summary> Constructor, given an NXOpen.Features.Block object</summary>
            <param name="block">An NXOpen.Features.Block object</param>
        </member>
        <member name="M:Snap.NX.Block.op_Implicit(NXOpen.Features.Block)~Snap.NX.Block">
            <summary> Implicit conversion of NXOpen.Features.Block to NX.block</summary>
            <param name="block"> An NXOpen.Features.block object</param>
            <returns>The corresponding NX.Block object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Block.op_Implicit(Snap.NX.Block)~NXOpen.Features.Block">
            <summary> Implicit conversion of NX.Block to NXOpen.Features.Block</summary>
            <param name="block"> AN NX.Block object</param>
            <returns>The enclosed NXOpen.Features.Block object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Block.CreateBlock(Snap.Position,Snap.Orientation,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates an NX.Block from origin, matrix, xLength, yLength, zLength</summary>
            <param name="origin">The corner-point of the block (in absolute coordinates</param>
            <param name="matrix">Orientation (see remarks)</param>
            <param name="xLength">Length in x-direction</param>
            <param name="yLength">Length in y-direction</param>
            <param name="zLength">Length in z-direction</param>        
            <returns>An NX.Block object</returns>
        </member>
        <member name="M:Snap.NX.Block.CreateBlock(Snap.Orientation,Snap.Position,Snap.Position,Snap.Number)">
            <summary>Creates an NX.Block with two points and height</summary>
            <param name="matrix">Orientation (see remarks)</param>
            <param name="originPoint">The origin-point of the block (in absolute coordinates</param>       
            <param name="cornerPoint">The corner-point of the block</param>        
            <param name="height">Height</param>
            <returns>An NX.Block object</returns>
        </member>
        <member name="M:Snap.NX.Block.CreateBlock(Snap.Orientation,Snap.Position,Snap.Position)">
            <summary>Creates an NX.Block from two diagonal points</summary>
            <param name="matrix">Orientation</param>
            <param name="originPoint">The origin-point of the block (in absolute coordinates</param>        
            <param name="cornerPoint">The corner-point of the block </param>                
            <returns>An NX.Block object</returns>
        </member>
        <member name="M:Snap.NX.Block.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Block tag to a Snap.NX.Block</summary>
            <param name="nxopenBlockTag">The tag of an NXOpen.Features.Block object to be converted</param>
            <returns>The Snap.NX.Block object formed by wrapping the NXOpen.Features.Block having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks> 
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Block object</exception>
        </member>
        <member name="T:Snap.NX.Body">
            <summary>
            Represents a Snap.NX.Body object (interchangeable with <see cref="T:NXOpen.Body">NXOpen.Body</see>)
            </summary>
            <remarks>
            <para>
            To find all the bodies in a part, use its <see cref="P:Snap.NX.Part.Bodies">Bodies</see> collection. 
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of an NX.Body object:
            <code title="Properties of an NX.Body object: " lang="VB.NET" source="Body_01.vb"> 
            </code> 
            The following picture shows the result of the example: 
            <para>
            <img src="../Images/Body.png"/>
            </para>
            </example>
            <seealso cref="P:Snap.NX.Part.Bodies">Snap.NX.Part.Bodies</seealso>
        </member>
        <member name="P:Snap.NX.Body.ObjectSubType">
            <summary>Subtypes of NX body</summary>
            <remarks>
            <para>
            The possible subtypes are
            <list type = "bullet">
            <item>BodyGeneral</item>     
            <item>BodySolid</item>  
            <item>BodySheet</item>
            </list>
            </para>
            </remarks>
            <seealso cref= "T:Snap.NX.ObjectTypes.SubType">Snap.NX.ObjectTypes.SubType</seealso>
        </member>
        <member name="M:Snap.NX.Body.GetBodySubType(Snap.NX.Body)">
            <summary>Factored-out method to get body subtype</summary>
            <param name="body">Body whose subtype we want</param>
            <returns>The subtype</returns>
        </member>
        <member name="P:Snap.NX.Body.Shells">
            <summary>The array of <see cref= "T:Snap.Topology.Shell">shells</see> in the body</summary>
            <example>
            This example shows how to get the shells in a body, their types,
            and the numbers of faces they contain:
            <code title="Getting body shells" lang="VB.NET" source="ShellType_01.vb"></code>
            </example>
            <seealso cref= "T:Snap.Topology.Shell">Snap.Topology.Shell</seealso>
            <seealso cref= "T:Snap.Topology.ShellType">Snap.Topology.ShellType</seealso>
        </member>
        <member name="P:Snap.NX.Body.Vertices">
            <summary>The array of vertices in the body</summary>
            <remarks>
            <para>
            If the body has no vertices (a spherical body, for example), 
            this property will return an array of length zero.
            </para>
            </remarks>    
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and gets its vertices. 
            <code title="Get the vertices of a body" lang="VB.NET" source="BodyVertices_01.vb">
            </code> 
            </example>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
            <seealso cref= "T:Snap.Topology.Vertex">Snap.Topology.Vertex</seealso>
        </member>
        <member name="M:Snap.NX.Body.ContainsPoint(Snap.Position)">
            <summary>
            Determine whether a given point is inside the body
            </summary>
            <param name="pt">The point to be tested</param>
            <returns>True if the given point lies inside (or on a face) of the body</returns>
            <example> 
            The following example creates a 
            sphere and checks whether points are contained inside it. 
            <code title="Testing point containment" lang="VB.NET" source="ContainsPoint_01.vb">
            </code> 
            </example>
            <seealso cref= "M:Snap.NX.Face.ContainsPoint(System.Double[])">Snap.NX.Face.ContainsPoint</seealso>
        </member>
        <member name="P:Snap.NX.Body.Edges">
            <summary>The array of <see cref= "T:Snap.NX.Edge">edges</see> in the body</summary>
            <remarks>
            <para>
            If the body has no edges (a spherical body, for example), 
            this property will return an array of length zero.
            </para>
            </remarks>
            <seealso cref= "T:Snap.NX.Edge">Snap.NX.Edge</seealso> 
        </member>
        <member name="P:Snap.NX.Body.Faces">
            <summary>The array of <see cref= "T:Snap.NX.Face">faces</see> in the body</summary>>
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and finds cylindrical faces. 
            <code title="Finding cylindrical faces" lang="VB.NET" source="BodyFaces_01.vb">
            </code> 
            </example>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
            <seealso cref= "T:Snap.NX.Face">Snap.NX.Face</seealso>
        </member>
        <member name="P:Snap.NX.Body.NXOpenBody">
            <summary>The enclosed NXOpen.Body object</summary>
        </member>
        <member name="P:Snap.NX.Body.PsTag">
            <summary>Get the Parasolid tag from this NX.Body</summary>
        </member>
        <member name="P:Snap.NX.Body.PsBody">
            <summary>Get the Parasolid body from this NX.Body</summary>
        </member>
        <member name="P:Snap.NX.Body.Box">
            <summary>The bounding box of the body</summary>        
        </member>
        <member name="P:Snap.NX.Body.Density">
            <summary>The density of the body</summary>        
            <remarks>
            <para>
            A sheet body is assumed to represent a thin-walled object, so its
            density is mass per unit area.
            </para>
            <para>
            If the part units are millimeters, the density units are gm/mm^3      
            for solid bodies, or gm/mm^2 for sheet bodies.
            </para>
            <para>
            If the part units are inches, the density units are lb/in^3
            for solid bodies, or lb/in^2 for sheet bodies.
            </para>
            </remarks>
            <seealso cref= "M:Snap.Compute.Mass(Snap.NX.Body[])">Snap.Compute.Mass</seealso>
        </member>
        <member name="P:Snap.NX.Body.IsSolidBody">
            <summary>If true, indicates that the body is a solid</summary>        
        </member>
        <member name="P:Snap.NX.Body.IsSheetBody">
            <summary>If true, indicates that the body is a sheet</summary>        
        </member>
        <member name="P:Snap.NX.Body.Prototype">
            <summary>
            Returns the prototype body of this body (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the body is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Body.#ctor(NXOpen.NXObject)">
            <summary>Constructor, given an NXOpen.NXObject object</summary>
            <param name="nxopenObject">An NXOpen.NXObject object</param>
        </member>
        <member name="M:Snap.NX.Body.#ctor(NXOpen.Tag)">
            <summary>Constructor, given an NXOpen.Tag object</summary>
            <param name="bodyTag">An NXOpen.Tag object</param>
        </member>
        <member name="M:Snap.NX.Body.#ctor(NXOpen.Features.Feature)">
            <summary>Constructor, given an NXOpen.Features.Feature object</summary>
            <param name="feature">An NXOpen.Features.Feature object</param>
        </member>
        <member name="M:Snap.NX.Body.op_Implicit(NXOpen.NXObject)~Snap.NX.Body">
            <summary>Implicit conversion from NXOpen.NXObject to NX.Body</summary>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Body.op_Implicit(Snap.NX.Body)~NXOpen.TaggedObject">
            <summary>Implicit conversion from NX.Body to NXOpen.TaggedObject</summary>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Body.op_Implicit(NXOpen.Body)~Snap.NX.Body">
            <summary>Implicit conversion from NXOpen.Body to NX.Body</summary>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Body.op_Implicit(Snap.NX.Body)~NXOpen.Body">
            <summary>Implicit conversion from NX.Body to NXOpen.Body</summary>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Body.Copy">
            <summary>Copies an NX.Body (with no transform)</summary>
            <returns>A copy of the input body</returns>
            <remarks>
            <para>
            The new body will be on the same layer as the original one. 
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Body.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Body</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Body</returns>
        </member>
        <member name="M:Snap.NX.Body.Copy(Snap.NX.Body[])">
            <summary>Copies an array of NX.Body objects (with no transform)</summary>
            <param name="original">Original NX.Body array</param>
            <returns>An array of copies of the input bodies</returns>
            <remarks>
            <para>
            The new bodies will be on the same layers as the original ones.
            </para>
            <para>
            The function will throw an NXOpen.NXException, if the copy operation cannot be performed.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Body.Copy(Snap.Geom.Transform,Snap.NX.Body[])">
            <summary>Transforms/copies an array of NX.Body objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Body array</param>
            <returns>A copy of the input bodies</returns>
            <remarks>The function will throw NXOpen.NXException, when the operation is not correct</remarks>            
        </member>
        <member name="M:Snap.NX.Body.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Body tag to a Snap.NX.Body</summary>
            <param name="nxopenBodyTag">The tag of an NXOpen.Body object to be converted</param>
            <returns>The Snap.NX.Body object formed by wrapping the NXOpen.Body having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Body object</exception>
        </member>
        <member name="T:Snap.NX.Boolean">
            <summary>
            Represents a Snap.NX.Boolean feature (interchangeable with <see cref="T:NXOpen.Features.BooleanFeature">NXOpen.Features.BooleanFeature</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Boolean object, use the Snap.Create.Unite, Snap.Create.Subtract, or Snap.Create.Intersect function.
            </para>
            </remarks>
            <example>
            This example shows how to use the properties of this class:
            <code title="Use the properties of this object: " lang="VB.NET" source="Boolean_03.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.Create.Intersect(Snap.NX.Body,Snap.NX.Body[])">Snap.Create.Intersect</seealso>   
            <seealso cref="M:Snap.Create.Subtract(Snap.NX.Body,Snap.NX.Body[])">Snap.Create.Subtract</seealso>   
            <seealso cref="M:Snap.Create.Unite(Snap.NX.Body,Snap.NX.Body[])">Snap.Create.Unite</seealso>   
        </member>
        <member name="P:Snap.NX.Boolean.NXOpenBooleanFeature">
            <summary>The enclosed NXOpen.Features.BooleanFeature object</summary>
        </member>
        <member name="P:Snap.NX.Boolean.BooleanBuilder">
            <summary>The NXOpen.Features.BooleanBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Boolean feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.BooleanBuilder">NXOpen.Features.BooleanBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Boolean.#ctor(NXOpen.Features.BooleanFeature)">
            <summary> Constructor, given an NXOpen.Features.BooleanFeature object</summary>
            <param name="boolean">An NXOpen.Features.BooleanFeature object</param>
        </member>
        <member name="M:Snap.NX.Boolean.op_Implicit(NXOpen.Features.BooleanFeature)~Snap.NX.Boolean">
            <summary> Implicit conversion of NXOpen.Features.BooleanFeature to NX.BooleanFeature</summary>
            <param name="boolean"> An NXOpen.Features.BooleanFeature object</param>
            <returns>The corresponding NX.BooleanFeature object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Boolean.op_Implicit(Snap.NX.Boolean)~NXOpen.Features.BooleanFeature">
            <summary> Implicit conversion of NX.BooleanFeature to NXOpen.Features.BooleanFeature</summary>
            <param name="boolean"> AN NX.BooleanFeature object</param>
            <returns>The enclosed NXOpen.Features.BooleanFeature object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Boolean.CreateBoolean(Snap.NX.Body,Snap.NX.Body[],NXOpen.Features.Feature.BooleanType)">
            <summary>
            Creates an NX.Boolean feature
            </summary>
            <param name="target">Target body</param>
            <param name="toolBodies">Array of tool bodies</param>
            <param name="booleanType">Type of boolean operation (unions, subtract, etc.)</param>
            <returns>NX.Boolean feature formed by operation</returns>
        </member>
        <member name="M:Snap.NX.Boolean.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.BooleanFeature tag to a Snap.NX.Boolean</summary>
            <param name="nxopenBooleanTag">The tag of an NXOpen.Features.BooleanFeature object to be converted</param>
            <returns>The Snap.NX.Boolean object formed by wrapping the NXOpen.Features.BooleanFeature having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.BooleanFeature object</exception>
        </member>
        <member name="T:Snap.NX.BoundedPlane">
            <summary>
            Represents a Snap.NX.BoundedPlane feature (interchangeable with <see cref="T:NXOpen.Features.BoundedPlane">NXOpen.Features.BoundedPlane</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.BoundedPlane object, use the <see cref="M:Snap.Create.BoundedPlane(Snap.NX.Curve[])">Snap.Create.BoundedPlane</see> functions. 
            </para>
            </remarks>
            <example> 
            This example shows how to create an example of this class:
            <code title="Create an example of this object: " lang="VB.NET" source="BoundedPlane_01.vb"> 
            </code> 
            The following picture shows the result of the example: 
            <para>
            <img src="../Images/BoundedPlane.png"/>
            </para>
            </example>
            <seealso cref="M:Snap.Create.BoundedPlane(Snap.NX.Curve[])">Snap.Create.BoundedPlane</seealso>      
        </member>
        <member name="P:Snap.NX.BoundedPlane.NXOpenBoundedPlane">
            <summary>The enclosed NXOpen.Features.BoundedPlane object</summary>
        </member>
        <member name="P:Snap.NX.BoundedPlane.BoundedPlaneBuilder">
            <summary>The NXOpen.Features.BooleanBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.BoundedPlane feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.BoundedPlaneBuilder">NXOpen.Features.BoundedPlaneBuilder</seealso>
        </member>
        <member name="M:Snap.NX.BoundedPlane.op_Implicit(NXOpen.Features.BoundedPlane)~Snap.NX.BoundedPlane">
            <summary> Implicit conversion of NXOpen.Features.BoundedPlane to NX.BoundedPlane</summary>
            <param name="boundedPlane"> An NXOpen.Features.BoundedPlane object</param>
            <returns>The corresponding NX.BoundedPlane object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.BoundedPlane.op_Implicit(Snap.NX.BoundedPlane)~NXOpen.Features.BoundedPlane">
            <summary> Implicit conversion of NX.BoundedPlane to NXOpen.Features.BoundedPlane</summary>
            <param name="boundedPlane"> AN NX.BoundedPlane object</param>
            <returns>The enclosed NXOpen.Features.BoundedPlane object</returns>
            <exclude/>        
        </member>
        <member name="M:Snap.NX.BoundedPlane.CreateBoundedPlane(Snap.NX.Curve[])">
            <summary>Creates a BoundedPlane object</summary>
            <param name="boundingCurves">The array of curves to be used as edges</param>      
            <returns> A <see cref="T:Snap.NX.BoundedPlane">Snap.NX.BoundedPlane</see> feature</returns>
        </member>
        <member name="M:Snap.NX.BoundedPlane.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.BoundedPlane tag to a Snap.NX.BoundedPlane</summary>
            <param name="nxopenBoundedPlaneTag">The tag of an NXOpen.Features.BoundedPlane object to be converted</param>
            <returns>The Snap.NX.BoundedPlane object formed by wrapping the NXOpen.Features.BoundedPlane having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.BoundedPlane object</exception>
        </member>
        <member name="T:Snap.NX.Bsurface">
            <summary>
            Represents a Snap.NX.Bsurface object, which is a body with a single face (interchangeable with <see cref="T:NXOpen.Body">NXOpen.Body</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Bsurface object, use the <see cref="O:Snap.Create.Bsurface">Snap.Create.Bsurface</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of this class:
            <code title="Use the properties of this object: " lang="VB.NET" source="Bsurface_05.vb"> 
            </code> 
            </example>   
            <seealso cref="O:Snap.Create.BezierPatch">Snap.Create.BezierPatch</seealso>
            <seealso cref="O:Snap.Create.BezierPatchThroughPoints">Snap.Create.BezierPatchThroughPoints</seealso>
            <seealso cref="O:Snap.Create.Bsurface">Snap.Create.Bsurface</seealso> 
            <seealso cref="O:Snap.Create.BsurfaceThroughPoints">Snap.Create.BsurfaceThroughPoints</seealso>
        </member>
        <member name="P:Snap.NX.Bsurface.Face">
            <summary>Gets the (one and only) NX.Face of the NX.Bsurface body</summary>
        </member>
        <member name="M:Snap.NX.Bsurface.#ctor(NXOpen.Body)">
            <summary>Constructor, given an NXOpen.Body object</summary>
            <param name="body">NXOpen.Body object</param>
        </member>
        <member name="M:Snap.NX.Bsurface.op_Implicit(NXOpen.Body)~Snap.NX.Bsurface">
            <summary> Implicit conversion of NXOpen.Body to NX.Bsurface</summary>
            <param name="body"> An NXOpen.Body</param>
            <returns> Corresponding NX.Bsurface</returns> 
            <exclude/>
        </member>
        <member name="M:Snap.NX.Bsurface.op_Implicit(Snap.NX.Bsurface)~NXOpen.Body">
            <summary> Implicit conversion of Body to NXOpen.Body</summary>
            <param name="body"> An NX.Body</param>
            <returns> Corresponding NXOpen.Body</returns> 
            <exclude/>
        </member>
        <member name="M:Snap.NX.Bsurface.CreateBsurface(Snap.Position[0:,0:],System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a rational b-surface from poles, weights, and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D poles</param>
            <param name="weights">A 2D array of nu x nv weights</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <returns>An NX.Bsurface object, which is a body with a single face</returns>
        </member>
        <member name="M:Snap.NX.Bsurface.CreateBsurface(Snap.Position[0:,0:],System.Double[],System.Double[])">
            <summary>Constructs a polynomial b-surface from poles and knot sequences</summary>
            <param name="poles">A 2D array of nu x nv 3D poles</param>
            <param name="knotsU">Knots for u-direction -- an array of nu+ku knot values : u[0], ... , u[nu+ku-1]</param>
            <param name="knotsV">Knots for v-direction -- an array of nv+kv knot values : v[0], ... , v[nv+kv-1]</param>
            <returns>An NX.Bsurface object, which is a body with a single face</returns>
        </member>
        <member name="T:Snap.NX.Category">
            <summary>Represents a layer category object (interchangeable with <see cref="T:NXOpen.Layer.Category">NXOpen.Layer.Category</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Category object, use the <see cref="M:Snap.Create.Category(System.String,System.String,System.Int32[])">Snap.Create.Category</see> function.
            </para>
            <para>
            To find all the categories in a part, use its <see cref="P:Snap.NX.Part.Categories">Categories</see> collection.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Category class:
            <code title="Properties of an NX.Category object: " lang="VB.NET" source="Category_02.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.Category(System.String,System.String,System.Int32[])">Snap.Create.Category</seealso>
            <seealso cref="P:Snap.NX.Part.Categories">Snap.NX.Part.Categories</seealso>
        </member>
        <member name="P:Snap.NX.Category.NXOpenCategory">
            <summary>The enclosed NXOpen.Layer.Category object</summary>
        </member>
        <member name="P:Snap.NX.Category.Name">
            <summary>The name of the layer category</summary>
        </member>
        <member name="P:Snap.NX.Category.Description">
            <summary>The description of the layer category</summary>
            <remarks>
            <para>
            The description string is shown in the Layer Settings dialog in NX.
            </para>
            <para>
            The maximum length of the description string is 80 characters.
            When setting this property, only the first 80 characters of the input
            string will be used, and the others will be ignored.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Category.Layers">
            <summary>The list of layers contained in the category</summary>
            <example> 
            The following example shows how to use the Layers list: 
            <code title="Using the Layers list" lang="VB.NET" source="Category_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Category.LayerMask">
            <summary>Layer mask indicating which layers belong to this category.</summary>
            <remarks> 
            <para>
            For n = 1,2, ..., 256, LayerMask(n) is true if layer number n belongs to the category.
            Layer(0) is unused. The layer mask provides a quick and easy way to check whether
            a given layer belongs to the category.
            </para>
            </remarks>
            <example> 
            This example shows how LayerMasks can be used to easily find out
            which categories contain a given layer:
            <code title="Using the LayerMask: " lang="VB.NET" source="Category_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Category.NXOpenTag">
            <summary>Get the NXOpen.Tag from this NX.Category</summary>
        </member>
        <member name="M:Snap.NX.Category.op_Implicit(NXOpen.Layer.Category)~Snap.NX.Category">
            <summary> Implicit conversion of NXOpen.Layer.Category to NX.Category</summary>
            <param name="category"> An NXOpen.Layer.Category object</param>
            <returns>The corresponding NX.Category object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Category.op_Implicit(Snap.NX.Category)~NXOpen.Layer.Category">
            <summary> Implicit conversion of NX.Category to NXOpen.Layer.Category</summary>
            <param name="category"> An NX.Category object</param>
            <returns>The corresponding NXOpen.Layer.Category object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Category.CreateCategory(System.String,System.String,System.Int32[])">
            <summary>Creates a layer category with a given name</summary>
            <param name="name">Name of layer category</param>
            <param name="description">Description of layer category</param>
            <param name="layers">Layers to be placed into the category</param>
            <returns>An NX.Category object </returns>
        </member>
        <member name="M:Snap.NX.Category.Remove(System.Int32[])">
            <summary>Remove layers from category</summary>
            <param name="layers">Array of layers to be removed</param>
            <returns>False if any of the input layers did not belong to the category</returns>
            <example> 
            The following example shows how to add and remove layers: 
            <code title="Adding and removing layers:" lang="VB.NET" source="Category_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Category.Add(System.Int32[])">
            <summary>Add layers into category</summary>
            <param name="layers">Array of layers to be added</param>
            <example> 
            The following example shows how to add and remove layers: 
            <code title="Adding and removing layers:" lang="VB.NET" source="Category_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Category.Delete">
            <summary>Delete this layer category</summary>
            <remarks>
            <para>
            If you apply this function to the special category named "ALL", then nothing
            will happen, because you are not allowed to delete this category.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Category.Delete(Snap.NX.Category[])">
            <summary>Deletes an array of layer categories</summary>
            <param name="categories">The categories to delete</param>
            <remarks>
            <para>
            If you pass the special category named "ALL" to this function, it will
            not be deleted, because you are not allowed to delete this category.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Category.FindByName(System.String)">
            <summary>Find the category in the work part that has a given name</summary>
            <param name="name">Name of the category</param>
            <returns>The NX.Category object having the given name, or <c>Nothing</c></returns>
            <remarks>
            <para>
            You can use this function to find out whether a category having a given name
            already exists. Specifically, if <c>FindByName("catName")</c> returns
             <c>Nothing</c>, then a category called "catName" does not yet exist.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.Category">Snap.NX.Category</seealso>
        </member>
        <member name="M:Snap.NX.Category.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Layer.Category tag to a Snap.NX.Category</summary>
            <param name="nxopenCategoryTag">The tag of an NXOpen.Layer.Category object to be converted</param>
            <returns>The Snap.NX.Category object formed by wrapping the NXOpen.Layer.Category having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Layer.Category object</exception>
        </member>
        <member name="T:Snap.NX.Chamfer">
            <summary>
            Represents a Snap.NX.Chamfer feature (interchangeable with <see cref="T:NXOpen.Features.Chamfer">NXOpen.Features.Chamfer</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Chamfer object, use the <see cref="O:Snap.Create.Chamfer">Snap.Create.Chamfer</see> functions.
            </para>
            </remarks>
            <example>
            This example shows how to create a chamfer object:
            <code title="Create a chamfer: " lang="VB.NET" source="Chamfer_04.vb">
            </code>
            </example>
            <seealso cref="O:Snap.Create.Chamfer">Snap.Create.Chamfer</seealso>
        </member>
        <member name="P:Snap.NX.Chamfer.NXOpenChamfer">
            <summary>The enclosed <see cref="T:NXOpen.Features.Chamfer">NXOpen.Features.Chamfer</see> object</summary>
        </member>
        <member name="P:Snap.NX.Chamfer.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature.Chamfer</summary>
        </member>
        <member name="P:Snap.NX.Chamfer.ChamferBuilder">
            <summary>The NXOpen.Features.ChamferBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Chamfer feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ChamferBuilder">NXOpen.Features.ChamferBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Chamfer.#ctor(NXOpen.Features.Chamfer)">
            <summary> Constructor, given an NXOpen.Features.Chamfer object</summary>
            <param name="chamfer">An NXOpen.Features.Chamfer object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Chamfer.op_Implicit(NXOpen.Features.Chamfer)~Snap.NX.Chamfer">
            <summary>Implicit conversion of NXOpen.Features.Chamfer to NX.Chamfer</summary>
            <param name="chamfer">The NXOpen.Features.Chamfer to be converted (enclosed)</param>
            <returns>A new NX.Chamfer object enclosing the given NXOpen.Features.Chamfer</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Chamfer.op_Implicit(Snap.NX.Chamfer)~NXOpen.Features.Chamfer">
            <summary>Implicit conversion of NX.Chamfer to NXOpen.Features.Chamfer</summary>
            <param name="chamfer">The NX.Chamfer to be converted</param>
            <returns>The NXOpen.Features.Chamfer object enclosed by the given NX.Chamfer</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Chamfer.CreateChamfer(Snap.NX.Edge,Snap.Number,System.Boolean)">
            <summary>Creates a Snap.NX.Chamfer feature</summary>
            <param name="edge">Edge used to chamfer</param>
            <param name="distance">Offset distance</param>
            <param name="offsetFaces">
            The offsetting method used to determine the size of the chamfer
            If true, the edges of the chamfer face will be constructed by offsetting the faces adjacent to the selected edge 
            If false, the edges of the chamfer face will be constructed by offsetting the selected edge along the adjacent faces  
            </param>
            <returns>An NX.Chamfer object</returns>
        </member>
        <member name="M:Snap.NX.Chamfer.CreateChamfer(Snap.NX.Edge,Snap.Number,Snap.Number,System.Boolean)">
            <summary>Creates a chamfer object</summary>
            <param name="edge">Edge used to chamfer</param>
            <param name="distance1">Offset distance1</param>
            <param name="distance2">Offset distance2</param>
            <param name="offsetFaces">
            The offsetting method used to determine the size of the chamfer
            If true, the edges of the chamfer face will be constructed by offsetting the faces adjacent to the selected edge 
            If false, the edges of the chamfer face will be constructed by offsetting the selected edge along the adjacent faces  
            </param>
            <returns>An NX.Chamfer object</returns>
        </member>
        <member name="M:Snap.NX.Chamfer.CreateChamfer(Snap.NX.Edge,Snap.Number,Snap.Number)">
            <summary>Creates a chamfer object</summary>
            <param name="edge">Edge used to chamfer</param>
            <param name="distance">Offset distance</param>
            <param name="angle">Offset angle</param>           
            <returns>An NX.Chamfer object</returns>
        </member>
        <member name="M:Snap.NX.Chamfer.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Chamfer tag to a Snap.NX.Chamfer</summary>
            <param name="nxopenChamferTag">The tag of an NXOpen.Features.Chamfer object to be converted</param>
            <returns>The Snap.NX.Chamfer object formed by wrapping the NXOpen.Features.Chamfer having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Chamfer object</exception>
        </member>
        <member name="T:Snap.NX.Component">
            <summary>
            Represents a Snap.NX.Component object (interchangeable with <see cref="T:NXOpen.Assemblies.Component">NXOpen.Assemblies.Component</see>)
            </summary>
            <remarks>
            <para>
            SNAP does not yet provide any functions for inserting new components into part files.
            The only thing you can do at present is read assembly/component information. 
            This is useful for writing reports of various kinds.
            </para>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly/component concepts.
            </para>
            </remarks>   
            <example>
            This example shows how to use some of the properties of the NX.Component class:
            <code title="Properties of an NX.Component object: " lang="VB.NET" source="Component_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Component.NXOpenComponent">
            <summary>The enclosed NXOpen.Assemblies.Component object</summary>
        </member>
        <member name="P:Snap.NX.Component.Box">
            <summary>The 3D box that encloses the component</summary>
            <remarks>
            <para>
            The box is computed by combining the boxes of the member objects of
            the component. If the component has no boxable members, then <c>Nothing</c>
            is returned.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Component.Members">
            <summary>An array containing all the member objects of this component</summary>
            <remarks>
            <para>
            The returned array contains all the objects in the component, possibly including some that
            SNAP knows nothing about.
            </para>
            <para>
            The members are all "occurrences". These are objects that are merely
            links to "real" objects that actually reside in subassemblies, rather than
            in the current part. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Component.Parent">
            <summary>The parent component of this component</summary>
            <remarks>
            <para>
            Components are arranged in a "tree" that represents the hierarchical
            structure of an assembly. Within this tree, the components one level 
            down from the current one are known as its "children", and the component 
            one level up is known as its "parent". 
            </para>
            <para>
            If the current component has no parent (because it is a root node,
            then this property will have the value <c>Nothing</c>.
            </para>
            <para>
            You can determine that a component is a root node by using its
            <see cref= "P:Snap.NX.Component.IsRoot">IsRoot</see> property.</para>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to these concepts.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Component.Children">
            <summary>The child components of this component</summary>
            <remarks>
            <para>
            Components are arranged in a "tree" that represents the hierarchical
            structure of an assembly. Within this tree, the components one level 
            down from the current one are known as its "children", and the component 
            one level up is known as its "parent". 
            </para>
            <para>
            If the current component has no children (because it is a leaf node),
            the returned array will have length zero.
            </para>      
            <para>
            Note that this property does not return non-geometric components (NGCs) 
            unless the environment variable UGII_ALLOW_NGC_IN_UGOPEN is set to YES.
            </para>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to these concepts.
            </para>
            <para>
            By using the Children property, you can recursively cycle through all the
            nodes in a tree of components. The example program below shows you how to do this.
            However, in many situations, you will find that cycling through tree nodes
            is much easier if you use the
            <see cref= "P:Snap.NX.Component.Descendants">Descendants</see> collection or the
            <see cref= "P:Snap.NX.Component.Leaves">Leaves</see> collection.
            </para>
            </remarks>
            <example> 
            The following example shows you how to perform some operation 
            on each node of a tree by using a recursive function. 
            <code title="Recursive traversal" lang="VB.NET" source="Component_06.vb"> 
            </code> 
            </example> 
            <seealso cref= "P:Snap.NX.Component.Descendants">Snap.NX.Component.Descendants</seealso>
            <seealso cref= "P:Snap.NX.Component.Leaves">Snap.NX.Component.Leaves</seealso>
        </member>
        <member name="P:Snap.NX.Component.IsLeaf">
            <summary>
            If True, indicates that this component is a "leaf" node
            </summary>
            <remarks>
            <para>
            A "leaf" component is one that's at the lowest level of the 
            component tree, so it has no children.
            </para>
            <para>
            You can find all the leaf nodes beneath a given component by using the
            <see cref= "P:Snap.NX.Component.Leaves">Leaves</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.Component.Leaves">Snap.NX.Component.Leaves</seealso>
        </member>
        <member name="P:Snap.NX.Component.IsRoot">
            <summary>
            If True, indicates that this component is a "root" node
            </summary>
            <remarks>
            <para>
            A "root" component is one that's at the highest level of the 
            component tree, so it has no parent. A root component is somewhat
            artificial. It's main purpose is to serve as a convenient starting
            point for algorithms that want to walk downwards through the component tree.
            </para>
            <para>
            You can obtain the root component in any given part by using its 
            <see cref= "P:Snap.NX.Part.RootComponent">RootComponent</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.Part.RootComponent">Snap.NX.Part.RootComponent</seealso> 
        </member>
        <member name="P:Snap.NX.Component.Descendants">
            <summary>
            Returns an enumerable collection containing the component itself,
            children, grandchildren, and all other descendents.
            </summary>
            <remarks>
            <para>
            You can cycle through the Descendants using a "For Each" loop.
            </para>
            </remarks>
            <example> 
            The following example shows how to cycle through descendants: 
            <code title="Cycling through descendants" lang="VB.NET" source="Component_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Component.Leaves">
            <summary>
            Returns an enumerable collection containing all the "leaf" node 
            components descended from this component.
            </summary>
            <remarks>
            <para>
            A "leaf" node is a component that has no children. Leaf nodes are sometimes 
            known as "piece parts", though this terminology is somewhat misleading.
            </para>
            <para>
            You can cycle through the Leaves collection using a "For Each" loop.
            </para>
            <para>
            You can determine whether or not a given component is a leaf node by using its
            <see cref= "P:Snap.NX.Component.IsLeaf">IsLeaf</see> property.
            </para>
            </remarks>
            <example> 
            The following example shows how to cycle through leaf nodes: 
            <code title="Cycling through leaf nodes" lang="VB.NET" source="Component_03.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.Component.IsLeaf">Snap.NX.Component.IsLeaf</seealso> property. 
        </member>
        <member name="P:Snap.NX.Component.Prototype">
            <summary>
            The prototype part of this component
            </summary>
            <remarks>
            <para>
            A component is created when a part is inserted into an assembly.
            The part that was inserted becomes the Prototype of the component.
            The prototype is the source object that supplies
            the data of the component.
            </para>
            <para>      
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concept of prototypes.
            </para>
            <para>
            Note that the return value will be <c>Nothing</c> if you try to get the
            Prototype property of a component that is not fully loaded, as
            illustrated in the example code below.
            </para>
            </remarks>
            <example> 
            This example shows use of the Prototype part property, including a check to
            avoid errors when the prototype part is not fully loaded.
            <code title="Using prototype parts" lang="VB.NET" source="Component_07.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Component.Depth">
            <summary>
            The depth of the component in the component tree hierarchy
            </summary>
            <remarks>
            <para>
            The root component has Depth = 0, it's children have
            Depth = 1, its grandchildren have Depth = 2, and so on.
            </para>
            <para>
            The Depth property is often useful when writing out indented lists of components.
            </para>
            </remarks>
            <example> 
            The following example shows how to use the Depth property: 
            <code title="Using the Depth property" lang="VB.NET" source="Component_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Component.Position">
            <summary>
            The position of the component
            </summary>
            <remarks>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concept of component positioning.
            </para>
            <para>
            To get the orientation of the component, use its
            <see cref= "P:Snap.NX.Component.Orientation">Orientation</see> property.
            </para>
            </remarks>
            <example> 
            The following example shows how to use component positions and orientations: 
            <code title="Component positions and orientations" lang="VB.NET" source="Component_05.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.Component.Orientation">Snap.NX.Component.Orientation</seealso> property.
        </member>
        <member name="P:Snap.NX.Component.Orientation">
            <summary>
            The orientation of the component
            </summary>
            <remarks>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concept of component orientations.
            </para>
            <para>
            To get the position of the component, use its
            <see cref= "P:Snap.NX.Component.Position">Position</see> property.
            </para>
            </remarks>
            <example> 
            The following example shows how to use component positions and orientations: 
            <code title="Component positions and orientations" lang="VB.NET" source="Component_05.vb"> 
            </code> 
            </example>
            /// <seealso cref= "P:Snap.NX.Component.Position">Snap.NX.Component.Position</seealso> property.
        </member>
        <member name="M:Snap.NX.Component.#ctor(NXOpen.Assemblies.Component)">
            <summary> Constructor, given an NXOpen.Assemblies.Component object</summary>
            <param name="component">An NXOpen.Assemblies.Component object</param>
        </member>
        <member name="M:Snap.NX.Component.op_Implicit(NXOpen.Assemblies.Component)~Snap.NX.Component">
            <summary> Implicit conversion of NXOpen.Assemblies.Component to Snap.NX.Component</summary>
            <param name="component"> An NXOpen.Assemblies.Component object</param>
            <returns>The corresponding Snap.NX.Component object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Component.op_Implicit(Snap.NX.Component)~NXOpen.Assemblies.Component">
            <summary> Implicit conversion of Snap.NX.Component to NXOpen.Assemblies.Component</summary>
            <param name="component"> A  Snap.NX.Component object</param>
            <returns>The enclosed NXOpen.Assemblies.Component object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Component.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Assemblies.Component tag to a Snap.NX.Component</summary>
            <param name="nxopenComponentTag">The tag of an NXOpen.Assemblies.Component object to be converted</param>
            <returns>The Snap.NX.Component object formed by wrapping the NXOpen.Assemblies.Component having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Assemblies.Component object</exception>
        </member>
        <member name="T:Snap.NX.Cone">
            <summary>
            Represents a Snap.NX.Cone feature (interchangeable with <see cref="T:NXOpen.Features.Cone">NXOpen.Features.Cone</see>)
            </summary>
            <remarks>
            <para>
            The following picture explains the properties of an NX.Cone object: 
            </para>
            <para>
            <img src="../Images/Cone.png"/>
            </para>
            There are several restrictions regarding the parameters of an NX.Cone object:
            <list type = "bullet">
            <item>The BaseDiameter and TopDiameter must not be equal</item>
            <item>The BaseDiameter and TopDiameter must both be non-negative (zero is OK)</item>
            <item>The base arc and the top arc do not need to be coaxial, but they must not be coplanar</item>
            <item>The diameters, height, and half-angle must be consistent: 
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;  BaseDiameter - TopDiameter = 2 * Height * tan(HalfAngle)
            </para>
            </item>
            </list>
            <para>
            To create an NX.Cone object, use the functions listed below
            </para> 
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Cone class:
            <code title="Properties of an NX.Cone object: " lang="VB.NET" source="Cone_05.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Cone">Snap.Create.Cone</seealso>
        </member>
        <member name="P:Snap.NX.Cone.AxisPoint">
            <summary>The axis point of the cone</summary>
            <remarks>
            <para>
            This is a point on the axis (center-line) of the cone at the center of the base arc. 
            See the picture for further clarification.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cone.AxisVector">
            <summary>The cone axis vector</summary>
            <remarks>
            <para>
            This is a vector along the axis of the cone. 
            Its direction is from the center of the base arc to the center of the top arc.
            See the picture for further clarification.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cone.BaseDiameter">
            <summary>The cone base diameter</summary>
            <remarks>
            <para>
            This is the diameter of the base arc of the cone. If HalfAngle &gt; 0, then
            BaseDiameter will be larger than TopDiameter. The BaseDiameter and TopDiameter
            are not allowed to be equal.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cone.TopDiameter">
            <summary>The cone top diameter</summary>
            <remarks>
            <para>
            This is the diameter of the top arc of the cone. If HalfAngle &gt; 0, then
            TopDiameter will be smaller than BaseDiameter. The BaseDiameter and TopDiameter
            are not allowed to be equal.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cone.Height">
            <summary>The cone height</summary>
        </member>
        <member name="P:Snap.NX.Cone.HalfAngle">
            <summary>The cone half-angle, in degrees.</summary>
            <remarks>
            <para>
            This angle will be positive if TopDiameter &lt; BaseDiameter.
            See the picture for further clarification.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cone.BaseArc">
            <summary>The circle at the base of the cone, with center at the cone's AxisPoint</summary>
        </member>
        <member name="P:Snap.NX.Cone.TopArc">
            <summary>The circle at the top of the cone (the other end from the BaseArc)</summary>
        </member>
        <member name="P:Snap.NX.Cone.NXOpenCone">
            <summary>The enclosed NXOpen.Features.Cone object</summary>
        </member>
        <member name="P:Snap.NX.Cone.ConeBuilder">
            <summary>The NXOpen.Features.ConeBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Cone feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ConeBuilder">NXOpen.Features.ConeBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Cone.#ctor(NXOpen.Features.Cone)">
            <summary> Constructor, given an NXOpen.Features.Cone object.</summary>
            <param name="cone">An NXOpen.Features.Cone object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Cone.op_Implicit(NXOpen.Features.Cone)~Snap.NX.Cone">
            <summary> Implicit conversion of NXOpen.Features.Cone to NX.cone</summary>
            <param name="cone"> An NXOpen.Features.Cone object</param>
            <returns>The corresponding NX.Cone object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Cone.op_Implicit(Snap.NX.Cone)~NXOpen.Features.Cone">
            <summary> Implicit conversion of NX.Cone to NXOpen.Features.Cone</summary>
            <param name="cone"> AN NX.Cone object</param>
            <returns>The enclosed NXOpen.Features.Cone object</returns>
            <exclude/>        
        </member>
        <member name="M:Snap.NX.Cone.CreateConeFromDiametersHeight(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, direction, base diameter, top diameter and height</summary>        
            <param name="axisPoint">The cone base position of base arc</param>
            <param name="direction">The cone direction vector from base to top</param>
            <param name="baseDiameter">The cone base diameter. The cone base diameter cannot equal its top diameter</param>
            <param name="topDiameter">The cone top diameter. The cone top diameter cannot equal its base diameter</param>
            <param name="height">The cone height</param>
            <returns>An NX.Cone feature object</returns>
        </member>
        <member name="M:Snap.NX.Cone.CreateConeFromDiametersAngle(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, direction, base diameter, top diameter and cone half-angle.</summary>        
            <param name="axisPoint">The cone base position of base arc</param>
            <param name="direction">The cone direction vector from base to top</param>
            <param name="baseDiameter">The cone base diameter. The cone base diameter cannot equal its top diameter</param>
            <param name="topDiameter">The cone top diameter. The cone top diameter cannot equal its base diameter</param>
            <param name="halfAngle">The cone half-angle in degree which is half of the coning angle</param>         
            <returns>An NX.Cone feature object</returns>
        </member>
        <member name="M:Snap.NX.Cone.CreateConeFromDiameterHeightAngle(Snap.Position,Snap.Vector,Snap.Number,Snap.Number,Snap.Number)">
            <summary>Creates a cone feature, given cone base position, direction, base diameter, height and cone half-angle</summary>
            <param name="axisPoint">The cone base position of base arc</param>
            <param name="direction">The cone direction vector from base to top</param>
            <param name="baseDiameter">The cone base diameter. The cone base diameter cannot smaller than (2.0 * height * tan(halfAngle))</param>
            <param name="height">The cone height. The cone height cannot greater than (baseDiameter / (2.0 * height))</param>
            <param name="halfAngle">The cone half-angle in degree which is half of the coning angle. The cone half-angle cannot greater than Atan(baseDiameter / (2.0 * height))</param>         
            <returns>An NX.Cone feature object</returns>
        </member>
        <member name="M:Snap.NX.Cone.CreateConeFromArcs(Snap.NX.ICurve,Snap.NX.ICurve)">
            <summary>Creates a cone feature, given cone base arc and top arc.</summary>                        
            <param name="baseArc">The cone base arc. Cone base arc and top arc cannot be coplanar</param>
            <param name="topArc">The cone top arc. Cone base arc and top arc cannot be coplanar</param>     
            <returns>An NX.Cone feature object</returns>
        </member>
        <member name="M:Snap.NX.Cone.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Cone tag to a Snap.NX.Cone</summary>
            <param name="nxopenConeTag">The tag of an NXOpen.Features.Cone object to be converted</param>
            <returns>The Snap.NX.Cone object formed by wrapping the NXOpen.Features.Cone having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Cone object</exception>
        </member>
        <member name="T:Snap.NX.CoordinateSystem">
            <summary>
            Represents a Snap.NX.CoordinateSystem object (interchangeable with <see cref="T:NXOpen.CoordinateSystem">NXOpen.CoordinateSystem</see>)   
            </summary>
            <remarks>
            <para>
            To create an NX.CoordinateSystem object, use the <see cref="O:Snap.Create.CoordinateSystem">Snap.Create.CoordinateSystem</see> functions. 
            </para>
            <para>
            Note that an Snap.NX.CoordinateSystem object is not the same thing as 
            a <see cref="T:Snap.NX.DatumCsys">Snap.NX.DatumCsys</see> object.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.CoordinateSystem class:
            <code title="Properties of an NX.CoordinateSystem object: " lang="VB.NET" source="Csys_03.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.CoordinateSystem">Snap.Create.CoordinateSystem</seealso>
            <seealso cref="T:Snap.NX.DatumCsys">Snap.NX.DatumCsys</seealso>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.ObjectSubType">
            <summary>Subtypes of NX CoordinateSystem</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.NXOpenCoordinateSystem">
            <summary>The enclosed NXOpen.CoordinateSystem object</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.Matrix">
            <summary>The NX.Matrix object referred to by the coordinate system</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.AxisX">
            <summary>X-axis of coordinate system</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.AxisY">
            <summary>Y-axis of coordinate system</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.AxisZ">
            <summary>Z-axis of coordinate system</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.Origin">
            <summary>The location of the origin of the coordinate system</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.Orientation">
            <summary>Orientation of coordinate system</summary>
        </member>
        <member name="P:Snap.NX.CoordinateSystem.Prototype">
            <summary>
            Returns the prototype coordinate system of this one (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the coordinate system is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.#ctor(NXOpen.CoordinateSystem)">
            <summary>Constructs An NX.CoordinateSystem from an NXOpen.CoordinateSystem</summary>
            <param name="csys">The NXOpen.CoordinateSystem object</param>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.op_Implicit(NXOpen.CoordinateSystem)~Snap.NX.CoordinateSystem">
            <summary>Implicit conversion of NXOpen.CoordinateSystem to NX.CoordinateSystem</summary>
            <param name="csys">The NXOpen.CoordinateSystem to be converted (enclosed)</param>
            <returns>A new NX.CoordinateSystem object enclosing the given NXOpen.CoordinateSystem</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.op_Implicit(Snap.NX.CoordinateSystem)~NXOpen.CoordinateSystem">
            <summary>Implicit conversion of NX.CoordinateSystem to NXOpen.CoordinateSystem</summary>
            <param name="csys">The NX.CoordinateSystem to be converted</param>
            <returns>The NXOpen.CoordinateSystem object enclosed by the given NX.CoordinateSystem</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.CreateCoordinateSystem(Snap.Position,Snap.NX.Matrix)">
            <returns>An NX.CoordinateSystem object</returns>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.CreateCoordinateSystem(Snap.Position,Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Constructs a CoordinateSystem from an origin and three axis vectors</summary>
            <param name="origin">Origin position</param>
            <param name="axisX">X axis</param>
            <param name="axisY">Y axis</param>
            <param name="axisZ">Z axis</param>
            <returns>An NX.CoordinateSystem object</returns>
            <remarks>Assumes that the three axis vectors are orthogonal, and does not perform any checking.</remarks>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.CreateCoordinateSystem(Snap.Position,Snap.Orientation)">
            <summary>Constructs a CoordinateSystem from an origin and an orientation</summary>
            <param name="origin">Origin position</param>
            <param name="matrix">Orientation</param>
            <returns>An NX.CoordinateSystem object</returns>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.MapCsysToCsys(Snap.Position,Snap.NX.CoordinateSystem,Snap.NX.CoordinateSystem)">
            <summary>Map a position from one coordinate system to another</summary>
            <param name="inputCoords">The coordinates of the given point wrt the input coordinate system</param>
            <param name="inputCsys">The input coordinate system</param>
            <param name="outputCsys">The output coordinate system</param>
            <returns>The coordinates of the given point wrt the output coordinate system</returns>
            <example> 
            This example demonstrates mapping between coordinate systems:
            <code title="Mapping between coordinate systems: " lang="VB.NET" source="Csys_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.MapCsysToCsys(Snap.Vector,Snap.NX.CoordinateSystem,Snap.NX.CoordinateSystem)">
            <summary>Map a vector from one coordinate system to another</summary>
            <param name="inputVector">The components of the given vector wrt the input coordinate system</param>
            <param name="inputCsys">The input coordinate system</param>
            <param name="outputCsys">The output coordinate system</param>
            <returns>The components of the given vector wrt the output coordinate system</returns>      
            <example> 
            This example demonstrates mapping between coordinate systems:
            <code title="Mapping between coordinate systems: " lang="VB.NET" source="Csys_07.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.MapWcsToAcs(Snap.Position)">
            <summary>Map a position from Work coordinates to Absolute coordinates</summary>
            <param name="workCoords">The coordinates of the given point wrt the Work Coordinate System (WCS)</param>
            <returns>The coordinates of the given point wrt the Absolute Coordinate System (ACS)</returns>
            <remarks>
            <para>
            If you are given point coordinates relative to the WCS, then you will need to
            use this function to "map" them to the ACS before using them in SNAP functions. 
            </para>
            </remarks>
            <example> 
            This example shows how to map coordinates from the WCS to the ACS:
            <code title="Map from WCS to ACS: " lang="VB.NET" source="Csys_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapAcsToWcs">MapAcsToWcs</seealso>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapCsysToCsys">MapCsysToCsys</seealso>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.MapWcsToAcs(Snap.Vector)">
            <summary>Map a vector from Work coordinates to Absolute coordinates</summary>
            <param name="workVector">The components of the given vector wrt the Work Coordinate System (WCS)</param>
            <returns>The components of the given vector wrt the Absolute Coordinate System (ACS)</returns>
            <remarks>
            <para>
            If you are given vector components relative to the WCS, then you will need to
            use this function to "map" them to the ACS before using them in SNAP functions. 
            </para>
            </remarks>
            <example> 
            This example shows how to map a vector from the WCS to the ACS:
            <code title="Map from WCS to ACS: " lang="VB.NET" source="Csys_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapAcsToWcs">MapAcsToWcs</seealso>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapCsysToCsys">MapCsysToCsys</seealso>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.MapAcsToWcs(Snap.Position)">
            <summary>Map a position from Absolute coordinates to Work coordinates</summary>
            <param name="absCoords">The coordinates of the given point wrt the Absolute Coordinate System (ACS)</param>
            <returns>The coordinates of the given point wrt the Work Coordinate System (WCS)</returns>
            <example> 
            This example shows how to map coordinates from the ACS to the WCS:
            <code title="Map from ACS to WCS: " lang="VB.NET" source="Csys_05.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapWcsToAcs">MapWcsToAcs</seealso>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapCsysToCsys">MapCsysToCsys</seealso>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.MapAcsToWcs(Snap.Vector)">
            <summary>Map a vector from Absolute coordinates to Work coordinates</summary>
            <param name="absVector">The components of the given vector wrt the Absolute Coordinate System (ACS)</param>
            <returns>The components of the given vector wrt the Work Coordinate System (WCS)</returns>
            <example> 
            This example shows how to map coordinates from the ACS to the WCS:
            <code title="Map from ACS to WCS: " lang="VB.NET" source="Csys_05.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapWcsToAcs">MapWcsToAcs</seealso>
            <seealso cref="O:Snap.NX.CoordinateSystem.MapCsysToCsys">MapCsysToCsys</seealso>
        </member>
        <member name="M:Snap.NX.CoordinateSystem.Copy">
            <summary>Copies an NX.CoordinateSystem (with a null transform)</summary>
            <returns>A copy of the input CoordinateSystem</returns>
            <remarks>
            <para>
            The new coordinate system will be on the same layer as the original one. 
            </para>
            <para>
            The function will throw an NXOpen.NXException, if the copy operation cannot be performed.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.CoordinateSystem.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.CoordinateSystem</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.CoordinateSystem</returns>      
        </member>
        <member name="M:Snap.NX.CoordinateSystem.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.CoordinateSystem tag to a Snap.NX.CoordinateSystem</summary>
            <param name="nxopenCoordinateSystemTag">The tag of an NXOpen.CoordinateSystem object to be converted</param>
            <returns>The Snap.NX.CoordinateSystem object formed by wrapping the NXOpen.CoordinateSystem having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.CoordinateSystem object</exception>
        </member>
        <member name="T:Snap.NX.Curve">
            <summary>
            Represents a Snap.NX.Curve object (interchangeable with <see cref="T:NXOpen.Curve">NXOpen.Curve</see>)   
            </summary>
            <remarks>
            <para>
            Many of the functions in this class use "parameter" values on curves.
            There are several different ways to treat parameter values, and this can lead
            to confusion, sometimes. A common approach is to "unitize" parameter values.
            This means that the curve parameter has the value u = 0 at the start of the
            curve, u = 1 at the end of the curve, and intermediate values in the
            range 0 &#8804; u &#8804; 1 for intermediate points.
            </para>
            <para>
            An alternative approach is to use the original parameterization of the curve,
            without unitizing. With this approach, you have to be aware of the starting and
            ending parameter values of the curve (MinU and MaxU), since these are not
            necessarily 0 and 1 respectively.
            </para>
            <para>
            It is the second (non-unitized) approach that we use in the functions in this class
            (and throughout Snap).
            </para>
            <para>
            To illustrate the difference, suppose <c>myArc</c> is a circular arc, and let's consider the
            point <c>myArc.Position(0.5)</c>. This is <strong>not</strong> the point half-way along the curve,
            it is the point corresponding to an angle of 0.5 degrees on the arc. If you want
            the mid-way point, your code should be:
            <code lang = "VB.NET">
            Dim midU as Double = (myArc.MinU + myArc.MaxU)/2
            Dim p As Position = myArc.Position(midU)
            </code>
            </para>
            <para>
            Similarly, if circ is a complete circle (360 degrees), then the point at 90 degrees
            is <c>circ.Position(90)</c>, not <c>circ.Position(0.25)</c>.
            </para>
            The following picture shows some of the properties of an NX.Curve object. The curve shown is the spline
            created by the example code below, so in this particular case it <strong>is</strong> true
            that MinU = 0 and MaxU = 1.
            <para>
            <img src="../Images/Curve.png"/>
            </para>
            </remarks>
            <example>
            This example shows how to use the properties of the NX.Curve class:
            <code title="Properties of an NX.Curve object: " lang="VB.NET" source="Curve_02.vb"> 
            </code>
            </example>
            <seealso cref="O:Snap.Create.Arc">Snap.Create.Arc</seealso>
            <seealso cref="O:Snap.Create.Ellipse">Snap.Create.Ellipse</seealso>
            <seealso cref="O:Snap.Create.Line">Snap.Create.Line</seealso>
            <seealso cref="O:Snap.Create.Spline">Snap.Create.Spline</seealso>
        </member>
        <member name="P:Snap.NX.Curve.NXOpenICurve">
            <summary>The enclosed NXOpen.ICurve object</summary>
        </member>
        <member name="P:Snap.NX.Curve.NXOpenCurve">
            <summary>The enclosed NXOpen.Curve object</summary>
        </member>
        <member name="P:Snap.NX.Curve.NXOpenDisplayableObject">
            <summary>The associated NXOpen.DisplayableObject of this NX.Curve</summary>
        </member>
        <member name="P:Snap.NX.Curve.NXOpenTag">
            <summary>Get the NXOpen.Tag from this NX.Curve</summary>
        </member>
        <member name="P:Snap.NX.Curve.ArcLength">
            <summary>The arclength of the curve</summary>
            <remarks>
            <para>
            If you want to calculate the total arclength of a collection of curves, use the
            <see cref= "M:Snap.Compute.ArcLength(Snap.NX.ICurve[])">Snap.Compute.Arclength</see> function instead.
            </para>
            </remarks>
            <seealso cref= "M:Snap.Compute.ArcLength(Snap.NX.ICurve[])">Snap.Compute.Arclength</seealso>
        </member>
        <member name="P:Snap.NX.Curve.Box">
            <summary>The 3D box that encloses the curve</summary>
        </member>
        <member name="P:Snap.NX.Curve.MinU">
            <summary>The lower-limit parameter value (at the start-point of the curve)</summary>
            <remarks>
            <para>
            If c is a curve, then <c>c.Position(c.MinU) = c.StartPoint</c>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Curve.MaxU">
            <summary>The upper-limit parameter value (at the end-point of the curve)</summary>
            <remarks>
            <para>
            If c is a curve, then <c>c.Position(c.MaxU) = c.EndPoint</c>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Curve.IsClosed">
            <summary>If true, indicates that the curve is closed (start-point = end-point)</summary>
        </member>
        <member name="P:Snap.NX.Curve.StartPoint">
            <summary>The start point of the curve</summary>
        </member>
        <member name="P:Snap.NX.Curve.EndPoint">
            <summary>The end point of the curve</summary>
        </member>
        <member name="P:Snap.NX.Curve.Plane">
            <summary>A plane containing the given curve</summary>
            <remarks>
            <para>
            This function returns <c>Nothing</c> if the curve is linear (in which case its plane
            is not well-defined) or if the curve is not planar.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Curve.Factor">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapValue = nxopenValue * Factor</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenValue = snapValue / Factor</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Curve.Prototype">
            <summary>
            Returns the prototype curve of this curve (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the curve is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Curve.#ctor(NXOpen.NXObject)">
            <summary>Construct an NX.Curve given an NXOpen.NXObject object</summary>
            <param name="nxopenObject">An NXOpen.NXObject object</param>
            <remarks>
            <para>
            The constructor is protected to encourage callers to use CreateCurve, 
            instead, since this ensures proper downcasting.
            The only callers should be constructors for derived classes.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.#ctor(NXOpen.Tag)">
            <summary>Construct an NX.Curve, given an NXOpen.Tag</summary>
            <param name="objectTag">An NXOpen.Tag</param>
            <remarks>
            <para>
            The constructor is protected to encourage callers to use CreateCurve, 
            instead, since this ensures proper downcasting.
            The only callers should be constructors for derived classes.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.#ctor(NXOpen.Edge)">
            <summary>Constructor, given an NXOpen.Curve object</summary>
            <param name="nxopenCurve">An NXOpen.Curve object</param>
            <remarks>
            <para>
            The constructor is protected to encourage callers to use CreateCurve, 
            instead, since this ensures proper downcasting.
            The only callers should be constructors for derived classes.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.CreateCurve(NXOpen.Curve)">
            <summary>
            Creates a Snap.NX.Curve object of the most specific type possible
            </summary>
            <param name="nxopenCurve">The input NXOpen.Curve</param>
            <returns>A Snap.NX.Curve object that has the most specific type possible</returns>
            <remarks>
            <para>
            The returned curve's static type is still Snap.NX.Curve, but, where
            possible, the NX.Curve variable now contains a curve object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller. This is used in Selection, for example.
            </para>
            <para>
            This function should be used instead of the NX.Curve constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.op_Implicit(NXOpen.Curve)~Snap.NX.Curve">
            <summary>Implicit conversion of NXOpen.Curve to NX.Curve</summary>
            <param name="curve">The NXOpen.Curve to be converted (enclosed)</param>
            <returns>A new NX.Curve object enclosing the given NXOpen.Curve</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Curve.op_Implicit(Snap.NX.Curve)~NXOpen.Curve">
            <summary>Implicit conversion of NX.Curve to NXOpen.Curve</summary>
            <param name="curve">The NX.Curve to be converted</param>
            <returns>The NXOpen.Curve object enclosed by the given NX.Curve</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Curve.Position(System.Double)">
            <summary>Calculates a point on the curve at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>The point corresponding to the given parameter value</returns>
            <remarks>
            <para>
            If you want to calculate several points on a curve, the 
            <see cref= "O:Snap.NX.Curve.PositionArray">PositionArray</see>
            functions might be more useful.
            The following example shows how the <c>Position</c> function can
            be used to calculate a sequence of points along a curve.
            </para>
            </remarks>
            <example> 
            <code title="Points along a curve" lang="VB.NET" source="Curve_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.Curve.PositionArray(System.Double[])">
            <summary>Calculates points on a curve at given parameter values</summary>
            <param name="values">Parameter values</param>
            <returns>The points corresponding to the given parameter values</returns>
            <remarks>
            <para>
            Calling this function is typically around 3&#215; as fast as calling
            the Curve.Position function in a loop.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.Derivative(System.Double)">
            <summary>Calculates the first derivative vector on the curve at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>First derivative vector (not unitized)</returns>
            <remarks>
            <para>
            The vector returned is usually not a unit vector. In fact, it may even have zero length, in certain unusual cases.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Curve.Derivatives(System.Double,System.Int32)">
            <summary>Calculates curve derivatives (and position) at a given parameter value</summary>
            <param name="value">Parameter at which to evaluate</param>
            <param name="order">Order of highest derivative returned (zero for position alone)</param>
            <returns>Array of derivative vectors -- [0] is position, [1] is first derivative, etc.</returns>
            <remarks>
            <para>
            The [0] element of the returned array represents a location on the curve, even though
            it is contained in a Vector variable. In many cases, you (the caller) should cast
            this Vector to a Position variable before using it further.
            </para>
            <para>
            The maximum value allowed for order is 3. Usinga value greater than 3 will result in
            a run-time error.
            </para>
            </remarks>     
            <example> 
            This example shows how to calculate curve derivatives: 
            <code title="Calculating derivatives" lang="VB.NET" source="Curve_03.vb"> 
            </code> 
            </example> 
        </member>
        <member name="M:Snap.NX.Curve.Tangent(System.Double)">
            <summary>Calculates the unit tangent vector at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit tangent vector</returns>
            <remarks>
            <para>
            This function successfully calculates a unit tangent vector even in those (rare) 
            cases where the derivative vector of the curve has zero length.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Curve.Normal(System.Double)">
            <summary>Calculates unit normal at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit normal vector</returns>
            <remarks>
            <para>
            The normal lies in the "osculating plane" of the curve at the given parameter value
            (the plane that most closely matches the curve). So, if the curve is planar, the normal always
            lies in the plane of the curve.
            </para>
            <para>
            The normal always points towards the center of curvature of the curve. So, if the curve
            has an inflexion, the normal will flip from one side to the other, which may be undesirable.
            </para>
            <para>
            The normal is the cross product of the binormal and the tangent: N = B*T
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.Binormal(System.Double)">
            <summary>Calculates the unit binormal at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit binormal</returns>
            <remarks>
            <para>
            The binormal is normal to the "osculating plane" of the curve at the given parameter value
            (the plane that most closely matches the curve). So, if the curve is planar, the binormal 
            is normal to the plane of the curve.
            </para>
            <para>
            The binormal is the cross product of the tangent and the normal: B = Cross(T,N).
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.Curvature(System.Double)">
            <summary>Calculates curvature at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Curvature value (always non-negative)</returns>
            <remarks>
            <para>
            Curvature is the reciprocal of radius of curvature. So, on a straight line,
            curvature is zero and radius of curvature is infinite. On a circle of radius 5,
            curvature is 0.2 (and radius of curvature is 5, of course).
            </para>
            </remarks>
            <example> 
            This example shows how to calculate curvature: 
            <code title="Calculating curvature" lang="VB.NET" source="Curve_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Curve.Parameter(Snap.Position)">
            <summary>Calculates the parameter value at a point on the curve</summary>
            <param name="point">The point</param>
            <returns>Parameter value at the point (not unitized)</returns>
            <remarks>
            <para>
            The <c>Parameter</c> function and the <c>Position</c> function are designed to work
            together smoothly -- each of these functions is the "reverse" of the other. 
            So, if c is any curve and t is any parameter value, then
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   <c>c.Parameter(c.Position(t)) = t</c>
            </para>
            <para>
            Also, if p is any point on the curve c, then
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   <c>c.Position(c.Parameter(p)) = p</c>
            </para>
            </remarks>
            <example> 
            This example shows how to use parameter values on curves: 
            <code title="Parameter values on curves" lang="VB.NET" source="Curve_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Curve.Parameter(System.Double,System.Double)">
            <summary>Calculates the parameter value defined by an arclength step along a curve</summary>
            <param name="baseParameter">The curve parameter value at the starting location</param>
            <param name="arclength">The arclength increment along the curve (the length of our step)</param>
            <returns>The curve parameter value at the far end of the step</returns>
            <remarks>
            <para>
            This function returns the curve parameter value at the far end of a "step" along a curve.
            The start of the step is defined by a given parameter value, and the size of the step is given
            by an arclength along the curve. The arclength step may be positive or negative.
            </para>
            </remarks>
            <example> 
            This example shows how to compute parameter increment:
            <code title="Compute parameter increment" lang="VB.NET" source="Parameter_01.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Curve.Parameter(System.Double)">
            <summary>Calculates the parameter value at a fractional arclength value along a curve</summary>
            <param name="arclengthFraction">Fractional arclength along the curve</param>
            <returns>Parameter value</returns>
            <remarks>
            <para>
            The input is a fractional arclength. A value of 0 corresponds to the start of the curve,
            a value of 1 corresponds to the end-point, and values between 0 and 1 correspond to
            interior points along the curve.
            </para>
            <para>
            You can input arclength values outside the range 0 to 1, and this will return parameter
            values corresponding to points on the extension of the curve.
            </para>
            </remarks>
            <example> 
            This example shows how to compute parameter:
            <code title="Compute parameter" lang="VB.NET" source="Parameter_04.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Curve.Copy">
            <summary>Copies an NX.Curve (with a null transform)</summary>
            <returns>A copy of the input curve</returns>
            <remarks>
            <para>
            </para>
            <para>
            The new curve will be on the same layer as the original one. 
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Curve</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Curve</returns>
        </member>
        <member name="M:Snap.NX.Curve.Copy(Snap.NX.Curve[])">
            <summary>Copies an array of NX.Curve (with no transform)</summary>
            <param name="original">Original NX.Curve array</param>
            <returns>A copy of the input curves</returns>
            <remarks>
            <para>
            The new curves will be on the same layers as the original ones. 
            </para>
            <para>
            The function will throw an NXOpen.NXException, if the copy operation cannot be performed.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Curve.Copy(Snap.Geom.Transform,Snap.NX.Curve[])">
            <summary>Transforms/copies an array of NX.Curve objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Curve array</param>
            <returns>A copy of the input curves</returns>
            <remarks>The function will throw NXOpen.NXException, when the operation is not correct</remarks>            
        </member>
        <member name="M:Snap.NX.Curve.Trim(System.Double,System.Double)">
            <summary>Trim a curve to a parameter interval</summary>
            <param name="lowerParam">The lower-limit parameter value</param>
            <param name="upperParam">The upper-limit parameter value</param>
            <example> 
            This example shows how to trim a curve:
            <code title="Trim a curve" lang="VB.NET" source="TrimCurve_01.vb">
            </code>
            </example>
            <seealso cref="O:Snap.NX.Curve.Divide">Snap.NX.Curve.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Curve.Divide(System.Double[])">
            <summary>Divide a curve at an array of parameter values</summary>
            <param name="parameters">The parameter values at which the curve should be divided</param>
            <returns>An array of <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <remarks>
            <para>
            The function will create new curves, and the original one will be unchanged.
            If you want to modify the extents of an existing curve, please use the
            <see cref= "M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</see> function.
            </para>
            <para>
            SNAP also provides functions for dividing specific types of curves, which
            may be more convenient, in many cases. Links to these functions are 
            provided in the "See Also" section below.
            </para>
            </remarks>
            <example> 
            This example shows how to divide a curve: 
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_06.vb"> 
            </code>
            </example>      
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
            <seealso cref="O:Snap.NX.Line.Divide">Snap.NX.Line.Divide</seealso>
            <seealso cref="O:Snap.NX.Arc.Divide">Snap.NX.Arc.Divide</seealso>
            <seealso cref="O:Snap.NX.Spline.Divide">Snap.NX.Spline.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Curve.Divide(Snap.NX.ICurve,Snap.Position)">
            <summary>Divide a curve at its intersection with another curve</summary>
            <param name="boundingCurve">Bounding curve to be used to divide the given curve</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <remarks>
            <para>
            This function will create two new curves, and the original one will be unchanged.
            If you want to modify the extents of an existing curve, please use the
            <see cref= "M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</see> function.
            </para>
            <para>
            SNAP also provides functions for dividing specific types of curves, which
            may be more convenient, in many cases. Links to these functions are 
            provided in the "See Also" section below.
            </para>
            </remarks>
            <example> 
            This example shows how to divide a curve: 
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_03.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
            <seealso cref="O:Snap.NX.Line.Divide">Snap.NX.Line.Divide</seealso>
            <seealso cref="O:Snap.NX.Arc.Divide">Snap.NX.Arc.Divide</seealso>
            <seealso cref="O:Snap.NX.Spline.Divide">Snap.NX.Spline.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Curve.Divide(Snap.NX.Face,Snap.Position)">
            <summary>Divide a curve at its intersection with a given face</summary>
            <param name="face">A face to be used to divide the given curve</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <remarks>
            <para>
            This function will create two new curves, and the original one will be unchanged.
            If you want to modify the extents of an existing curve, please use the
            <see cref= "M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</see> function.
            </para>
            <para>
            SNAP also provides functions for dividing specific types of curves, which
            may be more convenient, in many cases. Links to these functions are 
            provided in the "See Also" section below.
            </para>
            </remarks>
            <example> 
            This example shows how to divide a curve:
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_04.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
            <seealso cref="O:Snap.NX.Line.Divide">Snap.NX.Line.Divide</seealso>
            <seealso cref="O:Snap.NX.Arc.Divide">Snap.NX.Arc.Divide</seealso>
            <seealso cref="O:Snap.NX.Spline.Divide">Snap.NX.Spline.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Curve.Divide(Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Divide a curve at its intersection with a given plane</summary>
            <param name="geomPlane">A plane to be used to divide the given curve</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> objects</returns>
            <remarks>
            <para>
            This function will create two new curves, and the original one will be unchanged.
            If you want to modify the extents of an existing curve, please use the
            <see cref= "M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</see> function.
            </para>
            <para>
            SNAP also provides functions for dividing specific types of curves, which
            may be more convenient, in many cases. Links to these functions are 
            provided in the "See Also" section below.
            </para>
            </remarks>
            <example> 
            This example shows how to divide a curve:
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_05.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
            <seealso cref="O:Snap.NX.Line.Divide">Snap.NX.Line.Divide</seealso>
            <seealso cref="O:Snap.NX.Arc.Divide">Snap.NX.Arc.Divide</seealso>
            <seealso cref="O:Snap.NX.Spline.Divide">Snap.NX.Spline.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Curve.ToSpline">
            <summary>Converts the curve to a spline</summary>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            Any type of curve can be converted exactly into a spline; no approximation
            is involved.
            </para>
            <para>
            If you want to convert a string of curves or edges into a spline, please use the
            <see cref= "M:Snap.Create.JoinCurves(Snap.NX.ICurve[])">Snap.Create.JoinCurves</see> function, instead.
            </para>
            </remarks>
            <example> 
            This example shows how to convert a curve to a spline: 
            <code title="Convert curve to a spline" lang="VB.NET" source="ToSpline_01.vb"> 
            </code>
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>
            <seealso cref="M:Snap.NX.Edge.ToSpline">Snap.NX.Edge.ToSpline</seealso>
            <seealso cref="M:Snap.Create.JoinCurves(Snap.NX.ICurve[])">Snap.Create.JoinCurves</seealso>
        </member>
        <member name="M:Snap.NX.Curve.PositionArray(System.Int32)">
            <summary>Calculates an arrays of positions at equal arclengths on a curve</summary>
            <param name="pointCount">The number of positions to be calculated on the curve</param>
            <returns>An array of positions on the curve</returns>
            <example> 
            This example shows how to compute positions at equal arclengths on a curve : 
            <code title="Compute position array" lang="VB.NET" source="PositionArray_01.vb">
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Curve.PositionArray(System.Double)">
            <summary>Calculate an array of positions on a curve corresponding to a given chord-height tolerance</summary>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <remarks>
            <para>
            A chord is the straight line between adjacent positions on the curve. 
            The chord-height tolerance is the maximum allowable distance between a chord and the curve itself.
            </para>
            </remarks>
            <returns>An array of positions on the curve</returns>
            <example> 
            This example shows how to compute a position array with a given chord-height tolerance: 
            <code title="Create position array" lang="VB.NET" source="PositionArray_02.vb"> 
            </code>
            </example>      
        </member>
        <member name="M:Snap.NX.Curve.PositionArray(System.Double,System.Double,System.Double)">
            <summary>Calculates an array of positions on a curve corresponding to given tolerances</summary>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <param name="angularTolerance">The angular tolerance (in degrees)</param>
            <param name="stepTolerance">The chord-length tolerance</param>
            <returns>An array of positions on the curve</returns>
            <remarks>
            <para>
            A chord is a straight line between adjacent positions; the blue lines in the picture below are chords.
            </para>
            <para>
            The three tolerances provide independent values for controlling the positions located along the curve. Their meanings
            are shown in the following picture
            </para>
            <para>
            <img src="../Images/PositionArray_03.jpg"/>
            </para>
            <list type = "bullet">
            <item>The chord-height tolerance is the maximum allowable distance between chords and the curve. 
            This is the distance H in the picture above.</item>
            <item>The angular tolerance is the maximum allowable sum of the angles between the chord and 
            the tangents to the curve at the ends of the chord. This is the sum A1+A2 in the picture above.</item>
            <item>The step tolerance is the maximum allowable length of the chords, which is distance D in the picture.</item>
            </list>
            If any of the input tolerances is zero, it is ignored, so it has no effect.
            Otherwise, the output positions will satisfy all the given tolerances.
            Note that the maximum values specified in the tolerances may not be attained;
            we only guarantee that they will not be exceeded.
            </remarks> 
            <example>
            This example shows how to compute an array of positions on a curve: 
            <code title="Compute array of positions" lang="VB.NET" source="PositionArray_03.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Curve.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Curve tag to a Snap.NX.Curve</summary>
            <param name="nxopenCurveTag">The tag of an NXOpen.Curve object to be converted</param>
            <returns>The Snap.NX.Curve object formed by wrapping the NXOpen.Curve having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Curve object</exception>
        </member>
        <member name="M:Snap.NX.Curve.PointSet(Snap.NX.ICurve,System.Double,System.Double,System.Double)">
            <summary>Calculates an array of positions on a curve corresponding to given tolerances</summary>
            <param name="icurve">An NX.Curve or NX.Edge object</param>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <param name="angularTolerance">The angular tolerance (in degrees)</param>
            <param name="stepTolerance">The chord-length tolerance</param>
            <returns>An array of positions on the curve</returns>
        </member>
        <member name="M:Snap.NX.Curve.PointSet(Snap.NX.ICurve,System.Int32)">
            <summary>Calculates an arrays of positions at equal arclengths on a curve or edge</summary>
            <param name="icurve">An NX.Curve or NX.Edge object</param>
            <param name="pointCount">The number of positions to be calculated on the curve</param>
            <returns>An array of positions on the curve</returns>
        </member>
        <member name="T:Snap.NX.Cylinder">
            <summary>
            Represents a Snap.NX.Cylinder feature (interchangeable with <see cref="T:NXOpen.Features.Cylinder">NXOpen.Features.Cylinder</see>)
            </summary>
            <remarks>
            <para>
            The following picture explains the properties of an NX.Cylinder object: 
            </para>
            <para>
            <img src="../Images/Cylinder.png"/>
            </para>
            <para>
            To create an NX.Cylinder object, use the <see cref="O:Snap.Create.Cylinder">Snap.Create.Cylinder</see> functions.
            </para> 
            </remarks>   
            <example>
            This example shows how to use the properties of the NX.Cylinder class:
            <code title="Properties of an NX.Cylinder object: " lang="VB.NET" source="Cylinder_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Cylinder">Snap.Create.Cylinder</seealso>
        </member>
        <member name="P:Snap.NX.Cylinder.AxisPoint">
            <summary>The axis point of the cylinder</summary>
            <remarks>
            <para>
            This is a point on the axis (center-line) of the cylinder at the center of the base circle. 
            See the picture for further clarification.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cylinder.AxisVector">
            <summary>The axis vector of the cylinder</summary>
            <remarks>
            <para>
            This is a vector along the axis (centerline) of the cylinder. 
            Its direction is from the center of the base arc to the center of the top arc.
            See the picture for further clarification.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Cylinder.Diameter">
            <summary>The cylinder diameter</summary>        
        </member>
        <member name="P:Snap.NX.Cylinder.Height">
            <summary>The cylinder height (must be positive)</summary>        
        </member>
        <member name="P:Snap.NX.Cylinder.NXOpenCylinder">
            <summary>The enclosed NXOpen.Features.Cylinder object</summary>
        </member>
        <member name="P:Snap.NX.Cylinder.CylinderBuilder">
            <summary>The NXOpen.Features.CylinderBuilder object</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Cylinder feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.CylinderBuilder">NXOpen.Features.CylinderBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Cylinder.#ctor(NXOpen.Features.Cylinder)">
            <summary> Constructor, given an NXOpen.Features.Cylinder object</summary>
            <param name="cylinder">An NXOpen.Features.Cylinder object</param>
        </member>
        <member name="M:Snap.NX.Cylinder.op_Implicit(NXOpen.Features.Cylinder)~Snap.NX.Cylinder">
            <summary> Implicit conversion of NXOpen.Features.Cylinder to NX.Cylinder</summary>
            <param name="cylinder"> An NXOpen.Features.Cylinder object</param>
            <returns>The corresponding NX.Cylinder feature</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Cylinder.op_Implicit(Snap.NX.Cylinder)~NXOpen.Features.Cylinder">
            <summary> Implicit conversion of NX.Cylinder to NXOpen.Features.Cylinder</summary>
            <param name="cylinder"> AN NX.Cylinder object</param>
            <returns>The enclosed NXOpen.Features.Cylinder feature</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Cylinder.CreateCylinder(Snap.Position,Snap.Vector,Snap.Number,Snap.Number)">
            <summary>Creates a cylinder feature, given base point, direction, height and diameter expressions</summary>        
            <param name="axisPoint">The point at base of cylinder</param>
            <param name="axisVector">The cylinder axis vector (length doesn't matter)</param>
            <param name="height">The cylinder height</param>
            <param name="diameter">The cylinder diameter</param>
            <returns>An NX.Cylinder feature</returns>        
        </member>
        <member name="M:Snap.NX.Cylinder.CreateCylinder(Snap.NX.ICurve,Snap.Number)">
            <summary>Creates a cylinder feature, given base arc and height expression</summary>                
            <param name="arc">Base arc of cylinder</param>
            <param name="height">Height of cylinder</param> 
            <returns>A Snap.NX.Cylinder feature</returns> 
        </member>
        <member name="M:Snap.NX.Cylinder.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Cylinder tag to a Snap.NX.Cylinder</summary>
            <param name="nxopenCylinderTag">The tag of an NXOpen.Features.Cylinder object to be converted</param>
            <returns>The Snap.NX.Cylinder object formed by wrapping the NXOpen.Features.Cylinder having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Cylinder object</exception>
        </member>
        <member name="T:Snap.NX.DatumAxis">
            <summary>Represents a Snap.NX.DatumAxis object (interchangeable with <see cref="T:NXOpen.Features.DatumAxisFeature">NXOpen.Features.DatumAxisFeature</see>)</summary>
            <remarks>   
            <para>
            To create an NX.DatumAxis object, use the <see cref="O:Snap.Create.DatumAxis">Snap.Create.DatumAxis</see> functions. 
            </para>
            <para>
            Note that there are two types of Datum Axis object in NX/Open: 
            NXOpen.DatumAxis and NXOpen.Features.DatumAxisFeature. The Snap.NX.DatumAxis
            type corresponds most closely with the NXOpen.Features.DatumAxisFeature type.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.DatumAxis class:
            <code title="Properties of an NX.DatumAxis object: " lang="VB.NET" source="DatumAxis_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.DatumAxis">Snap.Create.DatumAxis</seealso>   
        </member>
        <member name="P:Snap.NX.DatumAxis.ObjectType">
            <summary>The type of the object</summary>
            <remarks>
            <para>
            This always returns NX.ObjectTypes.Type.DatumAxis.
            Note that this not the same as NXOpen.UF.UFConstants.UF_datum_axis_type.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.DatumAxis.NXOpenDatumAxisFeature">
            <summary>The enclosed NXOpen.Features.DatumAxisFeature object</summary>
        </member>
        <member name="P:Snap.NX.DatumAxis.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature.DatumAxis</summary>
            <remarks>
            <para>
            This array always has a single member, which is an NXOpen.DatumAxis object.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.DatumAxis.DatumAxisBuilder">
            <summary>The NXOpen.Features.DatumAxisBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.DatumAxis feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.DatumAxisBuilder">NXOpen.Features.DatumAxisBuilder</seealso>
        </member>
        <member name="P:Snap.NX.DatumAxis.Direction">
            <summary>The direction vector of the datum axis (a unit vector)</summary>
        </member>
        <member name="P:Snap.NX.DatumAxis.Origin">
            <summary>The origin of the datum axis</summary>
        </member>
        <member name="P:Snap.NX.DatumAxis.StartPoint">
            <summary>The start point of the axis</summary>
        </member>
        <member name="P:Snap.NX.DatumAxis.EndPoint">
            <summary>The end point of the axis</summary>
        </member>
        <member name="M:Snap.NX.DatumAxis.#ctor(NXOpen.Features.DatumAxisFeature)">
            <summary> Constructor, given an NXOpen.Features.DatumAxisFeature object</summary>
            <param name="datumAxisFeature">An NXOpen.Features.DatumAxisFeature object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumAxis.op_Implicit(NXOpen.Features.DatumAxisFeature)~Snap.NX.DatumAxis">
            <summary>Implicit conversion of NXOpen.Features.DatumAxisFeature to NX.DatumAxis</summary>
            <param name="datumAxisFeature">The NXOpen.Features.DatumAxisFeature to be converted (enclosed)</param>
            <returns>A new NX.DatumAxis object enclosing the given NXOpen.Features.DatumAxisFeature</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumAxis.op_Implicit(Snap.NX.DatumAxis)~NXOpen.Features.DatumAxisFeature">
            <summary>Implicit conversion of NX.DatumAxis to NXOpen.Features.DatumAxisFeature</summary>
            <param name="datumAxis">The NX.DatumAxis to be converted</param>
            <returns>The NXOpen.Features.DatumAxisFeature object enclosed by the given NX.DatumAxis</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumAxis.CreateDatumAxis(Snap.NX.ICurve,Snap.Number,Snap.NX.DatumAxis.CurveOrientations)">
            <summary>Creates a datum axis object</summary>
            <param name="icurve">Icurve is an edge or a curve</param>
            <param name="arcLengthPercent">Percent arcLength, in range 0 to 100</param>
            <param name="curveOrientation">The curve orientation used by axis</param>
            <returns>An NX.DatumAxis object</returns>
        </member>
        <member name="M:Snap.NX.DatumAxis.CreateDatumAxis(Snap.Position,Snap.Vector)">
            <summary>Creates a datum axis from a position and a vector</summary>
            <param name="origin">The base point of the datum axis</param>
            <param name="direction">The direction vector of the datum axis (length doesn't matter)</param>
            <returns>An NX.DatumAxis object</returns>
        </member>
        <member name="M:Snap.NX.DatumAxis.CreateDatumAxis(Snap.Position,Snap.Position)">
            <summary>Creates a datum axis from two positions</summary>
            <param name="startPoint">The start point of the axis</param>
            <param name="endPoint">The end point of the axis</param>
            <returns>An NX.DatumAxis object</returns>
        </member>
        <member name="T:Snap.NX.DatumAxis.CurveOrientations">
            <summary>Available orientation options when creating a Datum Axis at a point on a curve</summary>
        </member>
        <member name="F:Snap.NX.DatumAxis.CurveOrientations.Tangent">
            <summary>Along the tangent vector of the curve at the point</summary>
        </member>
        <member name="F:Snap.NX.DatumAxis.CurveOrientations.Normal">
            <summary>Along the normal vector of the curve at the point</summary>
        </member>
        <member name="F:Snap.NX.DatumAxis.CurveOrientations.Binormal">
            <summary>Along the binormal vector of the curve at the point</summary>
        </member>
        <member name="M:Snap.NX.DatumAxis.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.DatumAxisFeature tag to a Snap.NX.DatumAxis</summary>
            <param name="nxopenDatumAxisTag">The tag of an NXOpen.Features.DatumAxisFeature object to be converted</param>
            <returns>The Snap.NX.DatumAxis object formed by wrapping the NXOpen.Features.DatumAxisFeature having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.DatumAxisFeature object</exception>
        </member>
        <member name="T:Snap.NX.DatumCsys">
            <summary>Represents a Snap.NX.DatumCsys object (interchangeable with <see cref="T:NXOpen.Features.DatumCsys">NXOpen.Features.DatumCsys</see>)</summary>
            <remarks>
            <para>
            To create an NX.DatumCsys object, use the <see cref="O:Snap.Create.DatumCsys">Snap.Create.DatumCsys</see> functions.
            </para>
            <para>
            Note that an Snap.NX.DatumCsys is not the same thing as 
            a <see cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</see> object.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.DatumCsys class:
            <code title="Properties of an NX.DatumCsys object: " lang="VB.NET" source="DatumCsys_03.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.DatumCsys">Snap.Create.DatumCsys</seealso>
            <seealso cref="T:Snap.NX.CoordinateSystem">Snap.NX.CoordinateSystem</seealso>
        </member>
        <member name="P:Snap.NX.DatumCsys.NXOpenDatumCsys">
            <summary>The enclosed NXOpen.Features.DatumCsys object</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature.DatumCsys</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.DatumCsysBuilder">
            <summary>The NXOpen.Features.DatumCsysBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.DatumCsys feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.DatumCsysBuilder">NXOpen.Features.DatumCsysBuilder</seealso>
        </member>
        <member name="P:Snap.NX.DatumCsys.Origin">
            <summary>The location of the origin of the coordinate system</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.Orientation">
            <summary>Orientation of coordinate system</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.Matrix">
            <summary>The NX.Matrix object referred to by the datum csys</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.AxisX">
            <summary>X-axis of datum csys</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.AxisY">
            <summary>Y-axis of datum csys</summary>
        </member>
        <member name="P:Snap.NX.DatumCsys.AxisZ">
            <summary>Z-axis of coordinate system</summary>
        </member>
        <member name="M:Snap.NX.DatumCsys.#ctor(NXOpen.Features.DatumCsys)">
            <summary> Constructor, given an NXOpen.Features.DatumCsys object</summary>
            <param name="datumCsys">An NXOpen.Features.DatumCsys object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumCsys.op_Implicit(NXOpen.Features.DatumCsys)~Snap.NX.DatumCsys">
            <summary>Implicit conversion of NXOpen.Features.DatumCsys to NX.DatumCsys</summary>
            <param name="datumCsys">The NXOpen.Features.DatumCsys to be converted (enclosed)</param>
            <returns>A new NX.DatumCsys object enclosing the given NXOpen.Features.DatumCsys</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumCsys.op_Implicit(Snap.NX.DatumCsys)~NXOpen.Features.DatumCsys">
            <summary>Implicit conversion of NX.DatumCsys to NXOpen.Features.DatumCsys</summary>
            <param name="datumAxis">The NX.DatumCsys to be converted</param>
            <returns>The NXOpen.Features.DatumCsys object enclosed by the given NX.DatumCsys</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumCsys.CreateDatumCsys(Snap.Position,Snap.NX.Matrix)">
            <summary>Creates a datum csys object</summary>
            <param name="origin">The origin of the csys</param>
            <param name="matrix">The orientation of the csys</param>
            <returns>An NX.DatumCsys object</returns>
        </member>
        <member name="M:Snap.NX.DatumCsys.CreateDatumCsys(Snap.Position,Snap.Vector,Snap.Vector)">
            <summary>Creates a datum csys object</summary>
            <param name="origin">The origin of the csys</param>
            <param name="axisX">The axis in x direction</param>
            <param name="axisY">The axis in y direction</param>
            <returns>An NX.DatumCsys object</returns>
        </member>
        <member name="M:Snap.NX.DatumCsys.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.DatumCsys tag to a Snap.NX.DatumCsys</summary>
            <param name="nxopenDatumCsysTag">The tag of an NXOpen.Features.DatumCsys object to be converted</param>
            <returns>The Snap.NX.DatumCsys object formed by wrapping the NXOpen.Features.DatumCsys having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.DatumCsys object</exception>
        </member>
        <member name="T:Snap.NX.DatumPlane">
            <summary>
            Represents a Snap.NX.DatumPlane object (interchangeable with <see cref="T:NXOpen.Features.DatumPlaneFeature">NXOpen.Features.DatumPlaneFeature</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.DatumPlane object, use the <see cref="O:Snap.Create.DatumPlane">Snap.Create.DatumPlane</see> functions.
            </para>
            <para>
            Note that there are two types of Datum Plane object in NX/Open: 
            NXOpen.DatumPlane and NXOpen.Features.DatumPlaneFeature. The Snap.NX.DatumPlane
            type corresponds most closely with the NXOpen.Features.DatumPlaneFeature type.
            </para>
            <para>
            If you just want to do some computations with a temporary plane, and you don't
            want to create a permanent object in your NX part file, then you should use a
            <see cref="T:Snap.Geom.Surface.Plane">Snap.Geom.Surface.Plane</see> object, instead.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.DatumPlane class:
            <code title="Properties of an NX.DatumPlane object: " lang="VB.NET" source="DatumPlane_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.DatumPlane">Snap.Create.DatumPlane</seealso>
            <seealso cref="T:Snap.Geom.Surface.Plane">Snap.Geom.Surface.Plane</seealso>
        </member>
        <member name="P:Snap.NX.DatumPlane.ObjectType">
            <summary>The type of the object</summary>
            <remarks>
            <para>
            This always returns NX.ObjectTypes.Type.DatumPlane.
            Note that this not the same as NXOpen.UF.UFConstants.UF_datum_plane_type.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.DatumPlane.NXOpenDatumPlaneFeature">
            <summary>The enclosed NXOpen.Features.DatumPlaneFeature object</summary>
        </member>
        <member name="P:Snap.NX.DatumPlane.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature.DatumPlane</summary>
            <remarks>
            <para>
            This array always has a single member, which is an NXOpen.DatumPlane object.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.DatumPlane.Normal">
            <summary>The normal vector of the datum plane</summary>
        </member>
        <member name="P:Snap.NX.DatumPlane.Origin">
            <summary>The origin of the datum plane</summary>
        </member>
        <member name="P:Snap.NX.DatumPlane.CornerPoints">
            <summary>The corner points the datum plane</summary>
        </member>
        <member name="P:Snap.NX.DatumPlane.DatumPlaneBuilder">
            <summary>The NXOpen.Features.DatumPlaneBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.DatumPlane feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.DatumPlaneBuilder">NXOpen.Features.DatumPlaneBuilder</seealso>
        </member>
        <member name="M:Snap.NX.DatumPlane.ReverseDirection">
            <summary>Reverse the direction of the plane. The default direction is the normal of the plane.</summary>
        </member>
        <member name="P:Snap.NX.DatumPlane.Translucency">
            <summary>The translucency of the feature</summary>
            <remarks>
            <para>
            The translucency value is an integer between 0 and 100. A value of 0 indicates that the
            object is completely opaque (no translucency at all). A value of 100 indicates that
            the object is completely translucent, and therefore invisible.
            </para>
            <para>
            You cannot set the translucency of a datum plane.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.DatumPlane.#ctor(NXOpen.Features.DatumPlaneFeature)">
            <summary> Constructor, given an NXOpen.Features.DatumPlaneFeature object</summary>
            <param name="datumPlaneFeature">An NXOpenFeatures.DatumPlaneFeature object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumPlane.op_Implicit(NXOpen.Features.DatumPlaneFeature)~Snap.NX.DatumPlane">
            <summary>Implicit conversion of NXOpen.Features.DatumPlaneFeature to NX.DatumPlane</summary>
            <param name="datumPlaneFeature">The NXOpen.Features.DatumPlaneFeature to be converted (enclosed)</param>
            <returns>A new NX.DatumPlane object enclosing the given NXOpen.Features.DatumPlaneFeature</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumPlane.op_Implicit(Snap.NX.DatumPlane)~NXOpen.Features.DatumPlaneFeature">
            <summary>Implicit conversion of NX.DatumPlane to NXOpen.Features.DatumPlaneFeature</summary>
            <param name="datumPlane">The NX.DatumPlane to be converted</param>
            <returns>The NXOpen.Features.DatumPlaneFeature object enclosed by the given NX.DatumPlane</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.DatumPlane.CreateDatumPlane(Snap.NX.ICurve,Snap.Number)">
            <summary>Creates a datum plane object at an arclength location on a curve</summary>
            <param name="curve">The curve (either a curve or an edge)</param>
            <param name="arcLength">The percent arclength from the start point to the specified position</param>
            <returns>An NX.DatumPlane object</returns>
        </member>
        <member name="M:Snap.NX.DatumPlane.CreateDatumPlane(Snap.Position,Snap.Vector)">
            <summary>Creates a datum plane from a point and a vector</summary>
            <param name="position">Position of the datum plane</param>
            <param name="direction">The normal vector of the datum plane</param>
            <returns>An NX.DatumPlane object</returns>
        </member>
        <member name="M:Snap.NX.DatumPlane.CreateDatumPlane(Snap.Position,Snap.Orientation)">
            <summary>Creates a datum plane from a point and an orientation</summary>
            <param name="origin">Origin of the datum plane</param>
            <param name="orientation">Orientation of the datum plane</param>
            <returns>An NX.DatumPlane object</returns>
        </member>
        <member name="M:Snap.NX.DatumPlane.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.DatumPlaneFeature tag to a Snap.NX.DatumPlane</summary>
            <param name="nxopenDatumPlaneTag">The tag of an NXOpen.Features.DatumPlaneFeature object to be converted</param>
            <returns>The Snap.NX.DatumPlane object formed by wrapping the NXOpen.Features.DatumPlaneFeature having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.DatumPlaneFeature object</exception>
        </member>
        <member name="T:Snap.NX.EdgeConvexity">
            <summary>Describes the convexity across an edge (the angle between the faces that meet at the edge)</summary>
            <remarks>
            <para>
            The picture below shows a cross-section of an extruded shape. The numbered red dots denote
            edges running into the screen.
            </para>
            <para>
            <img src="../Images/convexity.png"/>
            </para>
            <para>
            These edges have convexities as follows:
            <list type="bullet">
            <item>Edge E2 is Convex</item>
            <item>Edge E3 is Concave</item>
            <item>Edges E1,E4,E5,E7,E8,E9 are SmoothConvex</item>
            <item>Edge E6 is SmoothInflection</item>
            </list>
            </para>
            <para>
            When we say an edge is "smooth", we mean that the two adjacent faces
            have the same surface normals at points along the edge, so that they join smoothly.
            Some people would say that the junction is "G1" or "tangent plane continuous".
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.Convex">
            <summary>The edge is not smooth, and the material surrounding it spans less than 180 degrees.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.Concave">
            <summary>The edge is not smooth, and the material surrounding it spans more than 180 degrees.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.SmoothFlat">
            <summary>The edge is smooth, and the adjacent faces have zero curvature along the edge.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.SmoothConvex">
            <summary>The edge is smooth, and the adjacent faces are both convex along the edge.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.SmoothConcave">
            <summary>The edge is smooth, and the adjacent faces are both concave along the edge.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.SmoothInflection">
            <summary>The edge is smooth, and the adjacent faces have opposite convexity along the edge 
            (one is convex and the other is concave).</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.SmoothVariable">
            <summary>The edge is smooth, and the adjacent faces have different convexity properties at
            different points along the edge. </summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.KnifeConvex">
            <summary>The surface normals are anti-parallel and the sum of the curvatures is non-negative.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.KnifeConcave">
            <summary>The surface normals are anti-parallel and the sum of the curvatures is non-positive.</summary>
        </member>
        <member name="F:Snap.NX.EdgeConvexity.Variable">
            <summary>The convexity/concavity  varies along the edge. </summary>
        </member>
        <member name="T:Snap.NX.Edge">
            <summary>
            Represents a Snap.NX.Edge object (interchangeable with <see cref="T:NXOpen.Edge">NXOpen.Edge</see>)   
            </summary>
            <example> 
            This example shows how to use the properties of the NX.Edge class:
            <code title="Properties of an NX.Edge object: " lang="VB.NET" source="Edge_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Edge.NXOpenICurve">
            <summary>The enclosed NXOpen.ICurve object</summary>
        </member>
        <member name="P:Snap.NX.Edge.NXOpenEdge">
            <summary>The enclosed NXOpen.Edge object</summary>
        </member>
        <member name="P:Snap.NX.Edge.NXOpenDisplayableObject">
            <summary>The associated NXOpen.DisplayableObject of this NX.Edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.NXOpenTag">
            <summary>Get the NXOpen.Tag from this NX.Edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.PsTag">
            <summary>Get the Parasolid tag from this NX.Edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.PsEdge">
            <summary>Get the Parasolid edge from this NX.Edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.ObjectType">
            <summary>The type of the object</summary>
        </member>
        <member name="P:Snap.NX.Edge.ObjectSubType">
            <summary>The subtype of the edge</summary>
            <remarks>
            <para>
            The possible subtypes are
            <list type = "bullet">
            <item>EdgeLine</item>
            <item>EdgeArc</item>
            <item>EdgeCircle</item>
            <item>EdgeEllipse</item>
            <item>EdgeIntersection</item> 
            <item>EdgeSpline</item>
            <item>EdgeSpCurve</item>
            <item>EdgeIsoCurv</item>
            <item>EdgeUnknown</item>
            </list>
            </para>
            </remarks>
            <seealso cref= "T:Snap.NX.ObjectTypes.SubType">Snap.NX.ObjectTypes.SubType</seealso>
        </member>
        <member name="P:Snap.NX.Edge.Body">
            <summary>The body on which the edge lies</summary>
        </member>
        <member name="P:Snap.NX.Edge.Faces">
            <summary>The faces adjacent to the edge</summary>
            <remarks>
            <para>
            In most cases, there will be two faces adjacent to a given edge. But for "boundary" or
            "laminar" edges on a sheet body, there will be only one adjacent face.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.Shell">
            <summary>The shell that the edge belongs to</summary>
            <remarks>
            <para>
            In NX objects, an edge always belongs to exactly one shell.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.Fins">
            <summary>The fins of the edge</summary>
            <remarks>
            <para>
            An edge may have one or two fins. Every edge of a solid body has
            two fins, but a laminar edge of a sheet body will have only one fin.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.ArcLength">
            <summary>The arclength of the edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.StartPoint">
            <summary>The start point of the edge</summary>
            <remarks>
            <para>
            This is the point where the parameter u has the value MinU.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.EndPoint">
            <summary>The end point of the edge</summary>
            <remarks>
            <para>
            This is the point where the parameter u has the value MaxU.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.Box">
            <summary>The 3D box that encloses the edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.MinU">
            <summary>The lower u-value -- the parameter value at the start-point of the edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.MaxU">
            <summary>The upper u-value -- the parameter value at the end-point of the edge</summary>
        </member>
        <member name="P:Snap.NX.Edge.IsClosed">
            <summary>The closed state of edge</summary>
            <remarks>
            <para>
            An edge is closed if its start-point and end-point are the same.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.Vertices">
            <summary>Gets the vertices of the edge</summary>
            An edge may have zero, one, or two vertices. 
            Most edges have either zero or two vertices; edges with one vertex are fairly unusual.
            <para>
            If the edge has zero vertices, then this property will return an array of length zero.
            </para>
            <seealso cref= "T:Snap.Topology.Vertex">Snap.Topology.Vertex</seealso>
        </member>
        <member name="M:Snap.NX.Edge.Convexity(System.Double)">
            <summary>The convexity across this edge</summary>
            <param name="angleTolerance">Angular tolerance, in degrees</param>
            <returns>The convexity</returns>
            <remarks>
            <para>
            The angular tolerance is used when deciding whether or not the edge is smooth.
            </para>
            </remarks>
            <example> 
            This example shows how to find sharp concave edges:
            <code title="Finding sharp concave edges" lang="VB.NET" source="EdgeConvexity_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Edge.Plane">
            <summary>A plane containing the given edge</summary>
            <remarks>
            <para>
            This function returns <c>Nothing</c> if the edge is linear (in which case its plane
            is not well-defined), or if the edge is not planar.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.Factor">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapValue = nxopenValue * Factor</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenValue = snapValue / Factor</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Edge.Prototype">
            <summary>
            Returns the prototype edge of this edge (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the edge is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Edge.#ctor(NXOpen.Edge)">
            <summary>Constructor, given an NXOpen.Edge object</summary>
            <param name="nxopenEdge">An NXOpen.Edge object</param>
            <remarks>
            <para>
            The constructor is protected to encourage callers to use CreateEdge, 
            instead, since this ensures proper downcasting.
            The only callers should be constructors for derived classes.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Edge.CreateEdge(NXOpen.Edge)">
            <summary>
            Creates a Snap.NX.Edge object of the most specific type possible
            </summary>
            <param name="nxopenEdge">The input NXOpen.Edge</param>
            <returns>A Snap.NX.Edge object that has the most specific type possible</returns>
            <remarks>
            <para>
            The returned edge's static type is still Snap.NX.Edge, but, where
            possible, the NX.Edge variable now contains an edge object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller. This is used in Selection, for example.
            </para>
            <para>
            This function should be used instead of the NX.Edge constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Edge.op_Implicit(NXOpen.Edge)~Snap.NX.Edge">
            <summary>Implicit conversion of NXOpen.Edge to NX.Edge</summary>
            <param name="edge">The NXOpen.Edge to be converted (enclosed)</param>
            <returns>A new NX.Edge object enclosing the given NXOpen.Edge</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Edge.op_Implicit(Snap.NX.Edge)~NXOpen.Edge">
            <summary>Implicit conversion of NX.Edge to NXOpen.Edge</summary>
            <param name="edge">The NX.Edge to be converted</param>
            <returns>The NXOpen.Edge object enclosed by the given NX.Edge</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Edge.Position(System.Double)">
            <summary>Calculates a point on the edge at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Point corresponding to the given parameter value</returns>
            <remarks>
            <para>
            If you want to calculate several points on an edge, the 
            <see cref= "O:Snap.NX.Edge.PositionArray">PositionArray</see>
            functions might be more useful.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Edge.Derivative(System.Double)">
            <summary>Calculates the first derivative vector on the edge at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>First derivative vector (not unitized)</returns>
            <remarks>
            <para>
            The vector returned is usually not a unit vector. In fact, it may even have zero length.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Edge.Derivatives(System.Double,System.Int32)">
            <summary>Calculates edge derivatives (and position) at a given parameter value</summary>
            <param name="value">Parameter at which to evaluate</param>
            <param name="order">Order of highest derivative returned (zero for position alone)</param>
            <returns>Array of derivative vectors -- [0] is position, [1] is first derivative, etc.</returns>      
        </member>
        <member name="M:Snap.NX.Edge.Tangent(System.Double)">
            <summary>Calculates the unit tangent vector at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit tangent vector</returns>
            <remarks>
            <para>
            The function calculates a unit tangent vector even in those (rare) cases where
            the derivative vector of the curve has zero length.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Edge.Normal(System.Double)">
            <summary>Calculates unit normal at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit normal vector</returns>
            <remarks>
            <para>
            The normal lies in the "osculating plane" of the curve at the given parameter value
            (the plane that most closely matches the curve). So, if the curve is planar, the normal always
            lies in the plane of the curve.
            </para>
            <para>
            The normal always points towards the center of curvature of the curve. So, if the curve
            has an inflexion, the normal will flip from one side to the other, which may be undesirable.
            </para>
            <para>
            The normal is the cross product of the binormal and the tangent: N = B*T
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Edge.Binormal(System.Double)">
            <summary>Calculates the unit binormal at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit binormal</returns>
            <remarks>
            <para>
            The binormal is normal to the "osculating plane" of the curve at the given parameter value
            (the plane that most closely matches the curve). So, if the curve is planar, the binormal 
            is normal to the plane of the curve.
            </para>
            <para>
            The binormal is the cross product of the tangent and the normal: B = Cross(T,N).
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Edge.Curvature(System.Double)">
            <summary>Calculates curvature at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Curvature value (always non-negative)</returns>      
            <remarks>
            <para>
            Curvature is the reciprocal of radius of curvature. So, on a straight line,
            curvature is zero and radius of curvature is infinite. On a circle of radius 5,
            curvature is 0.2 (and radius of curvature is 5, of course).
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Edge.Parameter(Snap.Position)">
            <summary>Calculates the parameter value at a point on the edge</summary>
            <param name="point">The point</param>
            <returns>Parameter value at the point</returns>
        </member>
        <member name="M:Snap.NX.Edge.Parameter(System.Double,System.Double)">
            <summary>Calculates the parameter value defined by an arclength step along an edge</summary>
            <param name="baseParameter">The curve parameter value at the starting location</param>
            <param name="arclength">The arclength increment along the edge (the length of our step)</param>
            <returns>The curve parameter value at the far end of the step</returns>
            <remarks>
            <para>
            This function returns the curve parameter value at the far end of a "step" along an edge.
            The start of the step is defined by a given parameter value, and the size of the step is given
            by an arclength along the edge. The arclength step may be positive or negative.
            </para>
            </remarks>
            <example> 
            This example shows how to compute parameter increment:
            <code title="Compute parameter increment" lang="VB.NET" source="Parameter_02.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Edge.Parameter(System.Double)">
            <summary>Calculates the parameter value at a fractional arclength value along an edge</summary>
            <param name="arclengthFraction">Fractional arclength along the edge</param>
            <returns>Parameter value</returns>
            <remarks>
            <para>
            The input is a fractional arclength. A value of 0 corresponds to the start of the edge,
            a value of 1 corresponds to the end-point, and values between 0 and 1 correspond to
            interior points along the edge.
            </para>
            <para>
            You can input arclength values outside the range 0 to 1, and this will return parameter
            values corresponding to points on the extension of the edge.
            </para>
            </remarks>
            <example> 
            This example shows how to compute parameter:
            <code title="Compute parameter" lang="VB.NET" source="Parameter_03.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Edge.ToSpline">
            <summary>Creates a spline that replicates the edge</summary>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
            <remarks>
            <para>
            If the edge is a line, arc, ellipse, or spline, the conversion is exact. But, in this
            case, it will probably be more convenient to use the 
            <see cref= "M:Snap.NX.Edge.Line.ToLine">ToLine</see>, 
            <see cref= "M:Snap.NX.Edge.Arc.ToArc">ToArc</see>, or
            <see cref= "M:Snap.NX.Edge.Ellipse.ToEllipse">ToEllipse</see> functions.
            </para>
            <para>
            If the edge is of type intersection curve, then the spline is an approximation,
            with accuracy controlled by 
            <see cref= "P:Snap.Globals.DistanceTolerance">Snap.Globals.DistanceTolerance</see> and 
            <see cref= "P:Snap.Globals.AngleTolerance">Snap.Globals.AngleTolerance</see>.
            </para>
            <para>
            If you want to convert a string of curves or edges into a spline, please use the
            <see cref= "M:Snap.Create.JoinCurves(Snap.NX.ICurve[])">Snap.Create.JoinCurves</see> function, instead.
            </para>
            </remarks>
            <example>
            This example shows how to create splines from edges:
            <code title="Convert edge to a spline" lang="VB.NET" source="ToSpline_03.vb">
            </code>
            </example>
            <seealso cref="T:Snap.NX.Spline">Snap.NX.Spline</seealso>
            <seealso cref="M:Snap.NX.Curve.ToSpline">Snap.NX.Curve.ToSpline</seealso>
            <seealso cref= "M:Snap.NX.Edge.Line.ToLine">Snap.NX.Edge.Line.ToLine</seealso> 
            <seealso cref= "M:Snap.NX.Edge.Arc.ToArc">Snap.NX.Edge.Arc.ToArc</seealso>
            <seealso cref= "M:Snap.NX.Edge.Ellipse.ToEllipse">Snap.NX.Edge.Ellipse.ToEllipse</seealso>
            <seealso cref="M:Snap.Create.JoinCurves(Snap.NX.ICurve[])">Snap.Create.JoinCurves</seealso>
            <seealso cref="M:Snap.Create.ExtractCurve(Snap.NX.Edge[])">Snap.Create.ExtractCurve</seealso>
        </member>
        <member name="M:Snap.NX.Edge.ToCurve">
            <summary>Creates a curve that replicates the edge</summary>
            <returns>A <see cref="T:Snap.NX.Curve">Snap.NX.Curve</see> object</returns>
            <remarks>
            <para>
            If the edge is a line, arc, ellipse, or spline, the conversion is exact,
            and a curve of the correct type is returned.
            </para>
            <para>
            If the edge is of type intersection curve, then the returned curve is a spline approximation,
            with accuracy controlled by 
            <see cref= "P:Snap.Globals.DistanceTolerance">Snap.Globals.DistanceTolerance</see> and 
            <see cref= "P:Snap.Globals.AngleTolerance">Snap.Globals.AngleTolerance</see>.
            </para>
            <para>
            In many situations, there is no need to create a curve replicating the edge.
            You can just use the edge itself directly, instead.
            </para>
            </remarks>
            <example>
            This example shows how to create curves from edges:
            <code title="Create curves from edges" lang="VB.NET" source="ToCurve_01.vb">
            </code>
            </example>
            <seealso cref= "M:Snap.NX.Edge.Line.ToLine">Snap.NX.Edge.Line.ToLine</seealso> 
            <seealso cref= "M:Snap.NX.Edge.Arc.ToArc">Snap.NX.Edge.Arc.ToArc</seealso>
            <seealso cref= "M:Snap.NX.Edge.Ellipse.ToEllipse">Snap.NX.Edge.Ellipse.ToEllipse</seealso>
            <seealso cref="M:Snap.Create.ExtractCurve(Snap.NX.Edge[])">Snap.Create.ExtractCurve</seealso>
        </member>
        <member name="M:Snap.NX.Edge.PositionArray(System.Int32)">
            <summary>Calculates an arrays of positions at equal arclengths on an edge</summary>
            <param name="pointCount">The number of positions to be calculated on the edge</param>
            <returns>An array of positions on the edge</returns>
            <example> 
            This example shows how to compute positions at equal arclengths on an edge : 
            <code title="Compute position array" lang="VB.NET" source="PositionArray_04.vb">
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Edge.PositionArray(System.Double)">
            <summary>Calculates an array of positions on an edge corresponding to a given chord-height tolerance</summary>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <remarks>
            <para>
            A chord is the straight line between adjacent positions on the edge. 
            The chord-height tolerance is the maximum allowable distance between a chord and the edge itself.
            </para>
            </remarks>
            <returns>An array of positions on the edge</returns>
            <example> 
            This example shows how to compute a position array with a given chord-height tolerance: 
            <code title="Create position array" lang="VB.NET" source="PositionArray_05.vb"> 
            </code>
            </example>      
        </member>
        <member name="M:Snap.NX.Edge.PositionArray(System.Double,System.Double,System.Double)">
            <summary>Calculates an array of positions on an edge corresponding to given tolerances</summary>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <param name="angularTolerance">The angular tolerance (in degrees)</param>
            <param name="stepTolerance">The chord-length tolerance</param>
            <returns>An array of positions on the edge</returns>
            <remarks>
            <para>
            A chord is a straight line between adjacent positions. 
            The tolerances provide independent values for controlling the positions located along the edge.
            <list type = "bullet">
            <item>The chord-height tolerance is the maximum allowable distance between chords and the edge. This is the distance D in the picture below.</item>
            <item>The angular tolerance is the maximum allowable sum of the angles between the chord and the tangents to the edge at the ends of the chord. This is the sum A1+A2
            in the picture below.</item>
            <item>The chord-length tolerance is the maximum allowable length of the chords, which is distance D in the picture.</item>
            </list>
            The following picture shows the meanings of the three tolerances:
            </para>
            <para>
            <img src="../Images/PositionArray_03.jpg"/>
            </para>
            If any of the input tolerances is zero, it is ignored, so it has no effect.
            Otherwise, the output positions will satisfy all the given tolerances.
            Note that the maximum values specified in the tolerances may not be attained;
            we only guarantee that they will not be exceeded.
            </remarks> 
            <example>
            This example shows how to compute an array of positions on an edge: 
            <code title="Compute array of positions" lang="VB.NET" source="PositionArray_06.vb"> 
            </code>
            </example>
        </member>
        <member name="M:Snap.NX.Edge.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Edge tag to a Snap.NX.Edge</summary>
            <param name="nxopenEdgeTag">The tag of an NXOpen.Edge object to be converted</param>
            <returns>The Snap.NX.Edge object formed by wrapping the NXOpen.Edge having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Edge object</exception>
        </member>
        <member name="M:Snap.NX.Edge.GetEdgeData(Snap.NX.Edge,System.Double@,System.Double@,System.Double@,Snap.Position@,Snap.Vector@,Snap.Vector@)">
            <summary>Only used for edge of arc type</summary>
        </member>
        <member name="M:Snap.NX.Edge.GetEdgeData(Snap.NX.Edge,Snap.Position@,Snap.Position@)">
            <summary>Only used for edge of line type</summary>
        </member>
        <member name="M:Snap.NX.Edge.GetEdgeData(Snap.NX.Edge,Snap.Position[]@,System.Double[]@,System.Double[]@)">
            <summary>Only used for edge of spline type</summary>
        </member>
        <member name="M:Snap.NX.Edge.GetEdgeData(Snap.NX.Edge,Snap.Position@,Snap.Vector@,Snap.Vector@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Only used for edge of ellipse type</summary>
        </member>
        <member name="M:Snap.NX.Edge.PointSet(Snap.NX.Edge,System.Double,System.Double,System.Double)">
            <summary>Calculates an array of positions on an edge corresponding to given tolerances</summary>
            <param name="edge">An NX.Edge object</param>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <param name="angularTolerance">The angular tolerance (in degrees)</param>
            <param name="stepTolerance">The chord-length tolerance</param>
            <returns>An array of positions on the edge</returns>
        </member>
        <member name="M:Snap.NX.Edge.PointSet(Snap.NX.Edge,System.Int32)">
            <summary>Calculates an arrays of positions at equal arclengths on an edge</summary>
            <param name="edge">An NX.Edge object</param>
            <param name="pointCount">The number of positions to be calculated on the edge</param>
            <returns>An array of positions on the edge</returns>
        </member>
        <member name="M:Snap.NX.Edge.FixPoints(Snap.NX.Edge,Snap.Position[])">
            <summary>Projects points back onto an edge, if badly calculated by NX functions</summary>
            <param name="edge">Edge that pts are supposed to lie on</param>
            <param name="badPts">Bad points</param>
            <returns>Good points, projected back to edge</returns>
        </member>
        <member name="M:Snap.NX.Edge.GetEdgeType(Snap.NX.Edge)">
            <summary>Utility function that maps NX edge subtypes to Snap edge subtypes</summary>
            <param name="snapEdge">Snap.NX.Edge object</param>
            <returns>Snap.NX.ObjectTypes.SubType of edge</returns>
        </member>
        <member name="T:Snap.NX.Edge.Arc">
            <summary>Represents a Snap.NX.Edge.Arc object</summary>
            <example> 
            This example shows how to use the properties of the NX.Edge.Arc class: 
            <code title="NX.Edge.Arc properties" lang="VB.NET" source="GeomArc_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Edge.Arc.#ctor(Snap.NX.Edge)">
            <summary>Constructor, given an NX.Edge object</summary>
            <param name="edge">An NX.Edge object</param>
        </member>
        <member name="M:Snap.NX.Edge.Arc.#ctor(NXOpen.Edge)">
            <summary>Constructor, given an NXOpen.Edge object</summary>
            <param name="nxopenEdge">An NXOpen.Edge object</param>
        </member>
        <member name="P:Snap.NX.Edge.Arc.Geometry">
            <summary>Geometry data of the edge</summary>
        </member>
        <member name="M:Snap.NX.Edge.Arc.ToArc">
            <summary>
            Creates an arc that replicates the edge
            </summary>
            <returns>A <see cref= "T:Snap.NX.Arc">Snap.NX.Arc</see> object</returns>
            <remarks>
            <para>
            In many situations, you do not need to create an arc replicating the edge.
            You can just use the edge itself directly, instead.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Edge.Arc.Factor">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapValue = nxopenValue * Factor</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenValue = snapValue / Factor</para>
            </remarks>
            <exclude/>
        </member>
        <member name="T:Snap.NX.Edge.Line">
            <summary>Represents a Snap.NX.Edge.Line object</summary>      
            <example> 
            This example shows how to use the properties of the NX.Edge.Line class: 
            <code title="NX.Edge.Line properties" lang="VB.NET" source="GeomLine_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Edge.Line.#ctor(Snap.NX.Edge)">
            <summary>Constructor, given an NX.Edge object</summary>
            <param name="edge">An NX.Edge object</param>
        </member>
        <member name="M:Snap.NX.Edge.Line.#ctor(NXOpen.Edge)">
            <summary>Constructor, given an NXOpen.Edge object</summary>
            <param name="nxopenEdge">An NXOpen.Edge object</param>
        </member>
        <member name="P:Snap.NX.Edge.Line.Geometry">
            <summary>Geometry data of the edge</summary>
        </member>
        <member name="M:Snap.NX.Edge.Line.ToLine">
            <summary>
            Creates a line that replicates the edge
            </summary>
            <returns>A <see cref= "T:Snap.NX.Line">Snap.NX.Line</see> object</returns>
            <remarks>
            <para>
            In many situations, you do not need to create a line replicating the edge.
            You can just use the edge itself directly, instead.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Edge.Spline">
            <summary>Represents a Snap.NX.Edge.Spline object</summary>      
            <example> 
            This example shows how to use the properties of the NX.Edge.Spline class: 
            <code title="NX.Edge.Spline properties" lang="VB.NET" source="GeomSpline_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Edge.Spline.#ctor(NXOpen.Edge)">
            <summary>Constructor, given an NXOpen.Edge object</summary>
            <param name="nxopenEdge">An NXOpen.Edge object</param>
        </member>
        <member name="P:Snap.NX.Edge.Spline.Geometry">
            <summary>Geometry data of the edge</summary>
        </member>
        <member name="T:Snap.NX.Edge.Ellipse">
            <summary>Represents a Snap.NX.Edge.Ellipse object</summary>      
            <example> 
            This example shows how to use the properties of the NX.Edge.Ellipse class: 
            <code title="NX.Edge.Spline properties" lang="VB.NET" source="GeomEllipse_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Edge.Ellipse.#ctor(Snap.NX.Edge)">
            <summary>Constructor, given an NX.Edge object</summary>
            <param name="edge">An NX.Edge object</param>
        </member>
        <member name="M:Snap.NX.Edge.Ellipse.#ctor(NXOpen.Edge)">
            <summary>Constructor, given an NXOpen.Edge object</summary>
            <param name="nxopenEdge">An NXOpen.Edge object</param>
        </member>
        <member name="P:Snap.NX.Edge.Ellipse.Geometry">
            <summary>Geometry data of the edge</summary>
        </member>
        <member name="M:Snap.NX.Edge.Ellipse.ToEllipse">
            <summary>
            Creates an ellipse that replicates the edge
            </summary>
            <returns>A <see cref= "T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> object</returns>
            <remarks>
            <para>
            In many situations, you do not need to create an ellipse replicating the edge.
            You can just use the edge itself directly, instead.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.EdgeBlend">
            <summary>
            Represents a Snap.NX.EdgeBlend feature (interchangeable with <see cref="T:NXOpen.Features.EdgeBlend">NXOpen.Features.EdgeBlend</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.EdgeBlend object, use the <see cref="M:Snap.Create.EdgeBlend(Snap.Number,Snap.NX.Edge[])">Snap.Create.EdgeBlend</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to create object of this class:
            <code title="Create object of this class: " lang="VB.NET" source="EdgeBlend_01.vb">
            </code> 
            </example>
            <seealso cref="M:Snap.Create.EdgeBlend(Snap.Number,Snap.NX.Edge[])">Snap.Create.EdgeBlend</seealso>
        </member>
        <member name="P:Snap.NX.EdgeBlend.NXOpenEdgeBlend">
            <summary>The enclosed <see cref="T:NXOpen.Features.EdgeBlend">NXOpen.Features.EdgeBlend</see> object</summary>
        </member>
        <member name="P:Snap.NX.EdgeBlend.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature.EdgeBlend</summary>
        </member>
        <member name="P:Snap.NX.EdgeBlend.EdgeBlendBuilder">
            <summary>The NXOpen.Features.EdgeBlendBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.EdgeBlend feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.EdgeBlendBuilder">NXOpen.Features.EdgeBlendBuilder</seealso>
        </member>
        <member name="P:Snap.NX.EdgeBlend.Radius">
            <summary>The radius of the blend</summary>
        </member>
        <member name="M:Snap.NX.EdgeBlend.#ctor(NXOpen.Features.EdgeBlend)">
            <summary> Constructor, given an NXOpen.Features.EdgeBlend object</summary>
            <param name="edgeBlend">An NXOpen.Features.EdgeBlend object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.EdgeBlend.op_Implicit(NXOpen.Features.EdgeBlend)~Snap.NX.EdgeBlend">
            <summary>Implicit conversion of NXOpen.Features.EdgeBlend to NX.EdgeBlend</summary>
            <param name="edgeBlend">The NXOpen.Features.EdgeBlend to be converted (enclosed)</param>
            <returns>A new NX.EdgeBlend object enclosing the given NXOpen.Features.EdgeBlend</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.EdgeBlend.op_Implicit(Snap.NX.EdgeBlend)~NXOpen.Features.EdgeBlend">
            <summary>Implicit conversion of NX.EdgeBlend to NXOpen.Features.EdgeBlend</summary>
            <param name="edgeBlend">The NX.EdgeBlend to be converted</param>
            <returns>The NXOpen.Features.EdgeBlend object enclosed by the given NX.EdgeBlend</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.EdgeBlend.CreateEdgeBlend(Snap.Number,Snap.NX.Edge[])">
            <summary>Creates an edge blend object</summary>
            <param name="edges">Edge array used to blend</param>
            <param name="radius">Radius of a regular blend</param>
            <returns>An NX.EdgeBlend object</returns>
        </member>
        <member name="M:Snap.NX.EdgeBlend.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.EdgeBlend tag to a Snap.NX.EdgeBlend</summary>
            <param name="nxopenEdgeBlendTag">The tag of an NXOpen.Features.EdgeBlend object to be converted</param>
            <returns>The Snap.NX.EdgeBlend object formed by wrapping the NXOpen.Features.EdgeBlend having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.EdgeBlend object</exception>
        </member>
        <member name="T:Snap.NX.Ellipse">
            <summary>
            Represents a Snap.NX.Ellipse object (interchangeable with <see cref="T:NXOpen.Ellipse">NXOpen.Ellipse</see>)   
            </summary>
            <remarks>
            <para>
            To create an NX.Ellipse object, use the <see cref="O:Snap.Create.Ellipse">Snap.Create.Ellipse</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to create an ellipse:
            <code title="Create object of this class: " lang="VB.NET" source="Ellipse_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Ellipse">Snap.Create.Ellipse</seealso>
        </member>
        <member name="P:Snap.NX.Ellipse.NXOpenEllipse">
            <summary>The enclosed NXOpen.Ellipse object</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.ObjectSubType">
            <summary>Subtypes of NX Ellipse</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.RadiusX">
            <summary>The half-width of the ellipse in its X-direction</summary>
            <remarks>
            <para>
            This is the "a" parameter in the standard ellipse equation 
            <c>(x^2)/(a^2) + (y^2)/(b^2) = 1</c>.
            </para>
            <para>
            It is sometimes known as the "major" radius, but this name is somewhat misleading since 
            it is not necessarily true that RadiusX &gt; RadiusY.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Ellipse.RadiusY">
            <summary>The half-width of the ellipse in its Y-direction</summary>
            <remarks>
            <para>
            This is the "b" parameter in the standard ellipse equation 
            <c>(x^2)/(a^2) + (y^2)/(b^2) = 1</c>.      
            </para>
            <para>
            It is sometimes known as the "minor" radius, but this name is somewhat misleading since 
            it is not necessarily true that RadiusY &lt; RadiusX.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Ellipse.Center">
            <summary> Center of ellipse (in absolute coordinates)</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.AxisX">
            <summary>A unit vector along the X-axis of the ellipse (where angle = 0)</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.AxisY">
            <summary>A unit vector along the Y-axis of the ellipse (where angle = 90)</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.AxisZ">
            <summary>A unit vector along the Z-axis of the ellipse (normal to the plane of the ellipse)</summary>
            <remarks>
            <para>
            The AxisZ is the cross product AxisX x AxisY. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Ellipse.Orientation">
            <summary>The orientation of the ellipse</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.Matrix">
            <summary>The Matrix of the ellipse (a reference to an NX.Matrix object)</summary>
        </member>
        <member name="P:Snap.NX.Ellipse.StartAngle">
            <summary>Start angle (in degrees) </summary>
            <remarks>
            <para>
            This is the polar angle of the start-point of the curve, which is not the same as MinU.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Ellipse.EndAngle">
            <summary>End angle (in degrees) </summary>
            <remarks>
            <para>
            This is the polar angle of the end-point of the curve, which is not the same as MaxU.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Ellipse.Factor">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapValue = nxopenValue * Factor</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenValue = snapValue / Factor</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Ellipse.Prototype">
            <summary>
            Returns the prototype ellipse of this one (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if this ellipse is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Ellipse.#ctor(NXOpen.Ellipse)">
            <summary> Constructor, given an NXOpen.Ellipse object</summary>
            <param name="ellipse">An NXOpen.Ellipse object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Ellipse.op_Implicit(NXOpen.Ellipse)~Snap.NX.Ellipse">
            <summary>Implicit conversion of NXOpen.Ellipse to NX.Ellipse</summary>
            <param name="ellipse">The NXOpen.Ellipse to be converted (enclosed)</param>
            <returns>A new NX.Ellipse object enclosing the given NXOpen.Ellipse</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Ellipse.op_Implicit(Snap.NX.Ellipse)~NXOpen.Ellipse">
            <summary>Implicit conversion of NX.Ellipse to NXOpen.Ellipse</summary>
            <param name="ellipse">The NX.Ellipse to be converted</param>
            <returns>The NXOpen.Ellipse object enclosed by the given NX.Ellipse</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Ellipse.CreateEllipse(Snap.Position,Snap.Vector,Snap.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates an NX.Ellipse from center, axes, radius, angles in degrees</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisX">Unit vector along X-axis (where angle = 0)</param>
            <param name="axisY">Unit vector along Y-axis (where angle = 90)</param>
            <param name="a">The major radius</param>
            <param name="b">The minor radius</param>
            <param name="angle1">Start angle (in degrees)</param>
            <param name="angle2">End angle (in degrees)</param>
            <returns>An NX.Ellipse object</returns>
        </member>
        <member name="M:Snap.NX.Ellipse.Copy">
            <summary>Copies an NX.Ellipse (with a null transform)</summary>
            <returns>A copy of the input ellipse</returns>
            <remarks>
            <para>
            The new ellipse will be on the same layer as the original one. 
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Ellipse.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Ellipse</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Ellipse</returns>   
            <exception cref="T:System.ArgumentException">The transform would convert the ellipse to an arc. Please use Curve.Copy instead</exception>
        </member>
        <member name="M:Snap.NX.Ellipse.Copy(Snap.NX.Ellipse[])">
            <summary>Copies an array of NX.Ellipse (with no transform)</summary>
            <param name="original">Original NX.Ellipse array</param>
            <returns>A copy of the input ellipses</returns>
            <remarks>
            <para>
            The new ellipses will be on the same layers as the original ones.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Ellipse.Copy(Snap.Geom.Transform,Snap.NX.Ellipse[])">
            <summary>Transforms/copies an array of NX.Ellipse objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Ellipse array</param>
            <returns>A copy of the input ellipses</returns>
            <exception cref="T:System.ArgumentException">The transform would convert the ellipse to an arc. Please use Curve.Copy instead</exception>
        </member>
        <member name="M:Snap.NX.Ellipse.Trim(System.Double,System.Double)">
            <summary>Trim an ellipse to a parameter interval</summary>
            <param name="lowerParam">The lower-limit parameter value</param>
            <param name="upperParam">The upper-limit parameter value</param>
            <example> 
            This example shows how to trim an ellipse:
            <code title="Trim an ellipse" lang="VB.NET" source="TrimCurve_03.vb">
            </code>
            </example>
            <seealso cref="O:Snap.NX.Ellipse.Divide">Snap.NX.Ellipse.Divide</seealso>
        </member>
        <member name="M:Snap.NX.Ellipse.Divide(System.Double[])">
            <summary>Divide an ellipse at an array of parameter values</summary>
            <param name="parameters">The parameter values at which the ellipse should be divided</param>
            <returns>An array of <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> objects</returns>
            <remarks>The function will create new ellipses by dividing the original one.</remarks>
            <example> 
            This example shows how to divide an ellipse: 
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_06.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Ellipse.Trim(System.Double,System.Double)">Snap.NX.Ellipse.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Ellipse.Divide(Snap.NX.ICurve,Snap.Position)">
            <summary>Divide an ellipse at an intersection with another curve</summary>
            <param name="boundingCurve">Bounding curve to be used to divide the given ellipse</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> objects</returns>
            <remarks>The function will create two new ellipses by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Ellipse.Trim(System.Double,System.Double)">Snap.NX.Ellipse.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Ellipse.Divide(Snap.NX.Face,Snap.Position)">
            <summary>Divide an ellipse at an intersection with a given face</summary>
            <param name="face">A face to be used to divide the given ellipse</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> objects</returns>
            <remarks>The function will create two new ellipses by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Ellipse.Trim(System.Double,System.Double)">Snap.NX.Ellipse.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Ellipse.Divide(Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Divide an ellipse at an intersection with a given plane</summary>
            <param name="geomPlane">A plane to be used to divide the given ellipse</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Ellipse">Snap.NX.Ellipse</see> objects</returns>
            <remarks>The function will create two new ellipses by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Ellipse.Trim(System.Double,System.Double)">Snap.NX.Ellipse.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Ellipse.EllipseArray(Snap.NX.Curve[])">
            To avoid having four identical copies of the same code
        </member>
        <member name="M:Snap.NX.Ellipse.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Ellipse tag to a Snap.NX.Ellipse</summary>
            <param name="nxopenEllipseTag">The tag of an NXOpen.Ellipse object to be converted</param>
            <returns>The Snap.NX.Ellipse object formed by wrapping the NXOpen.Ellipse having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Ellipse object</exception>
        </member>
        <member name="T:Snap.NX.Expression">
            <summary>
            Represents an expression object (interchangeable with <see cref="T:NXOpen.Expression">NXOpen.Expression</see>)   
            </summary>
            <remarks>
            <para>
            An Expression consists of an "equation" that has three parts:
            <list type = "bullet">
            <item>The "Name" -- the portion before the equals sign (i.e. the left-hand side)</item>
            <item>The "RightHandSide" -- the portion after the equals sign but before the comment</item>
            <item>The "Comment" -- the portion following the characters "//", up until the end of the equation</item>
            </list>
            </para>
            <para>
            So, for example, if the entire equation is 
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0; <c>area = pi*r*r // Calculate the area</c>
            </para>
            <para>
            then the three parts are:   
            </para>
            <list type = "bullet">
            <item>Name: "<c>area</c>"</item>
            <item>RightHandSide: "<c>pi*r*r"</c></item>
            <item>Comment: "<c>Calculate the area</c>"</item>
            </list>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            <para>
            To find all the expressions in a part, use its <see cref="P:Snap.NX.Part.Expressions">Expressions</see> collection.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Expression class:
            <code title="Properties of an NX.Expression object: " lang="VB.NET" source="Expression_07.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
            <seealso cref="P:Snap.NX.Part.Expressions">Snap.NX.Part.Expressions</seealso>
        </member>
        <member name="P:Snap.NX.Expression.Comment">
            <summary>The comment of the expression (the portion after "//")</summary>
        </member>
        <member name="P:Snap.NX.Expression.Descriptor">
            <summary>The descriptor for the expression, or <c>Nothing</c> if there is no descriptor</summary>
            <remarks>
            <para>
            Only an expression that serves as a feature parameter will have a descriptor. The descriptor
            indicates which feature parameter the expression controls. For example, a cylinder typically has
            an expression controlling its diameter, which might be listed in the Expression
            dialog as <c>p26 (Cylinder(7) Diameter)</c>. Here, "<c>Diameter</c>" is the Descriptor.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Expression.Equation">
            <summary>The entire expression, including name, right-hand-side, and comment</summary>
        </member>
        <member name="P:Snap.NX.Expression.IsGeometricExpression">
            <summary>If True, indicates that the expression is a geometric expression</summary>
        </member>
        <member name="P:Snap.NX.Expression.IsMeasurementExpression">
            <summary>If True, indicates that the expression is owned by a measurement</summary>
        </member>
        <member name="P:Snap.NX.Expression.IsUserLocked">
            <summary>If True, indicates that the expression is user locked</summary>
            <remarks>
            <para>
            If this property is False, then the expression can be over-ridden from another
            part. This is the default state for newly created expressions. If this
            property is True, you are not allowed to over-ride it.
            Note that if an expression is currently over-ridden, you cannot set its lock
            property. In this instance, an exception will be thrown.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Expression.OwningFeature">
            <summary>The feature that created the expression</summary>
            <remarks>
            <para>
            This is the feature whose creation caused the creation of the expression. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Expression.UsingFeatures">
            <summary>The array of features that use the expression</summary>
            <returns>Array of features, or empty array</returns>
        </member>
        <member name="P:Snap.NX.Expression.Name">
            <summary>The name of the expression (the portion before the equals sign)</summary>
        </member>
        <member name="P:Snap.NX.Expression.NXOpenTag">
            <summary>The NXOpen.Tag of the enclosed NXOpen.Expression object</summary>
        </member>
        <member name="P:Snap.NX.Expression.RightHandSide">
            <summary>The right hand side of the expression</summary>
            <remarks>
            <para>
            Note that setting the RightHandSide property will
            also change the Value property.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Expression.Type">
            <summary>The type of the expression</summary>
        </member>
        <member name="P:Snap.NX.Expression.NXOpenExpression">
            <summary>The enclosed NXOpen.Expression object</summary>
        </member>
        <member name="M:Snap.NX.Expression.#ctor(NXOpen.Expression)">
            <summary>Constructs an NX.Expression object from an NXOpen.Expression</summary>
            <summary>Internal constructor to create an expression</summary>
            <param name="expresssion">An NX.Expression object</param>
        </member>
        <member name="M:Snap.NX.Expression.#ctor">
            <summary>Default parameterless constructor, to support inheritance</summary>
            <exclude/>
        </member>
        <member name="F:Snap.NX.Expression.nxopenExpression">
            <summary>The enclosed NXOpen.TaggedObject object</summary>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Expression.op_Implicit(NXOpen.Expression)~Snap.NX.Expression">
            <summary>Implicit conversion of NXOpen.Expression to NX.Expression</summary>
            <param name="expression">The NXOpen.Expression to be converted (enclosed)</param>
            <returns>A new NX.Expression object enclosing the given NXOpen.Expression</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Expression.op_Implicit(Snap.NX.Expression)~NXOpen.Expression">
            <summary>Implicit conversion of NX.Expression to NXOpen.Expression</summary>
            <param name="expression">The NX.Expression to be converted</param>
            <returns>The NXOpen.Expression object enclosed by the given NX.Expression</returns>
            <exclude/>
        </member>
        <member name="T:Snap.NX.Expression.ExpressionType">
            <summary>The type of the expression</summary>
        </member>
        <member name="F:Snap.NX.Expression.ExpressionType.Boolean">
            <summary>Boolean-valued expression</summary>
        </member>
        <member name="F:Snap.NX.Expression.ExpressionType.Integer">
            <summary>Integer-valued expression</summary>
        </member>
        <member name="F:Snap.NX.Expression.ExpressionType.Point">
            <summary>Point-valued expression</summary>
        </member>
        <member name="F:Snap.NX.Expression.ExpressionType.String">
            <summary>String-valued expression</summary>
        </member>
        <member name="F:Snap.NX.Expression.ExpressionType.Vector">
            <summary>Vector-valued expression</summary>
        </member>
        <member name="F:Snap.NX.Expression.ExpressionType.Number">
            <summary>Number-valued (floating point) expression</summary>
        </member>
        <member name="M:Snap.NX.Expression.CreateExpression(NXOpen.Expression)">
            <summary>
            Creates a Snap.NX.Expression object of the most specific type possible
            </summary>
            <param name="nxopenExpression">The input NXOpen.Expression</param>
            <returns>A Snap.NX.Expression object that has the most specific type possible</returns>
            <remarks>
            <para>
            The returned expression's static type is still Snap.NX.Expression, but, where
            possible, the NX.Expression variable now contains an expression object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller. This is used in part-file cycling, for example.
            </para>
            <para>
            This function should be used instead of the NX.Expression constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Expression.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Expression tag to a Snap.NX.Expression</summary>
            <param name="nxopenExpressionTag">The tag of an NXOpen.Expression object to be converted</param>
            <returns>The Snap.NX.Expression object formed by wrapping the NXOpen.Expression having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Expression object</exception>
        </member>
        <member name="M:Snap.NX.Expression.Delete">
            <summary>Delete this expression</summary>
        </member>
        <member name="M:Snap.NX.Expression.FindByName(System.String)">
            <summary>Find the expression in the work part that has a given name</summary>
            <param name="name">Name of the expression</param>
            <returns>The NX.Expression object having the given name, or <c>Nothing</c></returns>
            <remarks>
            <para>
            You can use this function to find out whether an expression having a given name
            already exists. Specifically, if <c>FindByName("expName")</c> returns
             <c>Nothing</c>, then an expression called "expName" does not yet exist.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.Expression">Snap.NX.Expression</seealso>
        </member>
        <member name="T:Snap.NX.ExpressionBoolean">
            <summary>Boolean type of expression (one whose value is either True or False)</summary>
            <remarks>
            <para>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            </para>
            </remarks>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
        </member>
        <member name="M:Snap.NX.ExpressionBoolean.#ctor(System.String,System.Boolean)">
            <summary>Creates a boolean expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="value">The boolean value of the expression</param>
            <returns>An NX.ExpressionBoolean object</returns>
        </member>
        <member name="P:Snap.NX.ExpressionBoolean.Value">
            <summary>The boolean value of the expression</summary>
        </member>
        <member name="T:Snap.NX.ExpressionInteger">
            <summary>Integer type of expression</summary>
            <remarks>
            <para>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            </para>
            </remarks>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
        </member>
        <member name="M:Snap.NX.ExpressionInteger.#ctor(System.String,System.Int32)">
            <summary>Creates an integer expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="value">The integer value of the expression</param>
            <returns>An NX.ExpressionInteger object</returns>
        </member>
        <member name="P:Snap.NX.ExpressionInteger.Value">
            <summary>The integer value of the expression</summary>       
        </member>
        <member name="T:Snap.NX.ExpressionNumber">
            <summary>Number type of expression (one whose value is a floating-point number)</summary>
            <remarks>
            <para>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            </para>
            </remarks>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
        </member>
        <member name="P:Snap.NX.ExpressionNumber.Value">
            <summary>The value of the expression in base units</summary> 
            <remarks>
            <para>
            Note that setting the Value property will also change the value of the RightHandSide property.
            For example, if you set <c>Value = 3.5</c>, then the RightHandSide string will become "3.5".
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ExpressionNumber.#ctor(System.String,System.Double)">
            <summary>Creates a constant number expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="value">The number value of the expression</param>
            <returns>An NX.ExpressionNumber object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ExpressionNumber.#ctor(System.String,System.String)">
            <summary>Creates a constant number expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="rightHandSide">The right-hand side formula</param>
            <returns>An NX.ExpressionNumber object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ExpressionNumber.#ctor(System.String,Snap.Number,Snap.NX.Unit)">
            <summary>Creates a constant number expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="rightHandSide">The right-hand side</param>
            <param name="unit">The units of the expression</param>
            <returns>An NX.ExpressionNumber object</returns>
            <exclude/>
        </member>
        <member name="T:Snap.NX.ExpressionPoint">
            <summary>Point type of expression</summary>
            <remarks>
            <para>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            </para>
            </remarks>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
        </member>
        <member name="M:Snap.NX.ExpressionPoint.#ctor(System.String,Snap.Position)">
            <summary>Creates a point expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="value">The position value of the expression</param>
            <returns>An NX.ExpressionPoint object</returns>
        </member>
        <member name="P:Snap.NX.ExpressionPoint.Value">
            <summary>The point value of the expression</summary>
        </member>
        <member name="T:Snap.NX.ExpressionString">
            <summary>String type of expression</summary>
            <remarks>
            <para>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            </para>
            </remarks>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
        </member>
        <member name="M:Snap.NX.ExpressionString.#ctor(System.String,System.String)">
            <summary>Creates a string expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="value">The string value of the expression</param>
            <returns>An NX.ExpressionString object</returns>
        </member>
        <member name="P:Snap.NX.ExpressionString.Value">
            <summary>The string value of the expression</summary>
        </member>
        <member name="T:Snap.NX.ExpressionVector">
            <summary>Vector type of expression</summary>
            <remarks>
            <para>
            To create an NX.Expression object, use the <see cref="O:Snap.Create.Expression">Snap.Create.Expression</see> functions.
            </para>
            </remarks>
            <seealso cref="O:Snap.Create.Expression">Snap.Create.Expression</seealso>
        </member>
        <member name="M:Snap.NX.ExpressionVector.#ctor(System.String,Snap.Vector)">
            <summary>Creates a vector expression object</summary>        
            <param name="name">The name of the expression</param>
            <param name="value">The vector value of the expression</param>
            <returns>An NX.ExpressionVector object</returns>
        </member>
        <member name="P:Snap.NX.ExpressionVector.Value">
            <summary>The vector value of the expression</summary>
        </member>
        <member name="T:Snap.NX.ExtractFace">
            <summary>
            Represents a Snap.NX.ExtractFace feature (interchangeable with <see cref="T:NXOpen.Features.ExtractFace">NXOpen.Features.ExtractFace</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.ExtractFace object, use the <see cref="M:Snap.Create.ExtractFace(Snap.NX.Face[])">Snap.Create.ExtractFace</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to create an ExtractFace feature:
            <code title="Create an ExtractFace feature: " lang="VB.NET" source="Extract_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.ExtractFace(Snap.NX.Face[])">Snap.Create.ExtractFace</seealso>
        </member>
        <member name="P:Snap.NX.ExtractFace.NXOpenExtractFace">
            <summary>Returns the NXOpen.Features.ExtractFace of the object</summary>
        </member>
        <member name="P:Snap.NX.ExtractFace.ExtractFaceBuilder">
            <summary>The NXOpen.Features.ExtractFaceBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the ExtractFace feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ExtractFaceBuilder">NXOpen.Features.ExtractFaceBuilder</seealso>
        </member>
        <member name="M:Snap.NX.ExtractFace.#ctor(NXOpen.Features.ExtractFace)">
            <summary> Constructor, given an NXOpen.Features.ExtractFace object</summary>
            <param name="extract">An NXOpen.Features.ExtractFace object</param>
        </member>
        <member name="M:Snap.NX.ExtractFace.op_Implicit(NXOpen.Features.ExtractFace)~Snap.NX.ExtractFace">
            <summary>Implicit conversion of NXOpen.Features.ExtractFace to NX.ExtractFace</summary>
            <param name="extract">The NXOpen.Features.ExtractFace to be converted (enclosed)</param>
            <returns>A new NX.ExtractFace object enclosing the given NXOpen.Features.ExtractFace</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ExtractFace.op_Implicit(Snap.NX.ExtractFace)~NXOpen.Features.ExtractFace">
            <summary>Implicit conversion of NX.ExtractFace to NXOpen.Features.ExtractFace</summary>
            <param name="extract">The NX.ExtractFace to be converted</param>
            <returns>The NXOpen.Features.ExtractFace object enclosed by the given NX.ExtractFace</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ExtractFace.CreateExtractFace(Snap.NX.Face[])">
            <summary>Creates an extract object</summary>
            <param name="faces">The face array which will be extracted</param>
            <returns>An NX.ExtractFace feature</returns>
        </member>
        <member name="M:Snap.NX.ExtractFace.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.ExtractFace tag to a Snap.NX.ExtractFace</summary>
            <param name="nxopenExtractFaceTag">The tag of an NXOpen.Features.ExtractFace object to be converted</param>
            <returns>The Snap.NX.ExtractFace object formed by wrapping the NXOpen.Features.ExtractFace having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.ExtractFace object</exception>
        </member>
        <member name="T:Snap.NX.Extrude">
            <summary>
            Represents a Snap.NX.Extrude feature (interchangeable with <see cref="T:NXOpen.Features.Extrude">NXOpen.Features.Extrude</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Extrude object, use the <see cref="O:Snap.Create.Extrude">Snap.Create.Extrude</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Extrude class:
            <code title="Properties of an NX.Extrude object: " lang="VB.NET" source="Extrude_02.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Extrude">Snap.Create.Extrude</seealso>
            <seealso cref="O:Snap.Create.ExtrudeSheet">Snap.Create.ExtrudeSheet</seealso>
            <seealso cref="M:Snap.Create.ExtrudeShell(Snap.NX.ICurve[],Snap.Vector,Snap.Number[],Snap.Number[],Snap.Number)">Snap.Create.ExtrudeShell</seealso>
        </member>
        <member name="P:Snap.NX.Extrude.NXOpenExtrude">
            <summary>The enclosed NXOpen.Features.Extrude object</summary>
        </member>
        <member name="P:Snap.NX.Extrude.Direction">
            <summary>Extrude direction</summary>
        </member>
        <member name="P:Snap.NX.Extrude.ExtrudeBuilder">
            <summary>The NXOpen.Features.ExtrudeBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Extrude feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ExtrudeBuilder">NXOpen.Features.ExtrudeBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Extrude.#ctor(NXOpen.Features.Extrude)">
            <summary> Constructor, given an NXOpen.Features.Extrude object</summary>
            <param name="extrude">An NXOpen.Features.Extrude object</param>
        </member>
        <member name="M:Snap.NX.Extrude.op_Implicit(NXOpen.Features.Extrude)~Snap.NX.Extrude">
            <summary> Implicit conversion of NXOpen.Features.Extrude to NX.Extrude</summary>
            <param name="extrude"> An NXOpen.Features.Extrude object</param>
            <returns>The corresponding NX.Extrude object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Extrude.op_Implicit(Snap.NX.Extrude)~NXOpen.Features.Extrude">
            <summary> Implicit conversion of NX.Extrude to NXOpen.Features.Extrude</summary>
            <param name="extrude"> AN NX.Extrude object</param>
            <returns>The enclosed NXOpen.Features.Extrude object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Extrude.CreateExtrude(Snap.NX.Section,Snap.Vector,Snap.Number[],Snap.Number,System.Boolean,Snap.Number[],System.Boolean)">
            <summary>Creates an extrude feature</summary>
            <param name="section">The "section" to be extruded</param>
            <param name="axis">Extrusion direction (vector magnitude not significant)</param>
            <param name="extents">Extents of the extrusion (measured from input curves)</param>
            <param name="draftAngle">Draft angle, in degrees (positive angle gives larger sections in direction of axis)</param>
            <param name="offset">If true, means that offset values are being provided</param>
            <param name="offsetValues">Offset distances for section curves</param>
            <param name="createSheet">If true, forces creation of a sheet body</param>
            <returns>An NX.Extrude object</returns>
        </member>
        <member name="M:Snap.NX.Extrude.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Extrude tag to a Snap.NX.Extrude</summary>
            <param name="nxopenExtrudeTag">The tag of an NXOpen.Features.Extrude object to be converted</param>
            <returns>The Snap.NX.Extrude object formed by wrapping the NXOpen.Features.Extrude having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Extrude object</exception>
        </member>
        <member name="T:Snap.NX.Face">
            <summary>
            Represents a Snap.NX.Face object (interchangeable with <see cref="T:NXOpen.Face">NXOpen.Face</see>)
            </summary>
            <remarks>
            <para>
            The following picture explains the properties of an NX.Face object: 
            </para>
            <para>
            <img src="../Images/Face.png"/>
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Face class:
            <code title="Properties of an NX.Face object: " lang="VB.NET" source="Face_03.vb"> 
            </code> 
            </example>   
        </member>
        <member name="P:Snap.NX.Face.ObjectType">
            <summary>The type of the object</summary>
        </member>
        <member name="P:Snap.NX.Face.ObjectSubType">
            <summary>The subtype of the face</summary>
            <remarks>
            <para>
            The possible subtypes are
            <list type = "bullet">
            <item>FacePlane</item>     
            <item>FaceCylinder</item>  
            <item>FaceCone</item>
            <item>FaceSphere</item>
            <item>FaceTorus</item>
            <item>FaceBsurface</item>
            <item>FaceBlend</item>
            <item>FaceOffset</item>
            <item>FaceExtruded</item>
            <item>FaceRevolved</item>
            <item>FaceUnknown</item>
            </list>
            </para>
            </remarks>
            <seealso cref= "T:Snap.NX.ObjectTypes.SubType">Snap.NX.ObjectTypes.SubType</seealso>
        </member>
        <member name="P:Snap.NX.Face.NXOpenFace">
            <summary>The enclosed NXOpen.Face object</summary>
        </member>
        <member name="P:Snap.NX.Face.PsTag">
            <summary>Get the Parasolid tag from this NX.Face</summary>
        </member>
        <member name="P:Snap.NX.Face.PsFace">
            <summary>Get the Parasolid face from this NX.Face</summary>
        </member>
        <member name="P:Snap.NX.Face.Sense">
            <summary>The sense of the outward face normal</summary>
            <remarks>
            <para>
            This property helps you determine on which side of a face material lies.
            </para>
            <para>
            To compute an outward normal,
            you first get the "natural" normal by calling the 
            <see cref="M:Snap.NX.Face.Normal(System.Double[])">Face.Normal</see> function, and then you 
            multiply this by Face.Sense.
            </para>
            <para>
            On a cylindrical face, the natural normal points away from the centerline. So,
            if a cylindrical face has <c>Face.Sense = Sense.Positive</c>, this means that
            the outward normal also points away from the centerline, so the face must be
            part of a boss. Similarly, if a cylindrical face has <c>Face.Sense = Sense.Negative</c>, 
            it must be part of a hole.
            </para> 
            </remarks>
            <example> 
            This example shows how to use Face.Sense to construct an outward normal:
            <code title="Constructing an outward normal: " lang="VB.NET" source="FaceSense_01.vb"> 
            </code> 
            <para>
            This example shows how to use Face.Sense to identify holes and bosses:
            <code title="Identifying holes and bosses: " lang="VB.NET" source="FaceSense_02.vb"> 
            </code> 
            </para> 
            </example>
            <seealso cref="M:Snap.NX.Face.Normal(System.Double[])">Snap.NX.Face.Normal</seealso>
        </member>
        <member name="P:Snap.NX.Face.Body">
            <summary>The body on which the face lies</summary>
        </member>
        <member name="P:Snap.NX.Face.Edges">
            <summary>The array of edges in the face</summary>
            <remarks>
            <para>
            If the face has no edges (a spherical face, for example), 
            this property will return an array of length zero.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Face.Shell">
            <summary>The shell that the face belongs to</summary>
            <remarks>
            <para>
            In a solid body, the face normal points away from the volume bounded by this shell.
            In a sheet body, the shell may not bound a volume, of course.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Face.Loops">
            <summary>The array of loops in the face</summary>      
            <remarks>
            <para>
            If the face has no loops (a spherical face, for example), 
            this property will return an array of length zero.
            </para>
            </remarks>      
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and gets information about the
            loops on one of its faces.
            <code title="Finding information about loops" lang="VB.NET" source="FaceLoops_01.vb">
            </code> 
            </example>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
            <seealso cref= "T:Snap.Topology.LoopType">Snap.Topology.LoopType</seealso>
        </member>
        <member name="P:Snap.NX.Face.OuterLoop">
            <summary>The outer loop of the face (if it has one)</summary>      
            <remarks>
            <para>
            Planes and other non-periodic surfaces have a single outer loop
            and possibly some hole loops (type Inner). If the surface
            is periodic in one or two directions, there may not be any clear
            outer loop. In this case, this property will return <c>Nothing</c>.
            </para>
            </remarks>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
            <seealso cref= "T:Snap.Topology.LoopType">Snap.Topology.LoopType</seealso>
        </member>
        <member name="P:Snap.NX.Face.Vertices">
            <summary>The array of vertices in the face</summary>
            <remarks>
            <para>
            If the face has no vertices (a spherical face, for example), 
            this property will return an array of length zero.
            </para>
            </remarks>
            <seealso cref= "T:Snap.Topology.Vertex">Snap.Topology.Vertex</seealso>
        </member>
        <member name="M:Snap.NX.Face.ContainsPoint(System.Double[])">
            <summary>Determine whether a point with given (u,v) parameters lies inside the face</summary>
            <param name="uv">The (u,v) parameter values of the point to be tested </param>
            <returns>True if the given point lies inside (or on an edge) of the face</returns>
            <example> 
            The following example checks whether points are contained inside a face. 
            <code title="Testing point containment" lang="VB.NET" source="ContainsPoint_02.vb">
            </code> 
            </example>
            <seealso cref= "M:Snap.NX.Body.ContainsPoint(Snap.Position)">Snap.NX.Body.ContainsPoint</seealso>
        </member>
        <member name="P:Snap.NX.Face.BoxUV">
            <summary>The box that encloses the face in the UV parameter space of the surface</summary>        
        </member>
        <member name="P:Snap.NX.Face.Box">
            <summary>The 3D box that the encloses the face</summary>        
        </member>
        <member name="P:Snap.NX.Face.Area">
            <summary>The surface area of the face </summary>
        </member>
        <member name="P:Snap.NX.Face.FactorU">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapU = nxopenU * FactorU</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenU = snapU / FactorU</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Face.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Face.EdgeCurves">
            <summary>Gets the edge curves of the given face</summary>
            <returns>An array of edge curves (NX.Curve objects)</returns>
        </member>
        <member name="P:Snap.NX.Face.Prototype">
            <summary>
            Returns the prototype face of this face (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter 11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the face is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Face.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
            <remarks>
            <para>
            The constructor is protected to encourage callers to use CreateFace, 
            instead, since this ensures proper downcasting.
            The only callers should be constructors for derived classes.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.CreateFace(NXOpen.Face)">
            <summary>
            Creates a Snap.NX.Face object of the most specific type possible
            </summary>
            <param name="nxopenFace">The input NXOpen.Face</param>
            <returns>A Snap.NX.Face object that has the most specific type possible</returns>
            <remarks>
            <para>
            The returned face's static type is still Snap.NX.Face, but, where
            possible, the NX.Face variable now contains a face object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller. This is used in Selection, for example.
            </para>
            <para>
            This function should be used instead of the NX.Face constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.op_Implicit(NXOpen.Face)~Snap.NX.Face">
            <summary>Implicit conversion of NXOpen.Face to NX.Face</summary>
            <param name="face">The NXOpen.Face to be converted (enclosed)</param>
            <returns>A new NX.Face object enclosing the given NXOpen.Face</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.op_Implicit(Snap.NX.Face)~NXOpen.Face">
            <summary>Implicit conversion of NX.Face to NXOpen.Face</summary>
            <param name="face">The NX.Face to be converted</param>
            <returns>The NXOpen.Face object enclosed by the given NX.Face</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Position(System.Double[])">
            <summary>Evaluates a point on the face at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values -- not normalized to the range [0,1]</param>
            <returns>Point on face at the given (u,v) parameter values</returns>
            <remarks>
            <para>
            The <c>Position</c> function and the <c>Parameters</c> function are designed to work
            together smoothly -- each of these functions is the "reverse" of the other. 
            So, if f is any face and (u,v) is any pair of parameter values, then
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   <c>f.Parameters(f.Position(u,v)) = (u,v)</c>
            </para>
            <para>
            Also, if p is any point on the face f, then
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   <c>f.Position(c.Parameters(p)) = p</c>
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception> 
            <example> 
            This example shows how to calculate positions and normals on a face:
            <code title="Calculate points and normals on a face: " lang="VB.NET" source="Face_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
            <seealso cref="M:Snap.NX.Face.Parameters(Snap.Position)">Snap.NX.Face.Parameters</seealso>
        </member>
        <member name="M:Snap.NX.Face.Normal(System.Double[])">
            <summary>Evaluates the face normal at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values -- not normalized to the range [0,1]</param>
            <returns>Face normal at the given (u,v) parameter values (a unit vector)</returns>
            <remarks>
            <para>
            This function returns the "natural" normal vector, which is parallel to the cross product of the partial derivatives.
            Typically, <c>Normal(uv)</c> is a unit vector parallel to <c>Cross(DerivDu(uv), DerivDv(uv)</c>.
            However, sometimes one of the partial derivatives is zero. In this case the
            cross product will also be zero, and will provide no useful information.
            This function will return a correct surface normal vector even in these
            unpleasant cases.
            </para>
            <para>
            The natural face normal directions for some common surface types are as follows:
            <list type="bullet">
            <item><b>Cylinder:</b> Away from its centerline</item>
            <item><b>Cone:</b> Away from its centerline</item>
            <item><b>Sphere:</b> Away from its center</item>
            </list>
            </para>
            <para>
            It is often useful to compute an "outward" normal on the surface of a solid object (i.e.
            a normal vector that points away from material, towards empty space). To do this, you
            compute a natural normal vector using this function, and then adjust its sense using the
            <see cref="P:Snap.NX.Face.Sense">Face.Sense</see> property.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception>
            <example> 
            This example shows how to get the normal with given U and V parameters:
            <code title="Get the normal with given U and V parameters: " lang="VB.NET" source="Face_04.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
            <seealso cref="P:Snap.NX.Face.Sense">Snap.NX.Face.Sense</seealso>
        </member>
        <member name="M:Snap.NX.Face.DerivDu(System.Double[])">
            <summary>Evaluates partial derivative wrt u at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values -- not normalized to the range [0,1]</param>
            <returns>Partial derivative with respect to u at the given (u,v) parameter values</returns>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
        </member>
        <member name="M:Snap.NX.Face.DerivDuDv(System.Double[])">
            <summary>Evaluates mixed partial derivative at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values -- not normalized to the range [0,1]</param>
            <returns>Mixed partial derivative d2S/dudv at the given (u,v) parameter values</returns>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>     
        </member>
        <member name="M:Snap.NX.Face.DerivDv(System.Double[])">
            <summary>Evaluates partial derivative wrt v at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values -- not normalized to the range [0,1]</param>
            <returns>Partial derivative with respect to v at the given (u,v) parameter values</returns>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
        </member>
        <member name="M:Snap.NX.Face.Curvatures(System.Double[])">
            <summary>Evaluates principal curvatures at given (u,v) parameter values</summary>
            <param name="uv">The (u,v) parameter values -- not normalized to the range [0,1]</param>
            <returns>Principal curvatures at the given (u,v) parameter values</returns>
            <exception cref="T:System.ArgumentException">
            The (u,v) parameter array has the wrong length. You must input
            two separate values, or an array of length 2.
            </exception>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
            <remarks>
            <para>
            Curvature is the reciprocal of radius of curvature. So, on a straight line,
            curvature is zero and radius of curvature is infinite. On a circle of radius 5,
            curvature is 0.2 (and radius of curvature is 5, of course).
            </para>
            <para>
            The principal curvatures at a point on a face are the curvatures of two particular
            planar sections through that point. For more information, please read about the
            mathematics of "differential geometry".
            </para>
            <para>
            The two principal curvatures are returned in ascending order -- the first is smaller
            (i.e. closer to minus infinity).
            A principal curvature value will be positive if the corresponding planar section of
            the surface is concave when viewed from the outside, and negative if the cross-section is convex.
            A curvature of zero indicates a cross-sectional shape that is a straight line.
            </para>
            <para>
            For example, on the cylindrical surface of a 20mm diameter hole, the principal
            curvatures are (0, 0.1). The surface has radius 10, so its larger curvature 
            is 1/10 = 0.1. Similarly, on the cylindrical surface of a 10mm diameter boss, the
            principal curvatures are (-0.2, 0).
            </para>
            </remarks> 
            <example> 
            This example shows curvature calculations on simple faces:
            <code title="Curvatures on simple faces: " lang="VB.NET" source="FaceCurvatures_01.vb"></code> 
            This example shows curvature calculations on a free-form surface:
            <code title="Curvatures on a free-form surface: " lang="VB.NET" source="FaceCurvatures_02.vb"></code>
            </example>
        </member>
        <member name="M:Snap.NX.Face.Parameters(Snap.Position)">
            <summary>Finds surface (u,v) parameters at (or nearest to) a given point</summary>
            <param name="point">The given point (which should be on or near to the surface)</param>
            <returns>Surface (u,v) parameters at (or near to) the given point</returns>
            <remarks>
            <para>
            The <c>Parameters</c> function and the <c>Position</c> function are designed to work
            together smoothly -- each of these functions is the "reverse" of the other. 
            So, if f is any face and (u,v) is any pair of parameter values, then
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   <c>f.Parameters(f.Position(u,v)) = (u,v)</c>
            </para>
            <para>
            Also, if p is any point on the face f, then
            </para>
            <para>
            &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   <c>f.Position(c.Parameters(p)) = p</c>
            </para>
            <para>
            Note that this function finds parameter values on the underlying
            surface of the face. So, the values returned may correspond to a surface point
            that is actually outside the face.
            </para>
            </remarks>
            <example> 
            This example shows how to get the (u,v) parameters at a point on a face:
            <code title="Get the (u,v) parameters at a point on a face: " lang="VB.NET" source="Face_06.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
            <seealso cref="M:Snap.NX.Face.Position(System.Double[])">Snap.NX.Face.Position</seealso>
        </member>
        <member name="M:Snap.NX.Face.PositionArray(System.Double[],System.Double[])">
            <summary>Evaluates a rectangular array of points (positions) on the face</summary>
            <param name="paramsU">The u-parameter values for the array of positions</param>
            <param name="paramsV">The v-parameter values for the array of positions</param>
            <returns>A rectangular array of positions</returns>
            <remarks>
            <para>
            <c>PositionArray[i, j] = Face.Position( paramsU[i], paramsV[j] )</c>
            </para>
            </remarks>
            <example> 
            This example shows how to create an array of positions on a face: 
            <code title="Create an array of positions on a face" lang="VB.NET" source="Face_05.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
        </member>
        <member name="M:Snap.NX.Face.PositionArray(Snap.Geom.Box2d,System.Int32,System.Int32)">
            <summary>Evaluates a rectangular array of points (positions) on the face</summary>
            <param name="boxUV">The uv-box over which the points should be distributed</param>
            <param name="numU">Number of points in the u-direction</param>
            <param name="numV">Number of points in the v-direction</param>
            <returns>A rectangular array of numU x numV equally-spaced points</returns>
            <remarks>
            <para>
            The points are equally spaced in a parametric sense; the 3D distances between
            them are not necessarily equal.
            </para>
            </remarks>
            <example> 
            This example shows how to create an array of positions on a face: 
            <code title="Create an array of positions on a face" lang="VB.NET" source="Bsurface_03.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.Face">Snap.NX.Face</seealso>
        </member>
        <member name="M:Snap.NX.Face.Wrap(NXOpen.Tag)">
            <summary>Converts an NXOpen.Face tag to a Snap.NX.Face</summary>
            <param name="nxopenFaceTag">The tag of an NXOpen.Face object to be converted</param>
            <returns>The Snap.NX.Face object formed by wrapping the NXOpen.Face having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter 16.
            </para>
            <para>
            Returns <c>Nothing if the input tag is NXOpen.Tag.Null</c>.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag doesn't belong to an NXOpen.Face object</exception>
        </member>
        <member name="T:Snap.NX.Face.Plane">
            <summary>Represents a Snap.NX.Face.Plane object</summary>
            <seealso cref="T:Snap.Geom.Surface.Plane">Snap.Geom.Surface.Plane</seealso>
        </member>
        <member name="M:Snap.NX.Face.Plane.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Plane.Geometry">
            <summary>Geometry data of the planar face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Plane object" lang="VB.NET" source="GeomPlane_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Face.Plane.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are lines)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of lines corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single line.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Plane.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are lines)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of lines corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single line.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Bsurface">
            <summary>Represents a Snap.NX.Face.Bsurface object</summary>
            <seealso cref="T:Snap.Geom.Surface.Bsurface">Snap.Geom.Surface.Bsurface</seealso>
        </member>
        <member name="M:Snap.NX.Face.Bsurface.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Bsurface.Geometry">
            <summary>Geometry data of the bsurface face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Bsurface object" lang="VB.NET" source="GeomBsurface_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Face.Bsurface.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are splines)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of splines corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single spline.
            </para>
            </remarks>
            <example> 
            The following example shows how to create isoparametric curves on a b-surface: 
            <code title="Isocurves on a b-surface" lang="VB.NET" source="IsoparametricCurve_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Face.Bsurface.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are splines)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of splines corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single spline.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Cylinder">
            <summary>Represents a Snap.NX.Face.Cylinder object</summary> 
            <remarks>
            <para>
            On a cylindrical face, the u and v parameters have the following meanings:
            <list type = "bullet">
            <item>u measures angle around the cylindrical axis, in degrees</item>
            <item>v measures straight-line distance along the cylinder, starting from the AxisPoint</item>
            </list>
            </para>
            <para>
            The face normal vector is parallel to the cross product of the partial derivatives,
            and therefore points away from the cylinder axis.
            </para>
            </remarks>
            <seealso cref="T:Snap.Geom.Surface.Cylinder">Snap.Geom.Surface.Cylinder</seealso>
            <seealso cref="M:Snap.NX.Face.Normal(System.Double[])">Snap.NX.Face.Normal</seealso>
        </member>
        <member name="M:Snap.NX.Face.Cylinder.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Cylinder.Geometry">
            <summary>Geometry data of the cylindrical face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Cylinder object" lang="VB.NET" source="GeomCylinder_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Face.Cylinder.FactorU">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapU = nxopenU * FactorU</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenU = snapU / FactorU</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Face.Cylinder.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Cylinder.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are lines)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of lines corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single line.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Cylinder.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are arcs)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Cone">
            <summary>Represents a Snap.NX.Face.Cone object</summary>
            <remarks>
            <para>
            On a conical face, the u and v parameters have the following meanings:
            <list type = "bullet">
            <item>u measures angle around the cone's axis, in degrees</item>
            <item>v measures straight-line distance along the cone, starting from the AxisPoint</item>
            </list>
            </para>
            <para>
            The face normal vector is parallel to the cross product of the partial derivatives,
            and therefore points away from the cone axis.
            </para>
            </remarks>
            <seealso cref="M:Snap.NX.Face.Normal(System.Double[])">Snap.NX.Face.Normal</seealso>
            <seealso cref="T:Snap.Geom.Surface.Cone">Snap.Geom.Surface.Cone</seealso>
        </member>
        <member name="M:Snap.NX.Face.Cone.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Cone.Geometry">
            <summary>Geometry data of the conic face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Cone object" lang="VB.NET" source="GeomCone_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Face.Cone.FactorU">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapU = nxopenU * FactorU</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenU = snapU / FactorU</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Face.Cone.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Cone.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are lines)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of lines corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single line.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Cone.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are arcs)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Sphere">
            <summary>Represents a Snap.NX.Face.Sphere object</summary>
            <remarks>
            <para>
            The face normal vector points away from the center of the sphere.
            </para>
            </remarks>
            <seealso cref="T:Snap.Geom.Surface.Sphere">Snap.Geom.Surface.Sphere</seealso>
            <seealso cref="M:Snap.NX.Face.Normal(System.Double[])">Snap.NX.Face.Normal</seealso> 
        </member>
        <member name="M:Snap.NX.Face.Sphere.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Sphere.Geometry">
            <summary>Geometry data of the spherical face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Sphere object" lang="VB.NET" source="GeomSphere_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Face.Sphere.FactorU">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapU = nxopenU * FactorU</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenU = snapU / FactorU</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Face.Sphere.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Sphere.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are arcs)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Sphere.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are arcs)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Torus">
            <summary>Represents a Snap.NX.Face.Torus object</summary>         
            <seealso cref="T:Snap.Geom.Surface.Torus">Snap.Geom.Surface.Torus</seealso>
        </member>
        <member name="M:Snap.NX.Face.Torus.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Torus.Geometry">
            <summary>Geometry data of the toroidal face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Torus object" lang="VB.NET" source="GeomTorus_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Face.Torus.FactorU">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapU = nxopenU * FactorU</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenU = snapU / FactorU</para>
            </remarks>
            <exclude/>
        </member>
        <member name="P:Snap.NX.Face.Torus.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Torus.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are arcs)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Torus.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are arcs)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Revolved">
            <summary>Represents a Snap.NX.Face.Revolved object</summary>
            <remarks>
            <para>
            On a revolved face, the u and v parameters have the following meanings:
            <list type = "bullet">
            <item>u is the parameter of the generator curve</item>
            <item>v measures angle around the axis, in degrees, starting from the generator curve</item>
            </list>
            So, the isoparametric curve v = 0 coincides with the generator curve.
            </para>
            </remarks>
            <seealso cref="T:Snap.Geom.Surface.Revolve">Snap.Geom.Surface.Revolve</seealso>
        </member>
        <member name="M:Snap.NX.Face.Revolved.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Revolved.Geometry">
            <summary>Geometry data of the revolved face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Revolved object" lang="VB.NET" source="GeomRevolve_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Face.Revolved.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Revolved.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are arcs)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Revolved.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are splines)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of splines corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single spline.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Extruded">
            <summary>Represents a Snap.NX.Face.Extruded object</summary>
            <remarks>
            <para>
            On an extruded face, the u and v parameters have the following meanings:
            <list type = "bullet">
            <item>u is the parameter of the generator curve</item>
            <item>v measures straight-line distance along the extruded surface, starting from the generator curve</item>
            </list>
            So, the isoparametric curve v = 0 coincides with the generator curve.
            </para>
            </remarks>
            <seealso cref="T:Snap.Geom.Surface.Extrude">Snap.Geom.Surface.Extrude</seealso>
        </member>
        <member name="M:Snap.NX.Face.Extruded.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Extruded.Geometry">
            <summary>Geometry data of the extruded face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Extruded object" lang="VB.NET" source="GeomExtrude_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Face.Extruded.FactorV">
            <summary>Conversion factor between NX Open and SNAP parameter values. Needed because NX Open uses radians, where SNAP uses degrees</summary>
            <remarks>
            <para>
            </para>
            <para>When converting an NX Open parameter to a SNAP parameter, snapV = nxopenV * FactorV</para>
            <para>When converting a SNAP parameter to an NX Open parameter, nxopenV = snapV / FactorV</para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Face.Extruded.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are lines)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of lines corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single line.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Extruded.IsoCurveV(System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are splines)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <returns>An array of splines corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single spline.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.Face.Blend">
            <summary>Represents a Snap.NX.Face.Blend object</summary>            
            <seealso cref="T:Snap.Geom.Surface.Blend">Snap.Geom.Surface.Blend</seealso>
        </member>
        <member name="M:Snap.NX.Face.Blend.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Blend.Geometry">
            <summary>The geometry of blending face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Blend object" lang="VB.NET" source="GeomBlend_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Face.Blend.IsoCurveU(System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are arcs)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <returns>An array of arcs corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single arc.
            </para>
            <para>
            Iso-curves of the form v = constant are not supported on blend faces, so there 
            is no IsoCurveV function.
            </para>
            </remarks>
            <example> 
            The following example shows how to create u = constant iso-curves on a blend surface: 
            <code title="Isocurves on a blend surface" lang="VB.NET" source="IsoparametricCurve_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Face.Blend.SplineToArc(Snap.NX.Spline,System.Double)">
            <summary>Construct an arc based on a spline iso-curve of a blend</summary>
            <param name="spline">The spline iso-curve</param>
            <param name="radius">Radius of blend face</param>
            <returns>Arc that is a "better" iso-curve (more accurate)</returns>
        </member>
        <member name="T:Snap.NX.Face.Offset">
            <summary>Represents a Snap.NX.Face.Offset object</summary>      
            <seealso cref="T:Snap.Geom.Surface.Offset">Snap.Geom.Surface.Offset</seealso>
        </member>
        <member name="M:Snap.NX.Face.Offset.#ctor(NXOpen.Face)">
            <summary>Constructor, given an NXOpen.Face object</summary>
            <param name="nxopenFace">An NXOpen.Face object</param>
        </member>
        <member name="P:Snap.NX.Face.Offset.Geometry">
            <summary>Geometry data of the offset face</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of an NX.Face.Offset object" lang="VB.NET" source="GeomOffset_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Face.Offset.IsoCurveU(System.Double,System.Double)">
            <summary>Creates isoparametric curves of the form u = constant (which are splines)</summary>
            <param name="constantU">The u value defining the isoparametric curves</param>
            <param name="tolerance">Tolerance value, explained below. Optional. Default = 0.0254</param>
            <returns>An array of splines corresponding to u = constantU</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single spline.
            </para>
            <para>
            The iso-curves are approximations, and the accuracy of the approximation is controlled by the input tolerance.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.Offset.IsoCurveV(System.Double,System.Double)">
            <summary>Creates isoparametric curves of the form v = constant (which are splines)</summary>
            <param name="constantV">The v value defining the isoparametric curves</param>
            <param name="tolerance">Tolerance value, explained below. Optional. Default = 0.0254</param>
            <returns>An array of splines corresponding to v = constantV</returns>
            <remarks>
            <para>
            If the face has not been trimmed, then this function will always return a single spline.
            </para>
            <para>
            As the face is an offset surface, the iso-curves are approximations, and the accuracy of the approximation is controlled by the input tolerance.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.SurfaceEvaluate(Snap.NX.Face,System.Int32,System.Double,System.Double)">
            <summary>Main surface evaluator function</summary>
            <param name="face">The NX.Face on which to evaluate</param>
            <param name="mode">Mode indicating what returns are needed</param>
            <param name="u">u-parameter value</param>
            <param name="v">v-parameter value</param>
            <returns>Various points and derivatives (Position, DerivDu, DerivDv, UnitNormal)</returns>
            <remarks>The "mode" input indicates which derivatives should be calculated:
            <para>
                 mode = UF_MODL_EVAL             :  position only
                 mode = UF_MODL_EVAL_DERIV1      :  position and first partials dS/du and dS/dv
                 mode = UF_MODL_EVAL_DERIV2      :  position, dS/du, dS/dv, d2S/dudv, d2S/du2, d2S/dv2
                 mode = UF_MODL_EVAL_DERIV3      :  position, first, second, and third partials
                 mode = UF_MODL_EVAL_UNIT_NORMAL :  position, first partials, and unitized normal.
                 mode = UF_MODL_EVAL_NORMAL      :  position, first partials and the non-unitized normal.
                 mode = UF_MODL_EVAL_ALL         :  position, normals and all the partials up to the third order.  
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Face.GetFaceType(Snap.NX.Face)">
            <summary>Utility function that maps NX face subtypes to Snap face types</summary>
            <param name="snapFace">Snap.NX.Face object</param>
            <returns>Snap.NX.ObjectTypes.SubType of face</returns>
        </member>
        <member name="T:Snap.NX.FaceBlend">
            <summary>
            Represents a Snap.NX.FaceBlend feature (interchangeable with <see cref="T:NXOpen.Features.FaceBlend">NXOpen.Features.FaceBlend</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.FaceBlend object, use the <see cref="M:Snap.Create.FaceBlend(Snap.NX.Face,Snap.NX.Face,Snap.Number)">Snap.Create.FaceBlend</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.FaceBlend class:
            <code title="Properties of an NX.FaceBlend object: " lang="VB.NET" source="FaceBlend_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.FaceBlend(Snap.NX.Face,Snap.NX.Face,Snap.Number)">Snap.Create.FaceBlend</seealso>
        </member>
        <member name="P:Snap.NX.FaceBlend.NXOpenFaceBlend">
            <summary>The enclosed <see cref="T:NXOpen.Features.FaceBlend">NXOpen.Features.FaceBlend</see> object</summary>
        </member>
        <member name="P:Snap.NX.FaceBlend.FaceBlendBuilder">
            <summary>The NXOpen.Features.FaceBlendBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the FaceBlend feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.FaceBlendBuilder">NXOpen.Features.FaceBlendBuilder</seealso>
        </member>
        <member name="P:Snap.NX.FaceBlend.Radius">
            <summary>The radius of the face blend</summary>
        </member>
        <member name="M:Snap.NX.FaceBlend.#ctor(NXOpen.Features.FaceBlend)">
            <summary> Constructor, given an NXOpen.Features.FaceBlend object</summary>
            <param name="faceBlend">An NXOpen.Features.FaceBlend object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.FaceBlend.op_Implicit(NXOpen.Features.FaceBlend)~Snap.NX.FaceBlend">
            <summary>Implicit conversion of NXOpen.Features.FaceBlend to NX.FaceBlend</summary>
            <param name="faceBlend">The NXOpen.Features.FaceBlend to be converted (enclosed)</param>
            <returns>A new NX.FaceBlend object enclosing the given NXOpen.Features.FaceBlend</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.FaceBlend.op_Implicit(Snap.NX.FaceBlend)~NXOpen.Features.FaceBlend">
            <summary>Implicit conversion of NX.FaceBlend to NXOpen.Features.FaceBlend</summary>
            <param name="faceBlend">The NX.FaceBlend to be converted</param>
            <returns>The NXOpen.Features.FaceBlend object enclosed by the given NX.FaceBlend</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.FaceBlend.CreateFaceBlend(Snap.NX.Face,Snap.NX.Face,Snap.Number)">
            <summary>Creates a face blend object</summary>
            <param name="face1">Face one</param>
            <param name="face2">Face two</param>
            <param name="radius">Radius of a regular blend</param>
            <returns>An NX.FaceBlend object</returns>
        </member>
        <member name="M:Snap.NX.FaceBlend.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.FaceBlend tag to a Snap.NX.FaceBlend</summary>
            <param name="nxopenFaceBlendTag">The tag of an NXOpen.Features.FaceBlend object to be converted</param>
            <returns>The Snap.NX.FaceBlend object formed by wrapping the NXOpen.Features.FaceBlend having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.FaceBlend object</exception>
        </member>
        <member name="T:Snap.NX.Feature">
            <summary>
            Represents a Snap.NX.Feature object (interchangeable with <see cref="T:NXOpen.Features.Feature">NXOpen.Features.Feature</see>)
            </summary>
            <example> 
            This example shows how to use the properties of the NX.Feature class:
            <code title="Properties of an NX.Feature object: " lang="VB.NET" source="Feature_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Feature.NXOpenFeature">
            <summary>The enclosed NXOpen.Features.Feature object</summary>
        </member>
        <member name="P:Snap.NX.Feature.NXOpenDisplayableObject">
            <summary>The associated NXOpen.DisplayableObject of this NX.Feature</summary>
            <remarks>
            <para>
            This property is identical to NXOpenDisplayableObjects[0]. It serves as
            a shortcut in the common case where a feature has only a single
            corresponding displayable object.
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.Feature.NXOpenDisplayableObjects">NXOpenDisplayableObjects</seealso> 
        </member>
        <member name="P:Snap.NX.Feature.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature</summary>
            <remarks>
            <para>
            Here, in the case of a feature,
            we are over-riding the implementation in NXObject. If the feature consists of a single body,
            this allows us to confuse the feature with its body. This is useful
            because it means we can change the color of the feature, blank it, change its layer, and so on.
            A similar technique is used with Datum Planes and Datum Axes.
            </para>
            <para>
            See chapter&#160;10 of the SNAP Getting Started Guide for further discussion of feature display concepts.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Feature.Body">
            <summary>The associated body (an NX.Body object)</summary>
            <remarks>
            <para>
            If there is more than one body associated with the feature, please use property Feature.Bodies, instead.
            </para>
            <para>If there is no body associated with the feature, the value will be <c>Nothing</c>.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">There is more than one body associated with this feature.</exception>
        </member>
        <member name="P:Snap.NX.Feature.Bodies">
            <summary>The associated bodies (NX.Body objects)</summary>
            <remarks>
            <para>
            If you are sure that there is only one body associated with the
            feature, then it may be simpler to use the Body property.
            </para>
            <para>If there is no body associated with the feature, the value will be <c>Nothing</c>.</para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Feature.Edges">
            <summary>The associated edges (NX.Edge objects)</summary>
            <remarks>
            <para>
            Only returns the edges created by the body feature.
            </para>
            <para>If there is no edge associated with the feature, the value will be <c>Nothing</c>.</para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Feature.Faces">
            <summary>The associated faces (NX.Face objects)</summary>
            <remarks>
            <para>
            Only returns the faces created by the body feature.
            </para>
            <para>If there is no face associated with the feature, the value will be <c>Nothing</c>.</para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Feature.Box">
            <summary>The 3D box that the encloses the feature</summary>
            <remarks>
            <para>
            The Box property is not implemented for Datum Axis and Datum Plane objects.
            For these object types, getting this property will return <c>Nothing</c>, and will throw
            a System.ArgumentException.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input object is not of a type that can be boxed</exception>
        </member>
        <member name="P:Snap.NX.Feature.NameLocation">
            <summary>The position at which the name of the feature is displayed</summary>
        </member>
        <member name="P:Snap.NX.Feature.IsSuppressed">
            <summary>The suppression status of the feature</summary>
        </member>
        <member name="P:Snap.NX.Feature.Parents">
            <summary>The immediate parent features</summary>
        </member>
        <member name="M:Snap.NX.Feature.#ctor(NXOpen.Features.Feature)">
            <summary> Constructor, given an NXOpen.Feature object</summary>
            <param name="feature">An NXOpen.Feature object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Feature.CreateFeature(NXOpen.Features.Feature)">
            <summary>
            Creates a Snap.NX.Feature object of the most specific type possible
            </summary>
            <param name="nxopenFeature">The input NXOpen.Edge</param>
            <returns>A Snap.NX.Feature object that has the most specific type possible</returns>
            <remarks>
            <para>
            The returned feature's static type is still Snap.NX.Feature, but, where
            possible, the NX.Feature variable now contains a feature object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller. This is used in Selection, for example.
            </para>
            <para>
            This function should be used instead of the NX.Feature constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Feature.op_Implicit(NXOpen.Features.Feature)~Snap.NX.Feature">
            <summary> Implicit conversion of NXOpen.Features.Feature to NX.Feature</summary>
            <param name="feature"> An NXOpen.Features.Feature feature</param>
            <returns>The corresponding NX.Feature feature</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Feature.op_Implicit(Snap.NX.Feature)~NXOpen.Features.Feature">
            <summary> Implicit conversion of NX.Features.Feature to NXOpen.Feature</summary>
            <param name="feature"> An NX.Feature feature</param>
            <returns>The corresponding NXOpen.Features.Feature feature</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Feature.op_Implicit(Snap.NX.Feature)~Snap.NX.Body">
            <summary> Implicit conversion of NX.Feature to NX.Body</summary>
            <param name="feature"> An NXOpen.Features.Feature object</param>
            <returns>The corresponding NX.Body object</returns>
            <remarks>
            <para>
            This conversion is provided as a convenience, to avoid the need for
            explicitly accessing the body (or bodies) of the feature. This makes it possible
            to use features as input to booleans, change their color, and so on.
            It should raise an error if the feature has more than one body, but currently does not.
            </para>
            </remarks>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Feature.CommitFeature(NXOpen.Features.FeatureBuilder)">
            <summary>Commit feature with the given NX Open Feature</summary>
            <param name="featureBuilder">The NXOpen.Features.FeatureBuilder we want to commit</param>
            <returns>The resulting Snap.NX.Feature</returns>
        </member>
        <member name="M:Snap.NX.Feature.CheckHistoryMode">
            <summary>Throws an exception if NX is not in History mode</summary>
        </member>
        <member name="M:Snap.NX.Feature.Orphan">
            <summary>Remove parameters of this features</summary>
            <remarks>
            <para>
            As the name "orphan" implies, this function disconnects the feature from its "parent" objects.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Feature.Orphan(Snap.NX.Feature[])">
            <summary>Remove the parameters of features</summary>
            <param name="features">Features whose parameters are to be removed</param>
            <remarks>
            <para>
            As the name "orphan" implies, this function disconnects an object from its "parent" objects.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Feature.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Feature tag to a Snap.NX.Feature</summary>
            <param name="nxopenFeatureTag">The tag of an NXOpen.Features.Feature object to be converted</param>
            <returns>The Snap.NX.Feature object formed by wrapping the NXOpen.Features.Feature having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Feature object</exception>
        </member>
        <member name="T:Snap.NX.ICurve">
            <summary>Represents a Snap.NX.ICurve object -- either a curve or an edge.</summary>
            <example> 
            This example shows how to use the properties of the NX.ICurve class:
            <code title="Properties of an NX.ICurve object: " lang="VB.NET" source="Icurve_01.vb"> 
            </code> 
            </example>
            <seealso cref="N:Snap.NX">Snap.NX</seealso>
        </member>
        <member name="P:Snap.NX.ICurve.NXOpenICurve">
            <summary>Returns the NXOpen.ICurve of the object</summary>
        </member>
        <member name="P:Snap.NX.ICurve.NXOpenTag">
            <summary>The NXOpen.Tag of this NX.ICurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.NXOpenTaggedObject">
            <summary>The enclosed NXOpen.TaggedObject of this NX.ICurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.NXOpenDisplayableObject">
            <summary>The associated NXOpen.DisplayableObject of this NX.ICurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.StartPoint">
            <summary>Start point of the icurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.EndPoint">
            <summary>End point of the icurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.ArcLength">
            <summary>Arclength of the icurve</summary>
            <seealso cref= "M:Snap.Compute.ArcLength(Snap.NX.ICurve[])">Snap.Compute.ArcLength</seealso>
        </member>
        <member name="P:Snap.NX.ICurve.IsClosed">
            <summary>Periodic property of the icurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.Box">
            <summary>The 3D bounding box of the icurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.MinU">
            <summary>The lower u-value (at the start point of the curve)</summary>
        </member>
        <member name="P:Snap.NX.ICurve.MaxU">
            <summary>The upper u-value (at the end point of the curve)</summary>
        </member>
        <member name="P:Snap.NX.ICurve.ObjectType">
            <summary>The type of the icurve</summary>
        </member>
        <member name="P:Snap.NX.ICurve.ObjectSubType">
            <summary>The subtype of the icurve</summary>
        </member>
        <member name="M:Snap.NX.ICurve.Position(System.Double)">
            <summary>Calculates a point on the icurve at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Point</returns>
        </member>
        <member name="M:Snap.NX.ICurve.Derivative(System.Double)">
            <summary>Calculates the first derivative vector on the icurve at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>First derivative vector (not unitized)</returns>
            <remarks>
            <para>
            The vector returned is usually not a unit vector. In fact, it may even have zero length, occasionally.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.Derivatives(System.Double,System.Int32)">
            <summary>Calculates icurve derivatives (and position) at a given parameter value</summary>
            <param name="value">Parameter at which to evaluate</param>
            <param name="order">Order of highest derivative returned (zero for position alone)</param>
            <returns>Array of derivative vectors -- [0] is position, [1] is first derivative, etc.</returns>
        </member>
        <member name="M:Snap.NX.ICurve.Tangent(System.Double)">
            <summary>Calculates unit tangent vector at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit tangent vector</returns>
        </member>
        <member name="M:Snap.NX.ICurve.Normal(System.Double)">
            <summary>Calculates unit normal at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit normal vector</returns>
            <remarks>
            <para>
            The normal lies in the "osculating plane" of the curve at the given parameter value
            (the plane that most closely matches the curve). So, if the curve is planar, the normal always
            lies in the plane of the curve.
            </para>
            <para>
            The normal always points towards the center of curvature of the curve. So, if the curve
            has an inflexion, the normal will flip from one side to the other, which may be undesirable.
            </para>
            <para>
            The normal is the cross product of the binormal and the tangent: N = B*T
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.Binormal(System.Double)">
            <summary>Calculates the unit binormal at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Unit binormal</returns>
            <remarks>
            <para>
            The binormal is normal to the "osculating plane" of the curve at the given parameter value
            (the plane that most closely matches the curve). So, if the curve is planar, the binormal 
            is normal to the plane of the curve.
            </para>
            <para>
            The binormal is the cross product of the tangent and the normal: B = T*N
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.Curvature(System.Double)">
            <summary>Calculates curvature at a given parameter value</summary>
            <param name="value">Parameter value</param>
            <returns>Curvature value (always non-negative)</returns>
            <remarks>
            <para>
            Curvature is the reciprocal of radius of curvature. So, on a straight line,
            curvature is zero and radius of curvature is infinite. On a circle of radius 5,
            curvature is 0.2 (and radius of curvature is 5, of course).
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.Parameter(Snap.Position)">
            <summary>Calculates the parameter value at a point on the icurve</summary>
            <param name="point">The point</param>
            <returns>Parameter value at the point</returns>
            <remarks>
            <para>
            As usual in SNAP, the parameter value is not normalized to the range [0,1].
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.Parameter(System.Double,System.Double)">
            <summary>Calculates the parameter value defined by an arclength step along an icurve</summary>
            <param name="baseParameter">The curve parameter value at the starting location</param>
            <param name="arclength">The arclength increment along the icurve (the length of our step)</param>
            <returns>The curve parameter value at the far end of the step</returns>
            <remarks>
            <para>
            This function returns the curve parameter value at the far end of a "step" along an icurve.
            The start of the step is defined by a given parameter value, and the size of the step is given
            by an arclength along the icurve. The arclength step may be positive or negative.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.Parameter(System.Double)">
            <summary>Calculates the parameter value at a fractional arclength value along an icurve</summary>
            <param name="arclengthPercent">Percentage arclength along the icurve</param>
            <returns>Parameter value</returns>      
        </member>
        <member name="M:Snap.NX.ICurve.PositionArray(System.Int32)">
            <summary>Calculates an arrays of positions at equal arclengths on a curve or edge</summary>
            <param name="pointCount">The number of positions to be calculated on the curve</param>
            <returns>An array of positions on the curve</returns>
        </member>
        <member name="M:Snap.NX.ICurve.PositionArray(System.Double,System.Double,System.Double)">
            <summary>Calculates an array of positions on a curve corresponding to given tolerances</summary>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <param name="angularTolerance">The angular tolerance (in degrees)</param>
            <param name="stepTolerance">The chord-length tolerance</param>
            <returns>An array of positions on the curve</returns>
            <remarks>
            <para>
            A chord is a straight line between adjacent positions. 
            The tolerances provide independent values for controlling the positions located along the curve.
            <list type = "bullet">
            <item>The chord-height tolerance is the maximum allowable distance between chords and the curve. This is the distance D in the picture below.</item>
            <item>The angular tolerance is the maximum allowable sum of the angles between the chord and the tangents to the curve at the ends of the chord. This is the sum A1+A2
            in the picture below.</item>
            <item>The chord-length tolerance is the maximum allowable length of the chords, which is distance D in the picture.</item>
            </list>
            The following picture shows the meanings of the three tolerances:
            </para>
            <para>
            <img src="../Images/PositionArray_03.jpg"/>
            </para>
            If any of the input tolerances is zero, it is ignored, so it has no effect.
            Otherwise, the output positions will satisfy all the given tolerances.
            Note that the maximum values specified in the tolerances may not be attained;
            we only guarantee that they will not be exceeded.
            </remarks>
        </member>
        <member name="M:Snap.NX.ICurve.PositionArray(System.Double)">
            <summary>Calculates an array of positions on a curve corresponding to a given chord-height tolerance</summary>
            <param name="chordalTolerance">The chord-height tolerance</param>
            <remarks>
            <para>
            A chord is the straight line between adjacent positions on the curve. 
            The chord-height tolerance is the maximum allowable distance between a chord and the curve itself.
            </para>
            </remarks>
            <returns>An array of positions on the curve</returns>
        </member>
        <member name="T:Snap.NX.Line">
            <summary>
            Represents a Snap.NX.Line object (interchangeable with <see cref="T:NXOpen.Line">NXOpen.Line</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Line object, use the <see cref="O:Snap.Create.Line">Snap.Create.Line</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Line class:
            <code title="Properties of an NX.Line object: " lang="VB.NET" source="Line_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Line">Snap.Create.Line</seealso>
            <seealso cref="O:Snap.Create.LineTangent">Snap.Create.LineTangent</seealso>
            <seealso cref="M:Snap.Create.PolyLine(Snap.Position[])">Snap.Create.PolyLine</seealso>
            <seealso cref="O:Snap.Create.Rectangle">Snap.Create.Rectangle</seealso>   
        </member>
        <member name="P:Snap.NX.Line.NXOpenLine">
            <summary>The enclosed NXOpen.Line object</summary>
        </member>
        <member name="P:Snap.NX.Line.ObjectSubType">
            <summary>Subtypes of NX Line</summary>
        </member>
        <member name="P:Snap.NX.Line.Direction">
            <summary>A unit vector in the direction of the line</summary>
        </member>
        <member name="P:Snap.NX.Line.StartPoint">
            <summary>The start point of the line</summary>
        </member>
        <member name="P:Snap.NX.Line.EndPoint">
            <summary>The end point of the line</summary>
        </member>
        <member name="P:Snap.NX.Line.Prototype">
            <summary>
            Returns the prototype line of this one (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if this line is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Line.#ctor(NXOpen.Line)">
            <summary> Constructor, given an NXOpen.Line object</summary>
            <param name="line">An NXOpen.Line object</param>
        </member>
        <member name="M:Snap.NX.Line.op_Implicit(NXOpen.Line)~Snap.NX.Line">
            <summary>Implicit conversion of NXOpen.Line to NX.Line</summary>
            <param name="line">The NXOpen.Line to be converted (enclosed)</param>
            <returns>A new NX.Line object enclosing the given NXOpen.Line</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Line.op_Implicit(Snap.NX.Line)~NXOpen.Line">
            <summary>Implicit conversion of NX.Line to NXOpen.Line</summary>
            <param name="line">The NX.Line to be converted</param>
            <returns>The NXOpen.Line object enclosed by the given NX.Line</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Line.CreateLine(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates an NX.Line object</summary>
            <param name="x0">X-coordinate of start point</param>
            <param name="y0">Y-coordinate of start point</param>
            <param name="z0">Z-coordinate of start point</param>
            <param name="x1">X-coordinate of end   point</param>
            <param name="y1">Y-coordinate of end   point</param>
            <param name="z1">Z-coordinate of end   point</param>
            <returns>An NX.Line object</returns>
        </member>
        <member name="M:Snap.NX.Line.Copy">
            <summary>Copies an NX.Line object (with a null transform)</summary>
            <returns>A copy of the input line</returns>
            <remarks>
            <para>
            The new line will be on the same layer as the original one. 
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Line.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Arc</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Arc</returns>
        </member>
        <member name="M:Snap.NX.Line.Copy(Snap.NX.Line[])">
            <summary>Copies an array of NX.Line (with no transform)</summary>
            <param name="original">Original NX.Line array</param>
            <returns>A copy of the input lines</returns>
            <remarks>
            <para>
            The new lines will be on the same layers as the original ones. 
            </para>
            <para>
            The function will throw an NXOpen.NXException, if the copy operation cannot be performed.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Line.Copy(Snap.Geom.Transform,Snap.NX.Line[])">
            <summary>Transforms/copies an array of NX.Line objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Line array</param>
            <returns>A copy of the input lines</returns>
            <remarks>The function will throw NXOpen.NXException, when the operation is not correct</remarks>            
        </member>
        <member name="M:Snap.NX.Line.Divide(System.Double[])">
            <summary>Divide a line at an array of parameter values</summary>
            <param name="parameters">The parameter values at which the line should be divided</param>
            <returns>An array of <see cref="T:Snap.NX.Line">Snap.NX.Line</see> objects</returns>
            <remarks>The function will create new lines by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Line.Divide(Snap.NX.ICurve,Snap.Position)">
            <summary>Divide a line at an intersection with another curve</summary>
            <param name="boundingCurve">Bounding curve to be used to divide the given line</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Line">Snap.NX.Line</see> objects</returns>
            <remarks>The function will create two new lines by dividing the original one</remarks>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Line.Divide(Snap.NX.Face,Snap.Position)">
            <summary>Divide a line at an intersection with a given face</summary>
            <param name="face">A face to be used to divide the given line</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of <see cref="T:Snap.NX.Line">Snap.NX.Line</see> objects</returns>
            <remarks>The function will create two new lines by dividing the original one.</remarks>
            <example> 
            This example shows how to divide a line:
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_04.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Line.Divide(Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Divide a line at an intersection with a given plane</summary>
            <param name="geomPlane">A plane to be used to divide the given line</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of <see cref="T:Snap.NX.Line">Snap.NX.Line</see> objects</returns>
            <remarks>The function will create two new lines by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Line.LineArray(Snap.NX.Curve[])">
            To avoid having four identical copies of the same code
        </member>
        <member name="M:Snap.NX.Line.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Line tag to a Snap.NX.Line</summary>
            <param name="nxopenLineTag">The tag of an NXOpen.Line object to be converted</param>
            <returns>The Snap.NX.Line object formed by wrapping the NXOpen.Line having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Line object</exception>
            <example> 
            This example shows how to convert an NXOpen.Line tag to a Snap.NX.Line:
            <code title="Convert an NXOpen.Line tag to a Snap.NX.Line" lang="VB.NET" source="Line_09.vb"> 
            </code>
            </example>
        </member>
        <member name="T:Snap.NX.Matrix">
            <summary>
            Represents a Snap.NX.Matrix object (interchangeable with <see cref="T:NXOpen.NXMatrix">NXOpen.NXMatrix</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Matrix object, use the <see cref="O:Snap.Create.Matrix">Snap.Create.Matrix</see> functions.
            </para>
            <para>
            If you just want to represent an orientation in space, without creating an object in
            an NX part file, you can use a <see cref= "T:Snap.Orientation">Snap.Orientation</see> object, instead.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Matrix class:
            <code title="Properties of an NX.Matrix object: " lang="VB.NET" source="Matrix_03.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Matrix">Snap.Create.Matrix</seealso>
        </member>
        <member name="P:Snap.NX.Matrix.NXOpenTag">
            <summary>Get the NXOpen.Tag from this NX.Matrix</summary>
        </member>
        <member name="P:Snap.NX.Matrix.NXOpenMatrix">
            <summary>The enclosed NXOpen.NXMatrix object</summary>
        </member>
        <member name="P:Snap.NX.Matrix.AxisX">
            <summary>X-axis of rotated frame</summary>
        </member>
        <member name="P:Snap.NX.Matrix.AxisY">
            <summary>Y-axis of rotated frame</summary>
        </member>
        <member name="P:Snap.NX.Matrix.AxisZ">
            <summary>Z-axis of rotated frame</summary>
        </member>
        <member name="P:Snap.NX.Matrix.Orientation">
            <summary>Orientation of matrix</summary>
        </member>
        <member name="M:Snap.NX.Matrix.#ctor(NXOpen.NXMatrix)">
            <summary>Constructs An NX.Matrix from an NXOpen.NXMatrix</summary>
            <param name="matrix">The NXOpen..NXMatrix object</param>
        </member>
        <member name="M:Snap.NX.Matrix.#ctor(Snap.Vector,Snap.Vector,Snap.Vector)">
            <summary>Constructor, given three vectors</summary>
            <param name="axisX">X-axis vector</param>
            <param name="axisY">Y-axis vector</param>
            <param name="axisZ">Z-axis vector</param>
        </member>
        <member name="M:Snap.NX.Matrix.#ctor(Snap.Orientation)">
            <summary>Constructor, given an orientation</summary>
            <param name="rotation">The orientation (rotation)</param>
        </member>
        <member name="M:Snap.NX.Matrix.op_Implicit(NXOpen.NXMatrix)~Snap.NX.Matrix">
            <summary>Implicit conversion of NXOpen.NXMatrix to NX.Matrix</summary>
            <param name="matrix">The NXOpen.NXMatrix to be converted (enclosed)</param>
            <returns>A new NX.Matrix object enclosing the given NXOpen.NXMatrix</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Matrix.op_Implicit(Snap.NX.Matrix)~NXOpen.NXMatrix">
            <summary>Implicit conversion of NX.Matrix to NXOpen.NXMatrix</summary>
            <param name="matrix">The NX.Matrix to be converted</param>
            <returns>The NXOpen.NXMatrix object enclosed by the given NX.Matrix</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Matrix.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.NXMatrix tag to a Snap.NX.Matrix</summary>
            <param name="nxopenMatrixTag">The tag of an NXOpen.NXMatrix object to be converted</param>
            <returns>The Snap.NX.Matrix object formed by wrapping the NXOpen.NXMatrix having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.NXMatrix object</exception>
        </member>
        <member name="T:Snap.NX.NamespaceDoc">
            <summary>
            Contains classes representing NX objects. These classes provide
            rich sets of properties that you can use to analyze and modify the objects.
            </summary>
        </member>
        <member name="T:Snap.NX.Note">
            <summary>
            Represents a Snap.NX.Note (interchangeable with <see cref="T:NXOpen.Annotations.PmiNote">NXOpen.Annotations.PmiNote</see>)
            </summary>
            <remarks>  
            <para>
            To create an NX.Note object, use the <see cref="O:Snap.Create.Note">Snap.Create.Note</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Note class:
            <code title="Properties of an NX.Note object: " lang="VB.NET" source="Note_03.vb"> 
            </code>
            </example>
            <seealso cref="O:Snap.Create.Note">Snap.Create.Note</seealso>
        </member>
        <member name="P:Snap.NX.Note.NXOpenNote">
            <summary>The enclosed NXOpen.Annotations.BaseNote object</summary>
            <remarks>
            <para>
            In a sense, there are two kinds of Snap.NX.Note objects: those that
            enclose an NXOpen.Annotations.PmiNote object, and those that enclose
            an NXOpen.Annotations.Note object. The Snap.NX.Note objects created by SNAP
            functions are always of the first kind. But, when cycling through
            the NX.Part.Notes array, you may encounter notes of the second kind. In many
            situations, this doesn't matter, since the properties of the two kinds
            of enclosed objects are essentially identical.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Note.NoteBuilder">
            <summary>The NXOpen.Annotations.PmiNoteBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Note object.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Annotations.PmiNoteBuilder">NXOpen.Annotations.PmiNoteBuilder</seealso>
        </member>
        <member name="P:Snap.NX.Note.Origin">
            <summary>The position of the origin of the note</summary>
        </member>
        <member name="P:Snap.NX.Note.Text">
            <summary>The text of the note -- an array of lines of text</summary>
        </member>
        <member name="P:Snap.NX.Note.FontIndex">
            <summary>The index of the note's font within the part file's font table</summary>
            <remarks>
            <para>
            It is this index that actually determines the font used to display the note, not the font name. 
            Therefore, if the entries in the font table are re-organized, the note may use a
            different font, so the appearance of the text will change.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Note.FontName">
            <summary>The name of the primary font used within the note</summary>
            <remarks>
            <para>
            When setting this property, we first try to find a system (TrueType) font with the given name.
            If this fails, we look for a traditional NX font, instead. If you want more control over the
            search process, please use the SetFont function, instead.
            </para>
            </remarks>
            <seealso cref="M:Snap.NX.Note.SetFont(System.String,Snap.NX.TextStyle.FontType)">Snap.NX.Note.SetFont</seealso>
        </member>
        <member name="P:Snap.NX.Note.StrokeWidth">
            <summary>The width (thickness) of the strokes used to draw the font</summary>
            <remarks>
            <para>
            The stroke thickness property is only relevant for traditional NX fonts.
            Truetype fonts are not drawn with strokes, so this property doesn’t make sense.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Note.FontSize">
            <summary>The font size (in points)</summary>
        </member>
        <member name="P:Snap.NX.Note.Color">
            <summary>The color of the note (as a System.Drawing.Color)</summary>
            <remarks>
            <para>
            When the object color is set, NX will not necessarily honor the request.
            NX chooses the color from its current color table that is closest to
            the requested color.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Note.CharSpaceFactor">
            <summary>A multiplier used to adjust the spacing between characters</summary>
        </member>
        <member name="P:Snap.NX.Note.AspectRatio">
            <summary>A multiplier used to adjust the shapes of characters. Values greater than 1 will make characters wider than normal. </summary>
        </member>
        <member name="P:Snap.NX.Note.LineSpaceFactor">
            <summary>A multiplier used to adjust the spacing between lines of text</summary>
        </member>
        <member name="P:Snap.NX.Note.HorizontalTextJustification">
            <summary>The horizontal justification of the text (left, center, or right)</summary>
            <remarks>This takes effect only when the note has two or more lines of text.</remarks>
        </member>
        <member name="P:Snap.NX.Note.AlignmentPosition">
            <summary>One of nine "sites" used to locate the text</summary>
            <example>
            The following example creates notes with different alignment types:
            <code title="Create notes" lang="VB.NET" source="Note_04.vb">
            </code>
            </example>
        </member>
        <member name="P:Snap.NX.Note.LineAngle">
            <summary>The angle between the baseline of the text and the horizontal</summary>
        </member>
        <member name="P:Snap.NX.Note.IsVertical">
            <summary>If true, indicates that the text will be oriented vertically, not horizontally</summary>
            <remarks>
            <para>
            In "vertical" text, the characters are still upright, but are arranged in a vertical column. 
            If you want to take a line of text and simply rotate it into a vertical position, you should
            </para>
            set LineAngle equal to plus or minus 90 degrees.
            </remarks>
        </member>
        <member name="P:Snap.NX.Note.Orientation">
            <summary>The orientation of the note</summary>
            <remarks>
            <para>
            The text lies in a plane parallel to the X and Y axes of the orientation, and the baseline of the text is parallel to the X-axis.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Note.#ctor(NXOpen.Annotations.BaseNote)">
            <summary> Constructor, given an NXOpen.Annotations.BaseNote object</summary>
            <param name="note">An NXOpen.Annotations.BaseNote object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Note.op_Implicit(NXOpen.Annotations.BaseNote)~Snap.NX.Note">
            <summary> Implicit conversion of NXOpen.Annotations.PmiNote to NX.Note</summary>
            <param name="note"> An NXOpen.Annotations.PmiNote object</param>
            <returns>The corresponding NX.Note object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Note.op_Implicit(Snap.NX.Note)~NXOpen.Annotations.BaseNote">
            <summary> Implicit conversion of NX.Note to NXOpen.Annotations.BaseNote</summary>
            <param name="note"> AN NX.Note object</param>
            <returns>The enclosed NXOpen.Annotations.PmiNote object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Note.CreateNote(System.String[],Snap.Position,Snap.Orientation,Snap.NX.TextStyle)">
            <summary>Creates a PMI note</summary>
            <param name="text">Lines of text</param>
            <param name="origin">Origin (in absolute coordinates)</param>
            <param name="matrix">Matrix -- AxisX gives the "horizontal"</param>
            <param name="textStyle">Style info</param>
            <returns>An NX.Note object</returns>
            <remarks>
            <para>
            The note lies in a plane parallel to the vectors matrix.AxisX and matrix.AxisY, with matrix.AxisX forming the horizontal.
            </para>
            <para>
            If the input textStyle is <c>Nothing</c>, then formatting information comes from the settings in Annotation Preferences.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Note.SetFont(System.String,Snap.NX.TextStyle.FontType)">
            <summary>Sets the primary font to be used in the note</summary>
            <param name="fontName">The name of the font to be used</param>
            <param name="fontType">The type of font (either a standard system font or an NX font)</param>
        </member>
        <member name="M:Snap.NX.Note.Copy">
            <summary>Copies an NX.Note (with a null transform)</summary>
            <returns>A copy of the input Note</returns>
            <remarks>
            <para>
            The new note will be on the same layer as the original one. 
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Note.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Note</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Note</returns>      
        </member>
        <member name="M:Snap.NX.Note.Copy(Snap.NX.Note[])">
            <summary>Copies an array of NX.Note (with no transform)</summary>
            <param name="original">Original NX.Note array</param>
            <returns>A copy of the input notes</returns>
            <remarks>
            <para>
            The new notes will be on the same layers as the original ones. 
            </para>
            <para>
            The function will throw an NXOpen.NXException, if the copy operation cannot be performed.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Note.Copy(Snap.Geom.Transform,Snap.NX.Note[])">
            <summary>Transforms/copies an array of NX.Note objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Note array</param>
            <returns>A copy of the input notes</returns>
            <remarks>The function will throw NXOpen.NXException, when the operation is not correct</remarks>            
        </member>
        <member name="M:Snap.NX.Note.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Annotations.PmiNote tag to a Snap.NX.Note</summary>
            <param name="nxopenNoteTag">The tag of an NXOpen.Annotations.PmiNote object to be converted</param>
            <returns>The Snap.NX.Note object formed by wrapping the NXOpen.Annotations.PmiNote having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Annotations.PmiNote object</exception>
        </member>
        <member name="T:Snap.NX.NXObject">
            <summary>
            Represents a Snap.NX.NXObject object (interchangeable with <see cref="T:NXOpen.TaggedObject">NXOpen.NxObject</see>)
            </summary>
            <example> 
            This example shows how to use the properties of the NX.NXObject class:
            <code title="Properties of an NX.NXObject object: " lang="VB.NET" source="Object_01.vb"></code> 
            </example>   
        </member>
        <member name="P:Snap.NX.NXObject.NXOpenTaggedObject">
            <summary>The enclosed NXOpen.TaggedObject of this NX.NXObject</summary>
            
            <remarks>
            <para>
            A SNAP object is just a simple wrapper around a corresponding NX Open object � for 
            example, a Snap.NX.Spline object is just a wrapper that encloses an NXOpen.Spline, 
            and a Snap.NX.Sphere is a wrapper around an NXOpen.Features.Sphere object, and so on. 
            So, if you have an NXOpen object, you can �wrap� it to create a Snap.NX object. 
            In the other direction, if you have a Snap.NX object, you can �unwrap� it to get 
            the NXOpen object that it encloses.
            </para>
            <para>
            There are hidden �implicit� conversions that do this wrapping and unwrapping for you, 
            so often things just work without any extra effort. 
            However, there are times when the implicit conversions don�t work, and you need to 
            do something more explicit. For example, if you want to use NXOpen member functions 
            or properties, then you have to get an NXOpen object from your SNAP object first.
            </para>
            <para>
            Chapter 16 of the SNAP Getting Started Guide has a section entitled "Mixing SNAP
            and NX/Open" that discusses this topic in more detail.
            </para>
            </remarks>
            <seealso cref= "M:Snap.NX.NXObject.Wrap(NXOpen.Tag)">Snap.NX.NXObject.Wrap</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.NXOpenTag">
            <summary>Get the NXOpen.Tag from this NX.NXObject</summary>
        </member>
        <member name="M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">
            <summary>Tests whether this NXObject is "equal to" another NXObject</summary>
            <param name="other">The other NXObject to be used in the equality test</param>
            <returns>Returns <c>True</c> if this object is equal to the other one</returns>
            <remarks>
            <para>
            Two NXObject instances are regarded as equal if their enclosed NXOpen objects are equal
            (which means that the NXOpen objects have the same tag).
            </para>
            <para>
            Note that "equal" here is only loosely related to the geometry of the object.
            If two Point objects are "equal", for example, then they will certainly have the same
            coordinates, but the converse is not true.
            </para>
            Your code may be more readable if you use 
            <see cref="M:Snap.NX.NXObject.op_Equality(Snap.NX.NXObject,Snap.NX.NXObject)">the <c>=</c> operator</see> or 
            <see cref="M:Snap.NX.NXObject.op_Inequality(Snap.NX.NXObject,Snap.NX.NXObject)">the <c>&lt;&gt;</c> operator</see>
            to check whether two NXObject items are equal, as in the example below.
            </remarks>
            <example> 
            The following example shows various diffent equality situations and tests: 
            <code title="Testing NXObject equality" lang="VB.NET" source="Equals_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.NX.NXObject.op_Equality(Snap.NX.NXObject,Snap.NX.NXObject)">The <c>=</c> operator</seealso> or 
            <seealso cref="M:Snap.NX.NXObject.op_Inequality(Snap.NX.NXObject,Snap.NX.NXObject)">The <c>&lt;&gt;</c> operator</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Equals(System.Object)">
            <summary>Over-rides the System.Object.Equals method</summary>
            <param name="other">The other object to be used in the equality test</param>
            <returns>Returns <c>True</c> if this object is equal to the other one</returns>
            <remarks>
            <para>
            Equality is <c>True</c> if the other object is of type NXObject, and is equal
            to this object based on the NXObject.Equals method.
            </para>
            <para>
            Please refer to 
            <see cref= "M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">NXObject.Equals</see>
            for a discussion of what it means for two NXObject items to be "equal".
            </para>
            </remarks>
            <seealso cref= "M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">NXObject.Equals</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.GetHashCode">
            <summary>Serves as a hash function for the NXObject type</summary>
            <returns>Hash value</returns>
            <remarks>
            <para>
            The hash code is used to locate objects in lists and dictionaries, for example.
            You probably won't use this function directly in your code.
            </para>
            </remarks>
            <example> 
            The following example shows the hash codes of several NXObject items: 
            <code title="Hash codes" lang="VB.NET" source="Equals_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.op_Equality(Snap.NX.NXObject,Snap.NX.NXObject)">
            <summary>
            Tests whether two NXObject instances are equal
            </summary>
            <param name="left">One NXObject</param>
            <param name="right">The other NXObject</param>
            <returns>Returns <c>True</c> if the two objects are equal</returns>
            <remarks>
            <para>
            Please refer to 
            <see cref= "M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">NXObject.Equals</see>
            for a discussion of what it means for two NXObject items to be "equal".
            </para>
            </remarks>
            <seealso cref= "M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">NXObject.Equals</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.op_Inequality(Snap.NX.NXObject,Snap.NX.NXObject)">
            <summary>
            Tests whether two NXObject instances are unequal
            </summary>
            <param name="left">One NXObject</param>
            <param name="right">The other NXObject</param>
            <returns>Returns <c>True</c> if the two objects are different (unequal)</returns>
            <remarks>
            <para>
            Please refer to 
            <see cref= "M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">NXObject.Equals</see>
            for a discussion of what it means for two NXObject items to be "equal".
            </para>
            </remarks>
            <seealso cref= "M:Snap.NX.NXObject.Equals(Snap.NX.NXObject)">NXObject.Equals</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.ObjectType">
            <summary>The type of the object</summary>
            <remarks>
            <para>
            Note that SNAP object types are somewhat different from NX/Open ones.
            The biggest difference is in the area of bodies, faces, and edges.
            In NX/Open these all have type = UF_solid_type, but in SNAP there are three
            separate types: NX.ObjectTypes.Type.Body, NX.ObjectTypes.Type.Face,
            and NX.ObjectTypes.Type.Edge.
            </para>
            <para>
            Also, we have specific types for the SNAP DatumPlane and DatumAxis
            objects, whereas the corresponding NXOpen objects are just "features".
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.ObjectTypes.Type">The ObjectTypes.Type enumeration.</seealso>
            <seealso cref="T:Snap.NX.ObjectTypes.SubType">The ObjectTypes.SubType enumeration.</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.IsAlive(NXOpen.TaggedObject)">
            <summary>If true, indicates that the enclosed NXOpen object is "alive"</summary>
            <remarks>
            <para>
            Returns "False" if the input object is null.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.NXObject.ObjectSubType">
            <summary>The subtype of the object</summary>
            <remarks>
            <para>
            Note that SNAP object subtypes are somewhat different from NX/Open ones.
            </para>
            <para>
            One difference is in the area of bodies, face, and edges.
            In SNAP, these are three different object types, and their subtypes provide
            useful information about their geometry. For example the Body type
            has subtypes BodySolid and BodySheet, the Face type has subtypes
            FacePlane and FaceCone, and so on.
            </para>
            <para>
            Another difference is that SNAP subtypes are unique, so you can use them
            alone, without considering object types. So, for example, the expression
            <c>myCurve.ObjectSubtype = NX.ObjectTypes.SubType.ConicEllipse</c> will be
            true if and only if myCurve is an ellipse. There is no need to do a
            separate check to see if it is a conic.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.ObjectTypes.Type">The ObjectTypes.Type enumeration.</seealso>
            <seealso cref="T:Snap.NX.ObjectTypes.SubType">The ObjectTypes.SubType enumeration.</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.HasDisplayProperties">
            <summary>If true, indicates (roughly) that this object is displayable</summary>
            <remarks>
            <para>
            In fact, the HasDisplayProperties property is true if and only if the object's
            <see cref= "P:Snap.NX.NXObject.NXOpenDisplayableObjects">NXOpenDisplayableObjects</see>
            array has length greater than zero.
            </para>
            <para>      
            So, then, you may get and set display properties like layer and color.
            </para>
            <para>
            If HasDisplayProperties is True, this is not quite the same thing as saying that the object
            is itself displayable. For example, a cone feature is not displayable, but it will have
            HasDisplayProperties = True because display properties can be obtained from the
            associated solid body (which is a displayable object).
            </para>
            </remarks>
            <example>
            This example shows how you might use this property:
            <code title="Using the HasDisplayProperties property: " lang="VB.NET" source="Object_04.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.NXObject.NXOpenDisplayableObjects">NXOpenDisplayableObjects</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects of this NX.NXObject</summary>
            <remarks>
            <para>
            Usually, this is just an array of length one containing the 
            enclosed NXOpenTaggedObject. But, in the case of a feature,
            this definition needs to be over-ridden, so we declare it Overridable here.
            </para>
            <para>
            There are some objects (like layer categories, for example) that have no
            corresponding displayable objects. In these cases, this function returns
            an array of length zero.
            </para>
            <para>
            You can use the <see cref= "P:Snap.NX.NXObject.HasDisplayProperties">HasDisplayProperties</see>
            property to check whether an object has any associated displayable objects.
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.HasDisplayProperties">NXObject.HasDisplayProperties</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.NXOpenDisplayableObject">
            <summary>The associated NXOpen.DisplayableObject of this NX.NXObject</summary>
            <remarks>
            <para>
            Usually, this is just the enclosed NXOpenTaggedObject, but, in the case of a features,
            this definition needs to be over-ridden, so we declare it Overridable here.
            </para>
            <para>
            The returned value will be <c>Nothing</c> if there is no corresponding
            displayable object.
            </para>
            <para>
            Unless it's <c>Nothing</c>, the NXOpenDisplayableObject property always has the same 
            value as NXOpenDisplayableObjects[0], so it's just a convenience shortcut.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.NXObject.Layer">
            <summary>The layer on which the object resides</summary>
            <remarks>
            <para>
            If the object's <see cref="P:Snap.NX.NXObject.HasDisplayProperties">HasDisplayProperties</see>
            property is False, then getting or setting the Layer property will raise an exception.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>
        </member>
        <member name="P:Snap.NX.NXObject.LineWidth">
            <summary>The line width used to draw the object (thin, medium, or thick)</summary>
            <remarks>
            <para>
            If the object's <see cref="P:Snap.NX.NXObject.HasDisplayProperties">HasDisplayProperties</see>
            property is False, then getting or setting the LineWidth property will raise an exception.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>
        </member>
        <member name="P:Snap.NX.NXObject.LineFont">
            <summary>The line font used to draw the object (solid, dashed, etc.)</summary>
            <remarks>
            <para>
            If the object's HasDisplayProperties property is False, then getting or setting 
            the LineFont property will raise an exception.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>
        </member>
        <member name="P:Snap.NX.NXObject.Color">
            <summary>The color of the object (as a System.Drawing.Color)</summary>
            <remarks>
            <para>
            When the object color is set, NX will not necessarily honor the request.
            NX chooses the color from its current color table that is closest to
            the requested color.
            </para>
            <para>
            If the object's HasDisplayProperties property is False, then getting or setting 
            the Color property will raise an exception. 
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>
        </member>
        <member name="P:Snap.NX.NXObject.Translucency">
            <summary>The translucency of the object</summary>
            <remarks>
            <para>
            The translucency value is an integer between 0 and 100. A value of 0 indicates that the
            object is completely opaque (no translucency at all). A value of 100 indicates that
            the object is completely translucent, and therefore invisible.
            </para>
            <para>
            The setting only has a visible effect if the object is a body (solid or sheet)
            or a facetted body.
            </para>
            <para>
            If the object's HasDisplayProperties property is False, then getting or setting 
            the Translucency property will raise an exception. 
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>>
        </member>
        <member name="P:Snap.NX.NXObject.IsHidden">
            <summary>If true, indicates that the object is hidden (blanked)</summary>
            <remarks>
            <para>
            If the object's <see cref="P:Snap.NX.NXObject.HasDisplayProperties">HasDisplayProperties</see>
            property is False, then getting or setting the IsHidden property will raise an exception.
            </para>
            <para>
            You can hide an object by setting its IsHidden property to True, and Show it by
            setting IsHidden = False.
            </para>
            <para>
            If you want to Hide or Show several objects, it may be more convenient to use the
            <see cref= "M:Snap.NX.NXObject.Hide(Snap.NX.NXObject[])">Hide</see> and
            <see cref= "M:Snap.NX.NXObject.Show(Snap.NX.NXObject[])">Show</see> functions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>
        </member>
        <member name="P:Snap.NX.NXObject.IsHighlighted">
            <summary>If true, indicates that the displayable object is highlighted</summary>
            <remarks>
            <para>
            If the object's <see cref="P:Snap.NX.NXObject.HasDisplayProperties">HasDisplayProperties</see>
            property is False, then getting or setting the IsHighlighted property will raise an exception.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">This object is of a type that has no display properties.</exception>
        </member>
        <member name="P:Snap.NX.NXObject.Box">
            <summary>The bounding box of the object</summary>
            <remarks>
            <para>
            The Box property is implemented only for curves, edges, faces, bodies, features, and components.
            For other object types, getting the property will return <c>Nothing</c>, and will throw
            a System.ArgumentException.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input object is not of a type that can be boxed</exception>
        </member>
        <member name="P:Snap.NX.NXObject.Name">
            <summary>The name of the object (also called "custom name")</summary>
        </member>
        <member name="P:Snap.NX.NXObject.NameLocation">
            <summary>The position at which the name of the object is displayed</summary>
        </member>
        <member name="P:Snap.NX.NXObject.IsOccurrence">
            <summary>
            If true, indicates that this object is an occurrence.
            </summary>
            <remarks>
            <para>
            Occurrences are created when a part is inserted into an assembly.
            The inserted part gives rise to a component in the assembly part, and each
            object in the inserted part gives rise to an occurrence.
            An occurrence object can be regarded as a "proxy" for the 
            corresponding object in the inserted part (which is called
            its "prototype").
            </para>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concept of occurrences. 
            </para>
            </remarks>     
            <example> 
            The following example shows the use of the IsOccurrence property: 
            <code title="Finding occurrences" lang="VB.NET" source="Object_02.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">Snap.NX.NXObject.Prototype</seealso>
            <seealso cref= "T:Snap.NX.Component">Snap.NX.Component</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.Prototype">
            <summary>
            Returns the prototype object of this object (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the object is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <example> 
            The following example shows the use of the Prototype property: 
            <code title="Getting prototype objects" lang="VB.NET" source="Object_02.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="P:Snap.NX.NXObject.OwningComponent">
            <summary>
            Returns the owning component of this object (if it has one)
            </summary>
            <remarks>
            <para>
            Only occurrence objects have an owning component, so this property
            returns <c>Nothing</c> if the object is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            <para>
            Occurrences are created when a part is inserted into an assembly.
            In the assembly, the inserted part gives rise to a component, and each
            object in the inserted part gives rise to an object occurrence.
            The component is said to be the "owner" of the object occurrences,
            and they are said to be its "members".
            </para>
            <para>
            See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concept of occurrences. 
            </para>
            </remarks>     
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</seealso> property
            <seealso cref= "T:Snap.NX.Component">Snap.NX.Component</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.ToString">
            <summary>
            Returns a string representation of the object
            </summary>
            <returns>A string containing the object type and its NXOpen tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this object is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.#ctor(NXOpen.NXObject)">
            <summary>Construct an NXObject, given an NXOpen.NXObject object</summary>
            <param name="nxopenObject">An NXOpen.NXObject</param>
        </member>
        <member name="M:Snap.NX.NXObject.#ctor(NXOpen.Tag)">
            <summary>Construct an NXObject, given an NXOpen.Tag</summary>
            <param name="objectTag">An NXOpen.Tag</param>
        </member>
        <member name="M:Snap.NX.NXObject.CreateNXObject(NXOpen.TaggedObject)">
            <summary>
            Creates an NX.NXObject of the most specific type possible
            </summary>
            <param name="nxopenTaggedObject">The input NXOpen.TaggedObject</param>
            <returns>An NX.NXObject which has the most specific type possible</returns>
            <remarks>
            <para>
            The returned object's static type is still NX.NXObject, but, where
            possible, the NX.NXObject variable now contains an object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller. This is used in Selection, for example.
            </para>
            <para>
            This function should be used instead of the NX.NXObject constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.CreateNXObject2(NXOpen.TaggedObject)">
            <summary>Creates an NX.NXObject of the most specific type possible</summary>
            <param name="nxopenTaggedObject">The input NXOpen.TaggedObject</param>
            <returns>An NX.NXObject which has the most specific type possible</returns>
            <remarks>
            <para>
            Same as CreateNXObject, except that this function ...
               creates a Snap.NX.DatumPlane when given the tag of an NXOpen.DatumPlane, and it 
               creates a Snap.NX.DatumAxis  when given the tag of an NXOpen.DatumAxis.
            This behaviour is useful when returning selection results. If we didn't do this,
            the object returned from Selection would be a generic Snap.NX.NXObject
            enclosing an NXOpen.DatumPlane, which is not very useful to the caller.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.GetTypeFromTag(NXOpen.Tag)">
            <summary>
            Gets corresponding Snap type of an object, given a tag
            </summary>
            <param name="nxopenTag">Tag of NXOpen object that we're planning to insert into some Snap.NX.NXObject</param>
            <returns>Snap type of the "best" enclosing Snap object we could conceivably create</returns>
        </member>
        <member name="M:Snap.NX.NXObject.GetObjectFromTag(NXOpen.Tag)">
            <summary>Get an NXOpen.NXObject from a given NXOpen.Tag</summary>
            <param name="tag"></param>
            <returns>An NXOpen.NXObject, or null</returns>
            <remarks>
            <para>
            Returns null if the given tag does not correspond to an NXOpen.NXObject
            (either because it has no corresponding object at all, or because the
            corresponding object has the wrong type).
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.op_Implicit(Snap.NX.NXObject)~NXOpen.TaggedObject">
            <summary> Implicit conversion of NX.NXObject to NXOpen.TaggedObject</summary>
            <param name="entity">An NX.NXObject</param>
            <returns>The corresponding NXOpen.TaggedObject</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.NXObject.op_Implicit(NXOpen.NXObject)~Snap.NX.NXObject">
            <summary> Implicit conversion of NXOpen.NXObject to NX.NXObject</summary>
            <param name="entity">An NXOpen.NXObject</param>
            <returns>The corresponding NX.NXObject</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.NXObject.CopyToLayer(System.Int32,Snap.NX.NXObject[])">
            <summary>Copies objects to the specified layer</summary>
            <param name="newLayer">The layer to copy the objects to</param>
            <param name="nxobjectArray">The objects to be copied</param>      
            <remarks>
            <para>
             Objects of class NXOpen.Assemblies.Component, NXOpen.DatumAxis, NXOpen.DatumPlane, NXOpen.Edge, 
             NXOpen.Face, NXOpen.Features.Feature or NXOpen.View, may not be copied.
            </para>
            </remarks>
            <example> 
            This example shows how to manipulate layers " 
            <code title="Manipulate layers " lang="VB.NET" source="Globals_05.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.NXObject.MoveToLayer(System.Int32,Snap.NX.NXObject[])">
            <summary>Moves displayable objects to the specified layer.</summary>
            <param name="newLayer">The layer to move the objects to</param>
            <param name="nxobjectArray">The objects to be moved</param>
            <remarks>      
            <para>
            Another way to move an object to a new layer is to set its
            <see cref = "P:Snap.NX.NXObject.Layer">Layer</see> property. This function
            may be more convenient since it allows you to move several objects
            all at once.
            </para>
            </remarks>
            <example> 
            This example shows how to work with layers " 
            <code title="Manipulate layers " lang="VB.NET" source="Globals_05.vb"> 
            </code> 
            </example>
            <seealso cref = "P:Snap.NX.NXObject.Layer">NXObject.Layer</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Delete(Snap.NX.NXObject[])">
            <summary>Deletes an array of NXObject objects</summary>
            <param name="nxObjects">The objects to delete</param>      
        </member>
        <member name="M:Snap.NX.NXObject.Delete">
            <summary>Deletes an NX.NXObject</summary>
        </member>
        <member name="M:Snap.NX.NXObject.Copy">
            <summary>Copies an NX.NXObject (with no transform)</summary>
            <returns>A copy of the input object</returns>
            <remarks>
            <para>
            The new object will be on the same layer as the original one.
            </para>
            </remarks>      
            <exception cref="T:System.ArgumentException">The object is an edge. Edges cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">The object is a face. Faces cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">A feature cannot be copied unless all of its ancestors are copied too.</exception>
        </member>
        <member name="M:Snap.NX.NXObject.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an object</summary>
            <param name="xform">Transform to be applied</param>
            <returns>Output object</returns>
            <exception cref="T:System.ArgumentException">The object is an edge. Edges cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">The object is a face. Faces cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">A feature cannot be copied unless all of its ancestors are copied too.</exception>
            <exception cref="T:System.ArgumentException">A transform that does not preserve angles cannot be applied to a coordinate system.</exception>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Copy(Snap.NX.NXObject[])">
            <summary>Copies an array of NX.NXObject (with no transform)</summary>
            <param name="original">Original NX.NXObject array</param>
            <returns>A copy of the input objects</returns>
            <remarks>
            <para>
            The new objects will be on the same layers as the original ones. 
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">One of the input objects is an edge. Edges cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">One of the input objects is a face. Faces cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">A feature cannot be copied unless all of its ancestors are copied too.</exception>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Copy(Snap.Geom.Transform,Snap.NX.NXObject[])">
            <summary>Transforms/copies an array of NX objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.NXObject array</param>
            <returns>A copy of the input objects</returns>
            <exception cref="T:System.ArgumentException">One of the input objects is an edge. Edges cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">One of the input objects is a face. Faces cannot be copied.</exception>
            <exception cref="T:System.ArgumentException">A feature cannot be copied unless all of its ancestors are copied too.</exception>
            <exception cref="T:System.ArgumentException">A transform that does not preserve angles cannot be applied to a coordinate system.</exception>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Move(Snap.Geom.Transform)">
            <summary>Transform/Move an object</summary>
            <param name="xform">Transform to be applied</param>
            <returns>Error code. If positive, this indicates a problem. See Remarks below for details.</returns> 
            <exception cref="T:System.ArgumentException">The object is an edge. Edges cannot be moved.</exception>
            <exception cref="T:System.ArgumentException">The object is a face. Faces cannot be moved.</exception>
            <exception cref="T:System.ArgumentException">A feature cannot be moved, because its position is controlled by its parents.</exception>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            <para>
            The error code returned reports success or failure. If zero, it indicates that the Move operation was successful.
            If greater than zero, some problem arose, as described in the documentation for the function
            <c>NXOpen.Ufs.Trns.TransformObjects (uf5947)</c>. 
            Most error conditions are reported by raising
            exceptions, so this return value is not likely to be very useful. 
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Move(Snap.Geom.Transform,Snap.NX.NXObject[])">
            <summary>Transform/Move an array of objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.NXObject array</param>
            <exception cref="T:System.ArgumentException">One of the input objects is an edge. Edges cannot be moved.</exception>
            <exception cref="T:System.ArgumentException">One of the input objects is a face. Faces cannot be moved.</exception>
            <exception cref="T:System.ArgumentException">A feature cannot be moved, because its position is controlled by its parents.</exception>
            <remarks>
            <para>
            To create a transformation, use the functions in the
            <see cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</see>  class.
            </para>
            </remarks>
            <seealso cref = "T:Snap.Geom.Transform">Snap.Geom.Transform</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.FindAllByName(System.String)">
            <summary>Find all the objects in the work part that have a given name</summary>
            <param name="name">Name of the objects</param>
            <returns>An array of NX.NXObject objects having the given name</returns>
            <remarks>
            <para>
            This function returns an array, since there may be several objects having the same name.
            </para>
            <para>
            If there are no objects having the given name, the array will have length zero.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.NXObject">Snap.NX.NXObject</seealso>
            <seealso cref="M:Snap.NX.NXObject.FindByName(System.String)">Snap.NX.NXObject.FindByName</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.FindByName(System.String)">
            <summary>Find the first object in the work part that has a given name</summary>
            <param name="name">Name of the object</param>
            <returns>An NX.NXObject object having the given name</returns>
            <remarks>
            <para>
            This function finds the first object in the work part that has the given name.
            If the work part contains several objects with the same name, 
            the result will be unpredictable.
            In this case, you should use the FindAllByName function, instead.
            </para>
            <para>
            The return will be <c>Nothing</c> if there are no objects in the work part
            that have the given name.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.NXObject">Snap.NX.NXObject</seealso>
            <seealso cref="M:Snap.NX.NXObject.FindAllByName(System.String)">Snap.NX.NXObject.FindAllByName</seealso>
        </member>
        <member name="M:Snap.NX.NXObject.Hide(Snap.NX.NXObject[])">
            <summary>Hides (Blanks) an array of NXObject objects</summary>
            <param name="nxObjectArray">The objects to hide</param>      
            <remarks>
            <para>
            In former times, the "Hide" function was known as "Blank".
            Only the name has changed; the operation is exactly the same as before.
            </para>
            <para>
            Another way to Hide an object is to set its 
            <see cref= "P:Snap.NX.NXObject.IsHidden">IsHidden</see> property to True.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.Show(Snap.NX.NXObject[])">
            <summary>Shows (Unblanks) an array of NXObject objects</summary>
            <param name="nxObjectArray">The objects to show</param>
            <remarks>
            <para>
            In former times, the "Show" function was known as "Unblank".
            Only the name has changed; the operation is exactly the same as before.
            </para>
            <para>
            Another way to Show an object is to set its 
            <see cref= "P:Snap.NX.NXObject.IsHidden">IsHidden</see> property to False.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.NXObject tag to a Snap.NX.NXObject</summary>
            <param name="nxopenNXObjectTag">The tag of an NXOpen.NXObject object to be converted</param>
            <returns>The Snap.NX.NXObject object formed by wrapping the NXOpen.NXObject having the given tag</returns>
            <remarks>
            <para>
            Returns <c>Nothing</c> if the input tag is NXOpen.Tag.Null, or is not the tag of an NXOpen.NXObject.
            </para>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object. 
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.NXObject object</exception>
        </member>
        <member name="M:Snap.NX.NXObject.GetAttributeInfo">
            <summary>Returns an array of AttributeInformation structures (type + title)</summary>
            <returns>An array of attribute AttributeInformation structures</returns>
            <remarks>
            <para>
            If the object has no attributes, an array of length zero is returned.
            </para>
            </remarks>
            <example>
            The following example illustrates the use of this function:
            <code title="Getting AttributeInformation structures" lang="VB.NET" source="ObjectAttribute_06.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.NXObject.GetAttributeStrings">
            <summary>Get the object's attributes as strings</summary>
            <returns>An array of strings representing the object's attributes</returns>
            <remarks>
            <para>
            This function returns a two-dimensional array of strings.
            If the object has n attributes, this array will have dimensions n &#215; 3.
            </para>
            <para>
            If the returned array is called attribStrings, then the three
            elements in the i-th row are:
            <list type="bullet">
                <item>attribStrings(i,0) -- the type of the attribute, expressed as a string</item>
                <item>attribStrings(i,1) -- the title of the attribute (always a string, anyway)</item>
                <item>attribStrings(i,2) -- the value of the attribute, converted to string form</item>
            </list>
            </para> 
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Getting attributes as strings" lang="VB.NET" source="ObjectAttribute_07.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.HasAttribute(Snap.NX.NXObject.AttributeType,System.String)">
            <summary>
            Checks whether this object has an attribute with a given type and title
            </summary>
            <param name="type">The type of the attribute to be checked</param>
            <param name="title">The title of the attribute to be checked</param>
            <returns>Returns <c>True</c> if this object has an attribute with the given type and title</returns>
            <remarks>
            <para>
            By calling this function first, you can avoid exceptions caused by trying
            to get values for attributes that are not present.
            </para>
            </remarks>
            <example> 
            The following example illustrates how you can use this function to check
            that an attribute is present:
            <code title="Checking that an attribute exists" lang="VB.NET" source="ObjectAttribute_08.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.GetIntegerAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Integer"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (an integer)</returns>
            <remarks>
            <para>
            An exception is raised if the object does not have an attribute of type "Integer"
            with the given title. To avoid this, you can check that the attribute is present
            by calling the <see cref="M:Snap.NX.NXObject.HasAttribute(Snap.NX.NXObject.AttributeType,System.String)">HasAttribute</see>
            function before calling this one.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Getting Integer attributes" lang="VB.NET" source="ObjectAttribute_01.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">
            This object does not have an Integer attribute with the given title.
            </exception>
        </member>
        <member name="M:Snap.NX.NXObject.SetIntegerAttribute(System.String,System.Int32)">
            <summary>Creates and/or sets the value of an attribute of type "Integer"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If an Integer attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Writing Integer attributes" lang="VB.NET" source="ObjectAttribute_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.GetRealAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Real"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a "double" number)</returns>
            <remarks>
            <para>
            An exception is raised if the object does not have an attribute of type "Real"
            with the given title. To avoid this, you can check that the attribute is present
            by calling the <see cref="M:Snap.NX.NXObject.HasAttribute(Snap.NX.NXObject.AttributeType,System.String)">HasAttribute</see>
            function before calling this one.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Real attributes" lang="VB.NET" source="ObjectAttribute_02.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">
            This object does not have a "Real" attribute with the given title.
            </exception>
        </member>
        <member name="M:Snap.NX.NXObject.SetRealAttribute(System.String,System.Double)">
            <summary>Creates and/or sets the value of an attribute of type "Real"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If a Real attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Real attributes" lang="VB.NET" source="ObjectAttribute_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.GetStringAttribute(System.String)">
            <summary>Returns the value of an attribute of type "String"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a string)</returns>
            <remarks>
            <para>
            An exception is raised if the object does not have a String attribute 
            with the given title. To avoid this, you can check that the attribute is present
            by calling the <see cref="M:Snap.NX.NXObject.HasAttribute(Snap.NX.NXObject.AttributeType,System.String)">HasAttribute</see>
            function before calling this one.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with String attributes" lang="VB.NET" source="ObjectAttribute_03.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">
            This object does not have a String attribute with the given title.
            </exception>
        </member>
        <member name="M:Snap.NX.NXObject.SetStringAttribute(System.String,System.String)">
            <summary>Creates and/or sets the value of an attribute of type "String"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If a String attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with String attributes" lang="VB.NET" source="ObjectAttribute_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.GetBooleanAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Boolean"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a Boolean)</returns>     
            <remarks>
            <para>
            An exception is raised if the object does not have a Boolean attribute 
            with the given title. To avoid this, you can check that the attribute is present
            by calling the <see cref="M:Snap.NX.NXObject.HasAttribute(Snap.NX.NXObject.AttributeType,System.String)">HasAttribute</see>
            function before calling this one.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Boolean attributes" lang="VB.NET" source="ObjectAttribute_04.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">
            This object does not have a Boolean attribute with the given title.
            </exception>
        </member>
        <member name="M:Snap.NX.NXObject.SetBooleanAttribute(System.String,System.Boolean)">
            <summary>Creates and/or sets the value of an attribute of type "Boolean"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Reference attributes" lang="VB.NET" source="ObjectAttribute_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.GetDateTimeAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Time"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a System.DateTime object)</returns>
            <remarks>
            <para>
            An exception is raised if the object does not have a Time attribute 
            with the given title. To avoid this, you can check that the attribute is present
            by calling the <see cref="M:Snap.NX.NXObject.HasAttribute(Snap.NX.NXObject.AttributeType,System.String)">HasAttribute</see>
            function before calling this one.
            </para>
            <para>
            You can get more specific information using the functions in 
            the <see cref="T:System.DateTime">System.DateTime</see> class.
            For example, if date is a System.DateTime object, then you can use
            functions like date.Month and date.DayOfWeek and so on
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Date/Time attributes" lang="VB.NET" source="ObjectAttribute_05.vb"> 
            </code> 
            </example>
            <exception cref="T:System.ArgumentException">
            This object does not have a Date/Time attribute with the given title.
            </exception>
        </member>
        <member name="M:Snap.NX.NXObject.SetDateTimeAttribute(System.String,System.DateTime)">
            <summary>Creates and/or sets the value of an attribute of type "Time"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If a Time attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            <para>
            Note that NX can not handle dates before December 29th 1969, so an
            exception is raised if you try to set a "Time" attribute to a value
            prior to this.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input date is before December 29th 1969</exception>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Date/Time attributes" lang="VB.NET" source="ObjectAttribute_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.SetNullAttribute(System.String)">
            <summary>Creates an attribute of type "Null"</summary>
            <param name="title">The title of the attribute</param>
            <remarks>
            <para>
            An attribute of type "Null" has a title, but no value.
            </para>
            <para>
            If a Null attribute with the given title already exists, then calling
            this function does nothing. Otherwise, a new Null attribute is created.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Null attributes" lang="VB.NET" source="ObjectAttribute_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.NXObject.DeleteAttributes(Snap.NX.NXObject.AttributeType)">
            <summary>Deletes all attributes of a given type</summary>
            <param name="type">The attribute type -- see remarks below</param>
            <remarks>
            <para>
            The allowable attribute types are described by the 
            <see cref="T:Snap.NX.NXObject.AttributeType">Snap.NX.NXObject.AttributeType</see> enumeration.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.NXObject.DeleteAttributes(Snap.NX.NXObject.AttributeType,System.String)">
            <summary>Deletes an attribute with a given type and title</summary>
            <param name="type">The type of the attribute that is to be deleted</param>
            <param name="title">The title of the attribute that is to be deleted</param>
            <remarks>
            <para>
            The allowable attribute types are described by the 
            <see cref="T:Snap.NX.NXObject.AttributeType">Snap.NX.NXObject.AttributeType</see> enumeration.
            </para>
            </remarks>      
        </member>
        <member name="T:Snap.NX.NXObject.AttributeInformation">
            <summary>Contains attribute information (title and type)</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeInformation.Title">
            <summary>Attribute title</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeInformation.Type">
            <summary>Attribute type</summary>
        </member>
        <member name="T:Snap.NX.NXObject.AttributeType">
            <summary>Enumeration of different attribute types (Integer, Real, String, etc.)</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Null">
            <summary>Null</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Bool">
            <summary>Bool</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Integer">
            <summary>Integer</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Real">
            <summary>Real</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.String">
            <summary>String</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Time">
            <summary>Time and Date</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Reference">
            <summary>Reference</summary>
        </member>
        <member name="F:Snap.NX.NXObject.AttributeType.Any">
            <summary>All types</summary>
        </member>
        <member name="T:Snap.NX.OffsetCurve">
            <summary>
            Represents a Snap.NX.OffsetCurve feature (interchangeable with <see cref="T:NXOpen.Features.OffsetCurve">NXOpen.Features.OffsetCurve</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.OffsetCurve object, use the <see cref="O:Snap.Create.OffsetCurve">Snap.Create.OffsetCurve</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.OffsetCurve class:
            <code title="Properties of an NX.OffsetCurve object: " lang="VB.NET" source="OffsetCurve_03_01.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.OffsetCurve">Snap.Create.OffsetCurve</seealso>
        </member>
        <member name="P:Snap.NX.OffsetCurve.NXOpenOffsetCurve">
            <summary>The enclosed NXOpen.Features.OffsetCurve object</summary>
        </member>
        <member name="P:Snap.NX.OffsetCurve.Curves">
            <summary>The offset curves</summary>
        </member>
        <member name="P:Snap.NX.OffsetCurve.OffsetCurveBuilder">
            <summary>The NXOpen.Features.OffsetCurveBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.OffsetCurve feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.OffsetCurveBuilder">NXOpen.Features.OffsetCurveBuilder</seealso>
        </member>
        <member name="M:Snap.NX.OffsetCurve.#ctor(NXOpen.Features.OffsetCurve)">
            <summary> Constructor, given an NXOpen.Features.OffsetCurve object.</summary>
            <param name="offsetCurve">An NXOpen.Features.OffsetCurve object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.OffsetCurve.op_Implicit(NXOpen.Features.OffsetCurve)~Snap.NX.OffsetCurve">
            <summary> Implicit conversion of NXOpen.Features.OffsetCurve to NX.OffsetCurve</summary>
            <param name="offsetCurve"> An NXOpen.Features.OffsetCurve object</param>
            <returns>The corresponding NX.OffsetCurve object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.OffsetCurve.op_Implicit(Snap.NX.OffsetCurve)~NXOpen.Features.OffsetCurve">
            <summary> Implicit conversion of NX.OffsetCurve to NXOpen.Features.OffsetCurve</summary>
            <param name="offsetCurve"> AN NX.OffsetCurve object</param>
            <returns>The enclosed NXOpen.Features.OffsetCurve object</returns>
            <exclude/>        
        </member>
        <member name="M:Snap.NX.OffsetCurve.CreateOffsetCurve(Snap.NX.ICurve[],Snap.Number,System.Boolean)">
            <summary>Creates an offset curve feature from given curves, direction, distance</summary>
            <param name="curves">Array of curves to be offset</param>
            <param name="distance">Offset distance</param>
            <param name="reverseDirection">If true, reverse direction of offset. The default direction is the normal of the array of curves.</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            This function doesn't accept a single line as input. Please us the function 
            OffsetLine if you want to offset a single line.
            </para>
            </remarks>
            <example> 
            This example shows how to create an offset curve: 
            <code title="Create an offset curve" lang="VB.NET" source="OffsetCurve_01_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.NX.OffsetCurve.CreateOffsetCurve(Snap.NX.ICurve[],Snap.Number,Snap.Number,System.Boolean)">
            <summary>Creates an offset curve feature from given curves, direction, distance</summary>
            <param name="icurves">Array of curves to be offset</param>
            <param name="height">Draft height</param>
            <param name="angle">Draft angle</param>
            <param name="reverseDirection">If true, reverse direction of offset. The default direction is close to the normal of the array of curves.</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            This function doesn't accept a single line as input. Please us the function 
            OffsetLine if you want to offset a single line.
            </para>
            </remarks>
            <example> 
            This example shows how to create an offset curve: 
            <code title="Create an offset curve" lang="VB.NET" source="OffsetCurve_02.vb_01"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.NX.OffsetCurve.CreateOffsetCurve(Snap.NX.ICurve[],Snap.Number,Snap.Position,Snap.Vector)">
            <summary>Creates an offset curve feature from given curves, direction, distance</summary>
            <param name="curves">Array of base curves to be offset</param>
            <param name="distance">Offset distance</param>
            <param name="helpPoint">A help point on the base curves</param>
            <param name="helpVector">The offset direction (roughly) at the help point</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            Offsets of lines and arcs will again be lines and arcs, respectively. Offsets of splines
            and ellipses will be splines that approximate the exact offsets to with DistanceTolerance.
            </para>
            <para>
            This function doesn't accept an array consisting of a single line as input.
            </para> 
            </remarks>
        </member>
        <member name="M:Snap.NX.OffsetCurve.CreateOffsetCurve(Snap.NX.ICurve[],Snap.Number,Snap.Number,Snap.Position,Snap.Vector)">
            <summary>Creates an offset curve feature from given curves, direction, distance</summary>
            <param name="curves">Array of curves to be offset</param>
            <param name="height">Draft height</param>
            <param name="angle">Draft angle</param>
            <param name="helpPoint">A help point on the base curves</param>
            <param name="helpVector">The offset direction (roughly) at the help point</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            Offsets of lines and arcs will again be lines and arcs, respectively. Offsets of splines
            and ellipses will be splines that approximate the exact offsets to with DistanceTolerance.
            </para>
            <para>
            This function doesn't accept an array consisting of a single line as input.
            </para> 
            </remarks>
            <example> 
            This example shows how to create an offset curve: 
            <code title="Create an offset curve" lang="VB.NET" source="OffsetCurve_02_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.NX.OffsetCurve.CreateOffsetLine(Snap.NX.ICurve,Snap.NX.Point,System.String,System.Boolean)">
            <summary>Creates an offset curve feature from given curve, direction, distance</summary>
            <param name="icurve">Array of curves to be offset</param>
            <param name="point">Point on offset plane</param>
            <param name="distance">Offset Distance</param>
            <param name="reverseDirection">If true, reverse direction of offset. The default direction is the normal of the array of curves.</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            This function only accept a single line as input. Please us the function 
            Offset if you want to offset a non-linear curve.
            </para>
            </remarks>
            <example> 
            This example shows how to create an offset curve: 
            <code title="Create an offset curve" lang="VB.NET" source="OffsetCurve_03_01.vb"> 
            </code> 
            </example>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.NX.OffsetCurve.CreateOffsetLine(Snap.NX.ICurve,Snap.NX.Point,System.String,System.String,System.Boolean)">
            <summary>Creates an offset curve feature from given curve, direction, distance</summary>
            <param name="icurve">Array of curves to be offset</param>
            <param name="point">Point on offset plane</param>
            <param name="height">Draft height</param>
            <param name="angle">Draft angle</param>
            <param name="reverseDirection">If true, reverse direction of offset. The default direction is close to the normal of the array of curves.</param>
            <returns>A <see cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</see> object</returns>
            <remarks>
            <para>
            The resulting NX.OffsetCurve object may consist of many curves. Use the Curves
            property of this object to get the curves themselves.
            </para>
            <para>
            This function only accept a single line as input. Please us the function 
            Offset if you want to offset a non-linear curve.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.OffsetCurve">Snap.NX.OffsetCurve</seealso>
        </member>
        <member name="M:Snap.NX.OffsetCurve.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.OffsetCurve tag to a Snap.NX.OffsetCurve</summary>
            <param name="nxopenOffsetCurveTag">The tag of an NXOpen.Features.OffsetCurve object to be converted</param>
            <returns>The Snap.NX.OffsetCurve object formed by wrapping the NXOpen.Features.OffsetCurve having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.OffsetCurve object</exception>
        </member>
        <member name="T:Snap.NX.OffsetFace">
            <summary>
            Represents a Snap.NX.OffsetFace feature (interchangeable with <see cref="T:NXOpen.Features.OffsetFace">NXOpen.Features.OffsetFace</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.OffsetFace object, use the <see cref="M:Snap.Create.OffsetFace(Snap.Number,System.Boolean,Snap.NX.Face[])">Snap.Create.OffsetFace</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of an NX.OffsetFace object:
            <code title="Properties of an NX.OffsetFace object: " lang="VB.NET" source="OffsetFace_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.OffsetFace(Snap.Number,System.Boolean,Snap.NX.Face[])">Snap.Create.OffsetFace</seealso>
        </member>
        <member name="P:Snap.NX.OffsetFace.NXOpenOffsetFace">
            <summary>The enclosed NXOpen.Features.OffsetFace object</summary>
        </member>
        <member name="P:Snap.NX.OffsetFace.NXOpenDisplayableObjects">
            <summary>The associated NXOpen.DisplayableObjects array of this NX.Feature.OffsetFace</summary>
        </member>
        <member name="P:Snap.NX.OffsetFace.OffsetFaceBuilder">
            <summary>The NXOpen.Features.OffsetFaceBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.OffsetFace feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.OffsetFaceBuilder">NXOpen.Features.OffsetFaceBuilder</seealso>
        </member>
        <member name="P:Snap.NX.OffsetFace.Distance">
            <summary>Offset Distance</summary>
        </member>
        <member name="M:Snap.NX.OffsetFace.#ctor(NXOpen.Features.OffsetFace)">
            <summary> Constructor, given an NXOpen.Features.OffsetFace object</summary>
            <param name="offsetFace">An NXOpen.Features.OffsetFace object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.OffsetFace.op_Implicit(NXOpen.Features.OffsetFace)~Snap.NX.OffsetFace">
            <summary>Implicit conversion of NXOpen.Features.OffsetFace to NX.OffsetFace</summary>
            <param name="offsetFace">The NXOpen.Features.OffsetFace to be converted (enclosed)</param>
            <returns>A new NX.OffsetFace object enclosing the given NXOpen.Features.OffsetFace</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.OffsetFace.op_Implicit(Snap.NX.OffsetFace)~NXOpen.Features.OffsetFace">
            <summary>Implicit conversion of NX.OffsetFace to NXOpen.Features.OffsetFace</summary>
            <param name="offsetFace">The NX.OffsetFace to be converted</param>
            <returns>The NXOpen.Features.OffsetFace object enclosed by the given NX.OffsetFace</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.OffsetFace.CreateOffsetFace(Snap.NX.Face[],Snap.Number,System.Boolean)">
            <summary>Creates an offset face object</summary>
            <param name="faces">Offset faces</param>
            <param name="distance">Offset distance</param>
            <param name="direction">Offset direction</param>
            <returns>An NX.OffsetFace object</returns>
        </member>
        <member name="M:Snap.NX.OffsetFace.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.OffsetFace tag to a Snap.NX.OffsetFace</summary>
            <param name="nxopenOffsetFaceTag">The tag of an NXOpen.Features.OffsetFace object to be converted</param>
            <returns>The Snap.NX.OffsetFace object formed by wrapping the NXOpen.Features.OffsetFace having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.OffsetFace object</exception>
        </member>
        <member name="T:Snap.NX.Part">
            <summary>
            Represents an NX.Part object (interchangeable with <see cref="T:NXOpen.Part">NXOpen.Part</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Part object, use the <see cref="M:Snap.Create.Part(System.String,Snap.NX.Part.Templates,Snap.NX.Part.Units)">Snap.Create.Part</see> functions.
            </para>
            <para>
            An NX.Part object provides various arrays that allow you to cycle through
            the objects it contains. For example, 
            the <see cref="P:Snap.NX.Part.Bodies">Part.Bodies</see> array contains all the bodies in the part,
            the <see cref="P:Snap.NX.Part.Expressions">Part.Expressions</see> array contains all expressions,
            and so on. 
            The <see cref="P:Snap.NX.Part.Objects">Part.Objects</see> array contains all objects in the
            part, of all types.
            </para>
            </remarks>
            <example>
            This example shows how to use the properties of the NX.Part class:
            <code title="Properties of an NX.Part object: " lang="VB.NET" source="Part_02.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.Part(System.String,Snap.NX.Part.Templates,Snap.NX.Part.Units)">Snap.Create.Part</seealso>
        </member>
        <member name="P:Snap.NX.Part.NXOpenPart">
            <summary>The enclosed NXOpen.Part object</summary>
        </member>
        <member name="P:Snap.NX.Part.NXOpenTag">
            <summary>The NXOpen.Tag of the enclosed NXOpen.Part object</summary>
        </member>
        <member name="P:Snap.NX.Part.Features">
            <summary>An array containing all the <see cref="T:Snap.NX.Feature">NX.Feature</see> objects in this part</summary>
        </member>
        <member name="P:Snap.NX.Part.Objects">
            <summary>An array containing all the <see cref="T:Snap.NX.NXObject">NX.NXObject</see> objects in this part</summary>
            <remarks>
            <para>
            The returned array contains all the objects in the part, including many that
            SNAP knows nothing about (like cameras, light-sources, and skeleton objects).
            </para>
            <para>
            Also, the array contains "occurrences". These are objects that are merely
            links to "real" objects that actually reside in subassemblies, rather than
            in the current part. 
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </para>
            To cycle through objects of a specific type, you should use other properties
            of the Part object. For example, to cycle through all bodies, use the
            <see cref="P:Snap.NX.Part.Bodies">Part.Bodies</see> array, rather than the Part.Objects array.
            </remarks>
            <example>
            This example shows how to use the Part.Objects array:
            <code title="Using the Part.Objects array: " lang="VB.NET" source="Object_03.vb"> 
            </code> 
            </example>
            <seealso cref="P:Snap.NX.Part.Bodies">The Part.Bodies array</seealso>
            <seealso cref="P:Snap.NX.Part.Points">The Part.Points array</seealso>
            <seealso cref="P:Snap.NX.Part.Lines">The Part.Lines array</seealso> 
            <seealso cref="P:Snap.NX.Part.Expressions">The Part.Expressions array</seealso>
        </member>
        <member name="P:Snap.NX.Part.Points">
            <summary>An array containing all the <see cref="T:Snap.NX.Point">NX.Point</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include points that are occurrences. To find all points 
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <example> 
            This example shows how to cycle through the points in a part: 
            <code title="Cycling through points" lang="VB.NET" source="PartPoints_01.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso>
            <seealso cref="P:Snap.NX.Part.Objects">The Part.Objects array</seealso>
        </member>
        <member name="P:Snap.NX.Part.Name">
            <summary>The name of the part</summary>
            <remarks>
            <para>
            The string returned depends on whether you are running in native or
            managed mode. You can determine the current mode by using the
            <see cref="P:Snap.Globals.ManagedMode">Snap.Globals.ManagedMode</see> property.
            <list type = "bullet">
            <item>
            In native mode (ManagedMode = False), the result is the operating system filename, 
            with extension, which is typically something like <c>engine.prt</c>
            </item>
            <item>
            In managed mode (ManagedMode = True), the result is a 
            combination of the Teamcenter part number and revision level, separated
            by a "/" character, so typically something like <c>engine/A</c>.
            </item>
            </list>
            </para>
            </remarks>>
            <seealso cref= "P:Snap.NX.Part.FullPath">Snap.NX.Part.FullPath</seealso>
        </member>
        <member name="P:Snap.NX.Part.FullPath">
            <summary>
            Full pathname of the part, including extension
            </summary>
            <remarks>
            <para>
            The string returned depends on whether you are running in native or
            managed mode. You can determine the current mode by using the
            <see cref="P:Snap.Globals.ManagedMode">Snap.Globals.ManagedMode</see> property.
            <list type = "bullet">
            <item>
            In native mode (ManagedMode = False), the result is the operating system pathname, typically
            something like <c>C:\parts\engine.prt</c>
            </item>
            <item>
            In managed mode (ManagedMode = True), the result is the CLI name of the part, which is a 
            combination of the Teamcenter part number and revision level, with the prefix @DB/.
            So, typically, this looks something like <c>@DB/engine/A</c>.
            </item>
            </list>
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.Part.Name">Snap.NX.Part.Name</seealso>
        </member>
        <member name="M:Snap.NX.Part.FindByName(System.String)">
            <summary>Finds a part (from among those open in the session), given its name</summary>
            <param name="pathName">The name or pathname of the part</param>
            <returns>An NX.Part object, or <c>Nothing</c> if the part was not found in the session</returns>      
            <remarks>
            <para>
            The input string can be either the name of the part, as returned by the
            <see cref="P:Snap.NX.Part.Name">Snap.NX.Part.Name</see> property, 
            or the pathname of the part, as obtained from the
            <see cref="P:Snap.NX.Part.FullPath">Snap.NX.Part.FullPath</see> property
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.Part.Name">Snap.NX.Part.Name</seealso>
            <seealso cref= "P:Snap.NX.Part.FullPath">Snap.NX.Part.FullPath</seealso>
        </member>
        <member name="P:Snap.NX.Part.IsFullyLoaded">
            <summary>If true, indicates that the part is fully loaded</summary>
        </member>
        <member name="P:Snap.NX.Part.Bodies">
            <summary>An array containing all the <see cref="T:Snap.NX.Body">NX.Body</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include bodies that are occurrences. To find all bodies
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <example> 
            This example shows how to cycle through the bodies in a part: 
            <code title="Cycling through bodies" lang="VB.NET" source="PartBodies_01.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso>
            <seealso cref="P:Snap.NX.Part.Objects">Snap.NX.Part.Objects</seealso>
        </member>
        <member name="P:Snap.NX.Part.Arcs">
            <summary>An array containing all the <see cref="T:Snap.NX.Arc">NX.Arc</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include arcs that are occurrences. To find all arcs
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso> 
            <seealso cref="P:Snap.NX.Part.Objects">The Part.Objects array</seealso>
        </member>
        <member name="P:Snap.NX.Part.CoordinateSystems">
            <summary>An array containing all the <see cref="T:Snap.NX.CoordinateSystem">NX.CoordinateSystem</see> objects in this part</summary>
        </member>
        <member name="P:Snap.NX.Part.Curves">
            <summary>An array containing all the <see cref="T:Snap.NX.Curve">NX.Curve</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include curves that are occurrences. To find all curves
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso>
            <seealso cref="P:Snap.NX.Part.Objects">Snap.NX.Part.Objects</seealso>
        </member>
        <member name="P:Snap.NX.Part.Expressions">
            <summary>An array containing all the <see cref="T:Snap.NX.Expression">NX.Expression</see> objects in this part</summary>
            <example> 
            This example shows how to cycle through the expressions in a part: 
            <code title="Cycling through expressions" lang="VB.NET" source="PartExpressions_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Part.Lines">
            <summary>An array containing all the <see cref="T:Snap.NX.Line">NX.Line</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include lines that are occurrences. To find all lines
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso>
            <seealso cref="P:Snap.NX.Part.Objects">The Part.Objects array</seealso>
        </member>
        <member name="P:Snap.NX.Part.Splines">
            <summary>An array containing all the <see cref="T:Snap.NX.Spline">NX.Spline</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include splines that are occurrences. To find all splines
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso>
        </member>
        <member name="P:Snap.NX.Part.Ellipses">
            <summary>An array containing all the <see cref="T:Snap.NX.Ellipse">NX.Ellipse</see> objects in this part</summary>
            <remarks>
            <para>
            Note that this array does not include ellipses that are occurrences. To find all ellipses
            in a part, including occurrences, please use its
            <see cref= "P:Snap.NX.Part.Objects">Objects</see> collection. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">Snap.NX.NXObject.IsOccurrence</seealso>
        </member>
        <member name="P:Snap.NX.Part.Notes">
            <summary>An array containing all the <see cref="T:Snap.NX.Note">NX.Note</see> objects in this part</summary>
            <remarks>
            <para>
            In a sense, there are two types of NX.Note objects -- those that enclose an
            NXOpen.Annotations.Note object and those that enclose an NXOpen.Annotations.PmiNote object.
            This array contains both types.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Part.Categories">
            <summary>An array containing all the <see cref="T:Snap.NX.Category">NX.Category</see> objects in this part</summary>
            <example> 
            This example shows how to cycle through the categories in a part: 
            <code title="Cycling through categories" lang="VB.NET" source="PartCategories_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Part.RootComponent">
            <summary>
            The root component, or <c>Nothing</c> if this part is not an assembly
            </summary>
        </member>
        <member name="M:Snap.NX.Part.op_Implicit(NXOpen.Part)~Snap.NX.Part">
            <summary>Implicit conversion of NXOpen.Part to NX.Part</summary>
            <param name="part"> An NXOpen.Part object</param>
            <returns>The corresponding NX.Part object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Part.op_Implicit(Snap.NX.Part)~NXOpen.Part">
            <summary> Implicit conversion of NX.Part to NXOpen.Part</summary>
            <param name="part"> An NX.Part object</param>
            <returns>The corresponding NXOpen.Part object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Part.#ctor(NXOpen.Part)">
            <summary> Constructor, given an NXOpen.Part object.</summary>
            <param name="part">An NXOpen.Part object</param>
        </member>
        <member name="M:Snap.NX.Part.CreatePart(System.String,Snap.NX.Part.Templates,Snap.NX.Part.Units)">
            <summary>Creates a new part</summary>
            <param name="pathName">The full pathname of the part</param>
            <param name="templateType">The type of the template to be used to create the part</param>
            <param name="unitType">The type of the unit to be used</param>
            <returns>An NX.Part object</returns>
        </member>
        <member name="M:Snap.NX.Part.OpenPart(System.String)">
            <summary>Opens an existing .prt part, but does not set it to be the displayed part</summary>
            <param name="pathName">The full pathname of the part</param>
            <returns>An NX.Part object</returns>      
        </member>
        <member name="M:Snap.NX.Part.Save">
            <summary>Save the part</summary>
            <returns>An NXOpen.PartSaveStatus object</returns>      
        </member>
        <member name="M:Snap.NX.Part.SaveAs(System.String)">
            <summary>Save the part to a given location</summary>
            <param name="pathName">The full pathname of the location where the part is to be saved</param>
            <returns>An NXOpen.PartSaveStatus object</returns>      
        </member>
        <member name="M:Snap.NX.Part.Close(System.Boolean,System.Boolean)">
            <summary>Close the part</summary>
            <param name="CloseWholeTree">Indicates which parts in subassemblies should be closed</param>
            <param name="CloseModified">Indicates whether modified parts should be closed</param>  
            <remarks>
            <para>
            The meaning of the "CloseWholeTree" argument is as follows:
            <list type="bullet">
            <item>If true, all parts in the assembly tree are closed, including this part and all subassembly parts</item>
            <item>If false, only this part is closed</item>
            </list>
            </para> 
            <para>
            The meaning of the "CloseModified" argument is as follows:
            <list type="bullet">
            <item>If true, it will close all modified parts</item>
            <item>If false, it does not close any modified parts</item>  
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Part.LoadFully">
            <summary>Load the part fully</summary>
            <remarks>If the part can not be loaded fully, an exception will be raised</remarks>      
        </member>
        <member name="M:Snap.NX.Part.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Part tag to a Snap.NX.Part</summary>
            <param name="nxopenPartTag">The tag of an NXOpen.Part object to be converted</param>
            <returns>The Snap.NX.Part object formed by wrapping the NXOpen.Part having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Part object</exception>
        </member>
        <member name="M:Snap.NX.Part.ToString">
            <summary>
            Returns a string representation of the part
            </summary>
            <returns>A string containing the object type (Part) and its NXOpen tag</returns>
        </member>
        <member name="T:Snap.NX.Part.Templates">
            <summary>Template types that can be used when creating a new part</summary>
            
        </member>
        <member name="F:Snap.NX.Part.Templates.Modeling">
            <summary>A Part Modeling template, with a datum CSYS</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.Assembly">
            <summary>An Assembly Modeling template</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.ShapeStudio">
            <summary>A Shape Studio template, with perspective and grid</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.NXSheetMetal">
            <summary>A sheet metal template</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.AeroSheetMetal">
            <summary>An aerospace sheet metal template</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.RoutingLogical">
            <summary>A Logical Routing template</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.RoutingMechanical">
            <summary>A Mechanical Routing template</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.RoutingElectrical">
            <summary>An Electrical Routing template</summary>
        </member>
        <member name="F:Snap.NX.Part.Templates.Blank">
            <summary>A template that creates a blank part file</summary>
        </member>
        <member name="T:Snap.NX.Part.Units">
            <summary>Part units</summary>
        </member>
        <member name="F:Snap.NX.Part.Units.MilliMeters">
            <summary>Abbreviation : mm</summary>
        </member>
        <member name="F:Snap.NX.Part.Units.Inches">
            <summary>Abbreviation : in</summary>
        </member>
        <member name="M:Snap.NX.Part.GetAppName(NXOpen.FileNew,Snap.NX.Part.Templates)">
            <summary>Get the application name now required by NXOpen (since NX9) from the Snap enum value</summary>
            <param name="fileNew">An NXOpen fileNew object</param>
            <param name="templateType">Template type</param>
            <returns>Application name (template type name, really)</returns>
        </member>
        <member name="M:Snap.NX.Part.GetTemplateFileName(NXOpen.FileNew,Snap.NX.Part.Templates,Snap.NX.Part.Units)">
            <summary>Get the names of the available template files</summary>
            <param name="fileNew">An NXOpen fileNew object</param>
            <param name="templateType">Template type</param>
            <param name="unit">Part units</param>
            <returns>The appropriate template file</returns>
        </member>
        <member name="M:Snap.NX.Part.SafeAppName(NXOpen.FileNew,System.String)">
            <summary>Check that an application name is OK</summary>
            <param name="fileNew">A fileNew object</param>
            <param name="testName">The name to be validated</param>
            <returns>The input name, if it's OK, otherwise "GatewayTemplate"</returns>
        </member>
        <member name="M:Snap.NX.Part.SafeTemplateName(NXOpen.FileNew,System.String)">
            <summary>Check that a template file name is OK</summary>
            <param name="fileNew">A fileNew object</param>
            <param name="testName">The name to be validated</param>
            <returns>The input name, if it's OK, otherwise "Blank"</returns>
        </member>
        <member name="M:Snap.NX.Part.GetAttributeInfo">
            <summary>Returns an array of AttributeInformation structures (type + title)</summary>
            <returns>An array of attribute AttributeInformation structures</returns>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with AttributeInformation structures" lang="VB.NET" source="PartAttribute_06.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.Part.GetAttributeStrings">
            <summary>Get the object's attributes as strings</summary>
            <returns>An array of strings representing the object's attributes</returns>
            <remarks>
            <para>
            This function returns a two-dimensional array of strings.
            If the object has n attributes, this array will have dimensions n &#215; 3.
            </para>
            <para>
            If the returned array is called attribStrings, then the three
            elements in the i-th row are:
            <list type="bullet">
                <item>attribStrings(i,0) -- the type of the attribute, expressed as a string</item>
                <item>attribStrings(i,1) -- the title of the attribute (always a string, anyway)</item>
                <item>attribStrings(i,2) -- the value of the attribute, converted to string form</item>
            </list>
            </para> 
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Getting attributes as strings" lang="VB.NET" source="PartAttribute_07.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.Part.GetIntegerAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Integer"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (an integer)</returns>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Integer attributes" lang="VB.NET" source="PartAttribute_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.Part.SetIntegerAttribute(System.String,System.Int32)">
            <summary>Creates and/or sets the value of an attribute of type "Integer"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If an Integer attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Integer attributes" lang="VB.NET" source="PartAttribute_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.Part.GetRealAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Real"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a "double" number)</returns>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Real attributes" lang="VB.NET" source="PartAttribute_02.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.NX.Part.SetRealAttribute(System.String,System.Double)">
            <summary>Creates and/or sets the value of an attribute of type "Real"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If a Real attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Real attributes" lang="VB.NET" source="PartAttribute_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.GetStringAttribute(System.String)">
            <summary>Returns the value of an attribute of type "String"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a string)</returns>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with String attributes" lang="VB.NET" source="PartAttribute_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.SetStringAttribute(System.String,System.String)">
            <summary>Creates and/or sets the value of an attribute of type "String"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If a String attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with String attributes" lang="VB.NET" source="PartAttribute_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.GetBooleanAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Boolean"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a bool)</returns>     
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Boolean attributes" lang="VB.NET" source="PartAttribute_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.SetBooleanAttribute(System.String,System.Boolean)">
            <summary>Creates and/or sets the value of an attribute of type "Boolean"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Boolean attributes" lang="VB.NET" source="PartAttribute_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.GetDateTimeAttribute(System.String)">
            <summary>Returns the value of an attribute of type "Time"</summary>
            <param name="title">The title of the attribute</param>
            <returns>The value of the attribute (a System.DateTime object)</returns>
            <remarks>
            <para>
            You can get more specified information using the functions in the <see cref="T:System.DateTime">System.DateTime</see> class.
            For example, if date is a System.DateTime object, then you can use
            </para>
            functions like date.Month and date.DayOfWeek and so on.
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Date/Time attributes" lang="VB.NET" source="PartAttribute_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.SetDateTimeAttribute(System.String,System.DateTime)">
            <summary>Creates and/or sets the value of an attribute of type "Time"</summary>
            <param name="title">The title of the attribute</param>
            <param name="value">The value to assign</param>
            <remarks>
            <para>
            If a Time attribute with the given title already exists, then its value
            is simply modified. Otherwise, a new attribute is created
            and its value is set equal to the input value.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Date/Time attributes" lang="VB.NET" source="PartAttribute_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.SetNullAttribute(System.String)">
            <summary>Creates an attribute of type "Null"</summary>
            <param name="title">The title of the attribute</param>
            <remarks>
            <para>
            An attribute of type "Null" has a title, but no value.
            </para>
            <para>
            If a Null attribute with the given title already exists, then calling
            this function does nothing. Otherwise, a new Null attribute is created.
            </para>
            </remarks>
            <example> 
            The following example illustrates the use of this function:
            <code title="Working with Null attributes" lang="VB.NET" source="PartAttribute_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.NX.Part.DeleteAttributes(Snap.NX.Part.AttributeType)">
            <summary>Deletes all attributes of a given type</summary>
            <param name="type">The attribute type -- see remarks below</param>
            <remarks>
            <para>
            This function only deletes attributes attached to the part itself, not
            those attached to objects within the part. To delete attributes attached to
            objects within a part, please use the
            <see cref="O:Snap.NX.NXObject.DeleteAttributes">NXObject.DeleteAttributes</see> functions.
            </para>
            <para>
            The allowable attribute types are described by the 
            <see cref="T:Snap.NX.Part.AttributeType">AttributeType</see> enumeration.
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Part.DeleteAttributes(Snap.NX.Part.AttributeType,System.String)">
            <summary>Deletes an attribute with a given type and title</summary>
            <param name="type">The type of the attribute that is to be deleted -- see remarks below</param>
            <param name="title">The title of the attribute that is to be deleted</param>
            <remarks>
            <para>
            This function only deletes attributes attached to the part itself, not
            those attached to objects within the part. To delete attributes attached to
            objects within a part, please use the
            <see cref="O:Snap.NX.NXObject.DeleteAttributes">NXObject.DeleteAttributes</see> functions.
            </para>
            <para>
            The allowable attribute types are described by the 
            <see cref="T:Snap.NX.Part.AttributeType">AttributeType</see> enumeration.
            </para>
            </remarks>      
        </member>
        <member name="T:Snap.NX.Part.AttributeInformation">
            <summary>Contains attribute information.</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeInformation.Title">
            <summary>Attribute title</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeInformation.Type">
            <summary>Attribute type</summary>
        </member>
        <member name="T:Snap.NX.Part.AttributeType">
            <summary>Specifies attribute type</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Null">
            <summary>Null</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Bool">
            <summary>Bool</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Integer">
            <summary>Integer</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Real">
            <summary>Real</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.String">
            <summary>String</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Time">
            <summary>Time and Date</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Reference">
            <summary>Reference</summary>
        </member>
        <member name="F:Snap.NX.Part.AttributeType.Any">
            <summary>All types</summary>
        </member>
        <member name="T:Snap.NX.Point">
            <summary>
            Represents a Snap.NX.Point object (interchangeable with <see cref="T:NXOpen.Point">NXOpen.Point</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Point object, use the <see cref="O:Snap.Create.Point">Snap.Create.Point</see> functions.
            </para>
            <para>
            To find all the points in a part, use its <see cref="P:Snap.NX.Part.Points">Points</see> collection.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Point class:
            <code title="Properties of an NX.Point object: " lang="VB.NET" source="Point_05.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Point">Snap.Create.Point</seealso>
            <seealso cref="P:Snap.NX.Part.Points">Snap.NX.Part.Points</seealso>
        </member>
        <member name="P:Snap.NX.Point.NXOpenPoint">
            <summary>The enclosed NXOpen.Point object (actually a "Smart Point")</summary>
        </member>
        <member name="P:Snap.NX.Point.X">
            <summary>The x-coordinate of the point</summary>
        </member>
        <member name="P:Snap.NX.Point.Y">
            <summary>The y-coordinate of the point</summary>
        </member>
        <member name="P:Snap.NX.Point.Z">
            <summary>The z-coordinate of the point</summary>
        </member>
        <member name="P:Snap.NX.Point.Position">
            <summary>The position of the point</summary>
        </member>
        <member name="P:Snap.NX.Point.Box">
            <summary>The 3D box that encloses the point</summary>
            <remarks>
            <para>
            The enclosing box has zero size, of course. However, it still makes a contribution
            when used in the       
            <see cref= "M:Snap.Geom.Box3d.Combine(Snap.Geom.Box3d[])">Box3d.Combine</see> function. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Point.Prototype">
            <summary>
            Returns the prototype point of this point (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if the point is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Point.#ctor(NXOpen.Point)">
            <summary> Constructor, given an NXOpen.Point object</summary>
            <param name="pt">An NXOpen.Point object</param>
        </member>
        <member name="M:Snap.NX.Point.op_Implicit(NXOpen.Point)~Snap.NX.Point">
            <summary> Implicit conversion of NXOpen.Point to NX.Point</summary>
            <param name="point"> An NXOpen.Point object</param>
            <returns>The corresponding NX.Point object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Point.op_Implicit(Snap.NX.Point)~NXOpen.Point">
            <summary> Implicit conversion of NX.Point to NXOpen.Point</summary>
            <param name="point"> AN NX.Point object</param>
            <returns>The corresponding NXOpen.Point object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Point.CreatePointInvisible(System.Double,System.Double,System.Double)">
            <summary>Creates an NX.Point object from given coordinates</summary>
            <param name="x">x coordinate</param>
            <param name="y">y coordinate</param>
            <param name="z">z coordinate</param>
            <returns>An invisible NXOpen.Point object (a "smart point")</returns>
        </member>
        <member name="M:Snap.NX.Point.CreatePointInvisible(Snap.Position)">
            <summary>Creates an NX.Point object from given coordinates</summary>
            <param name="p">Position</param>
            <returns>An invisible NXOpen.Point object (a "smart point")</returns>
        </member>
        <member name="M:Snap.NX.Point.CreatePoint(System.Double,System.Double,System.Double)">
            <summary>Creates an NX.Point object</summary>
            <param name="x">x coordinate</param>
            <param name="y">y coordinate</param>
            <param name="z">z coordinate</param>
            <returns>An NX.Point object</returns>
        </member>
        <member name="M:Snap.NX.Point.Copy">
            <summary>Copies an NX.Point (with a null transform)</summary>
            <returns>A copy of the input point</returns>
            <remarks>
            <para>
            The new point will be on the same layer as the original one. 
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.NX.Point.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Point</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Point</returns>
        </member>
        <member name="M:Snap.NX.Point.Copy(Snap.NX.Point[])">
            <summary>Copies an array of NX.Point (with no transform)</summary>
            <param name="original">Original NX.Point array</param>
            <returns>A copy of the input points</returns>
            <remarks>
            <para>
            The new points will be on the same layers as the original ones.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Point.Copy(Snap.Geom.Transform,Snap.NX.Point[])">
            <summary>Transforms/copies an array of NX.Point objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Point array</param>
            <returns>A copy of the input points</returns>    
        </member>
        <member name="M:Snap.NX.Point.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Point tag to a Snap.NX.Point</summary>
            <param name="nxopenPointTag">The tag of an NXOpen.Point object to be converted</param>
            <returns>The Snap.NX.Point object formed by wrapping the NXOpen.Point having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Point object</exception>
            <example> 
            This example shows how to convert an NXOpen.Point tag to a Snap.NX.Point:
            <code title="Convert an NXOpen.Point tag to Snap.NX.Point" lang="VB.NET" source="Point_06.vb"> 
            </code>
            </example>
        </member>
        <member name="T:Snap.NX.ProjectCurve">
            <summary>
            Represents a Snap.NX.ProjectCurve feature (interchangeable with <see cref="T:NXOpen.Features.ProjectCurve">NXOpen.Features.ProjectCurve</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.ProjectCurve object, use the <see cref="O:Snap.Create.ProjectCurve">Snap.Create.ProjectCurve</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.ProjectCurve class:
            <code title="Properties of an NX.ProjectCurve object: " lang="VB.NET" source="ProjectCurve_10.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.ProjectCurve">Snap.Create.ProjectCurve</seealso>
        </member>
        <member name="P:Snap.NX.ProjectCurve.NXOpenProjectCurve">
            <summary>The enclosed <see cref="T:NXOpen.Features.ProjectCurve">NXOpen.Features.ProjectCurve</see> object</summary>
        </member>
        <member name="P:Snap.NX.ProjectCurve.ProjectCurveBuilder">
            <summary>The NXOpen.Features.ProjectCurveBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.ProjectCurve feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ProjectCurveBuilder">NXOpen.Features.ProjectCurveBuilder</seealso>
        </member>
        <member name="P:Snap.NX.ProjectCurve.Curves">
            <summary>The curves generated by projecting curves</summary>
        </member>
        <member name="P:Snap.NX.ProjectCurve.Points">
            <summary>The points generated by projecting points</summary>
        </member>
        <member name="M:Snap.NX.ProjectCurve.#ctor(NXOpen.Features.ProjectCurve)">
            <summary> Constructor, given an NXOpen.Features.ProjectCurve object</summary>
            <param name="projectCurve">An NXOpen.Features.ProjectCurve object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ProjectCurve.op_Implicit(NXOpen.Features.ProjectCurve)~Snap.NX.ProjectCurve">
            <summary>Implicit conversion of NXOpen.Features.ProjectCurve to NX.ProjectCurve</summary>
            <param name="projectCurve">The NXOpen.Features.ProjectCurve to be converted (enclosed)</param>
            <returns>A new NX.ProjectCurve object enclosing the given NXOpen.Features.ProjectCurve</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ProjectCurve.op_Implicit(Snap.NX.ProjectCurve)~NXOpen.Features.ProjectCurve">
            <summary>Implicit conversion of NX.ProjectCurve to NXOpen.Features.ProjectCurve</summary>
            <param name="projectCurve">The NX.ProjectCurve to be converted</param>
            <returns>The NXOpen.Features.ProjectCurve object enclosed by the given NX.ProjectCurve</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ProjectCurve.CreateProjectCurve(Snap.NX.Curve[],Snap.NX.Point[],Snap.Geom.Surface.Plane)">
            <summary>Creates an NX.ProjectCurve object with given curves, points and the plane to project to</summary>
            <param name="curves">Curve array</param>
            <param name="points">Point array</param>
            <param name="geomPlane">The Geom.Plane to project to</param>
            <returns>An NX.ProjectCurve object</returns>
        </member>
        <member name="M:Snap.NX.ProjectCurve.CreateProjectCurve(Snap.NX.Curve[],Snap.NX.Point[],Snap.NX.DatumPlane)">
            <summary>Creates an NX.ProjectCurve object with given curves, points and the datum plane to project to</summary>
            <param name="curves">Curve array</param>
            <param name="points">Point array</param>
            <param name="datumPlane">The datum plane to project to</param>
            <returns>An NX.ProjectCurve object</returns>
        </member>
        <member name="M:Snap.NX.ProjectCurve.CreateProjectCurve(Snap.NX.Curve[],Snap.NX.Point[],Snap.NX.Face)">
            <summary>Creates an NX.ProjectCurve object by projecting along face normals</summary>
            <param name="curves">Array of curves to be projected onto the face</param>
            <param name="points">Array of points to be projected onto the face</param>
            <param name="face">The face to project onto</param>
            <returns>An NX.ProjectCurve object</returns>
        </member>
        <member name="M:Snap.NX.ProjectCurve.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.ProjectCurve tag to a Snap.NX.ProjectCurve</summary>
            <param name="nxopenProjectCurveTag">The tag of an NXOpen.Features.ProjectCurve object to be converted</param>
            <returns>The Snap.NX.ProjectCurve object formed by wrapping the NXOpen.Features.ProjectCurve having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.ProjectCurve object</exception>
        </member>
        <member name="M:Snap.NX.ProjectCurve.CreateProjectCurve2(Snap.NX.Curve[],Snap.NX.Point[],Snap.NX.Face)">
            <summary>Creates an NX.ProjectCurve object with given curves, points and the face to project to</summary>
            <param name="curves">Curve array</param>
            <param name="points">Point array</param>
            <param name="face">The face to project to</param>
            <returns>An NX.ProjectCurve object</returns>
        </member>
        <member name="T:Snap.NX.Revolve">
            <summary>
            Represents a Snap.NX.Revolve feature (interchangeable with <see cref="T:NXOpen.Features.Revolve">NXOpen.Features.Revolve</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Revolve object, use the <see cref="O:Snap.Create.Revolve">Snap.Create.Revolve</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Revolve class:
            <code title="Properties of an NX.Revolve object: " lang="VB.NET" source="Revolve_02.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Revolve">Snap.Create.Revolve</seealso>
            <seealso cref="O:Snap.Create.RevolveSheet">Snap.Create.RevolveSheet</seealso>
            <seealso cref="M:Snap.Create.RevolveShell(Snap.NX.ICurve[],Snap.Position,Snap.Vector,Snap.Number[],Snap.Number[])">Snap.Create.RevolveShell</seealso>
        </member>
        <member name="P:Snap.NX.Revolve.NXOpenRevolve">
            <summary>The enclosed NXOpen.Features.Revolve object</summary>
        </member>
        <member name="P:Snap.NX.Revolve.AxisPoint">
            <summary>The axis point of the revolve</summary>
        </member>
        <member name="P:Snap.NX.Revolve.AxisVector">
            <summary>The axis vector of the revolve</summary>
        </member>
        <member name="P:Snap.NX.Revolve.Extents">
            <summary>The extents of the revolve</summary>
        </member>
        <member name="P:Snap.NX.Revolve.Offsets">
            <summary>The offsets of the revolve</summary>
        </member>
        <member name="P:Snap.NX.Revolve.ICurves">
            <summary>The icurves used to revolve</summary>
        </member>
        <member name="P:Snap.NX.Revolve.RevolveBuilder">
            <summary>The NXOpen.Features.RevolveBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Revolve feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.RevolveBuilder">NXOpen.Features.RevolveBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Revolve.#ctor(NXOpen.Features.Revolve)">
            <summary> Constructor, given an NXOpen.Features.Revolve object</summary>
            <param name="revolve">An NXOpen.Features.Revolve object</param>
        </member>
        <member name="M:Snap.NX.Revolve.op_Implicit(NXOpen.Features.Revolve)~Snap.NX.Revolve">
            <summary> Implicit conversion of NXOpen.Features.Revolve to NX.Revolve</summary>
            <param name="revolve"> An NXOpen.Features.Revolve object</param>
            <returns>The corresponding NX.Revolve object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Revolve.op_Implicit(Snap.NX.Revolve)~NXOpen.Features.Revolve">
            <summary> Implicit conversion of NX.Revolve to NXOpen.Features.Revolve</summary>
            <param name="revolve"> AN NX.Revolve object</param>
            <returns>The enclosed NXOpen.Features.Revolve object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Revolve.CreateRevolve(Snap.NX.ICurve[],Snap.Position,Snap.Vector,Snap.Number[],System.Boolean,Snap.Number[],System.Boolean)">
            <summary>Creates a revolved feature</summary>
            <param name="icurves">The ICurves  to be revolved</param>
            <param name="axisPoint">Point on the axis of revolution</param>
            <param name="axisVector">Vector along the axis of revolution (magnitude doesn't matter)</param>
            <param name="extents">Angular extents of the revolved shape, in degrees, measured from the section</param>
            <param name="offset">If true, indicates that offsets will be applied to the section</param>
            <param name="offsetValues">Offset distances for section curves (ignored if offset == false)</param>
            <param name="createSheet">If true, forces creation of a sheet body</param>
            <returns>The revolved body (an NX.Revolve object)</returns>
        </member>
        <member name="M:Snap.NX.Revolve.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Revolve tag to a Snap.NX.Revolve</summary>
            <param name="nxopenRevolveTag">The tag of an NXOpen.Features.Revolve object to be converted</param>
            <returns>The Snap.NX.Revolve object formed by wrapping the NXOpen.Features.Revolve having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Revolve object</exception>
        </member>
        <member name="T:Snap.NX.Ruled">
            <summary>
            Represents a Snap.NX.Ruled feature (interchangeable with <see cref="T:NXOpen.Features.Ruled">NXOpen.Features.Ruled</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Ruled object, use the <see cref="O:Snap.Create.Ruled">Snap.Create.Ruled</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Ruled class:
            <code title="Properties of an NX.Ruled object: " lang="VB.NET" source="Ruled_02.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Ruled">Snap.Create.Ruled</seealso>
            <seealso cref="O:Snap.Create.ThroughCurves">Snap.Create.ThroughCurves</seealso>
        </member>
        <member name="P:Snap.NX.Ruled.NXOpenRuled">
            <summary>The enclosed NXOpen.Features.Ruled object</summary>
        </member>
        <member name="P:Snap.NX.Ruled.FirstCurve">
            <summary>First curve (along u=0)</summary>
        </member>
        <member name="P:Snap.NX.Ruled.SecondCurve">
            <summary>Second curve (along u=1)</summary>
        </member>
        <member name="P:Snap.NX.Ruled.RuledBuilder">
            <summary>The NXOpen.Features.RuledBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Ruled feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.RuledBuilder">NXOpen.Features.RuledBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Ruled.#ctor(NXOpen.Features.Ruled)">
            <summary> Constructor, given an NXOpen.Features.Ruled object</summary>
            <param name="ruled">An NXOpen.Features.Ruled object</param>
        </member>
        <member name="M:Snap.NX.Ruled.op_Implicit(NXOpen.Features.Ruled)~Snap.NX.Ruled">
            <summary> Implicit conversion of NXOpen.Features.Ruled to NX.Ruled</summary>
            <param name="ruled"> An NXOpen.Features.Ruled object</param>
            <returns>The corresponding NX.Ruled object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Ruled.op_Implicit(Snap.NX.Ruled)~NXOpen.Features.Ruled">
            <summary> Implicit conversion of NX.Ruled to NXOpen.Features.Ruled</summary>
            <param name="ruled"> AN NX.Ruled object</param>
            <returns>The enclosed NXOpen.Features.Ruled object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Ruled.CreateRuled(Snap.NX.Curve,Snap.NX.Curve)">
            <summary>Creates a ruled feature</summary>
            <param name="curve0">First curve (along u=0)</param>
            <param name="curve1">Second curve (along u=1)</param>
            <returns>The ruled feature (an NXOpen.Features.Ruled object)</returns>
        </member>
        <member name="M:Snap.NX.Ruled.CreateRuled(Snap.NX.Curve,Snap.NX.Curve,System.Boolean,System.Boolean)">
            <summary>Creates a ruled feature</summary>
            <param name="curve0">First curve (along u=0)</param>
            <param name="curve1">Second curve (along u=1)</param>
            <param name="reverse0">If true, direction of curve0 is reversed (see remarks below)</param>
            <param name="reverse1">If true, direction of curve1 is reversed</param>
            <returns>The ruled feature (an NXOpen.Features.Ruled object)</returns>
        </member>
        <member name="M:Snap.NX.Ruled.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Ruled tag to a Snap.NX.Ruled</summary>
            <param name="nxopenRuledTag">The tag of an NXOpen.Features.Ruled object to be converted</param>
            <returns>The Snap.NX.Ruled object formed by wrapping the NXOpen.Features.Ruled having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Ruled object</exception>
        </member>
        <member name="T:Snap.NX.Section">
            <summary>
            Represents a "section" object (interchangeable with <see cref="T:NXOpen.Section">NXOpen.Section</see>)
            </summary>
        </member>
        <member name="P:Snap.NX.Section.NXOpenSection">
            <summary>The enclosed NXOpen.Section object</summary>
        </member>
        <member name="M:Snap.NX.Section.#ctor(NXOpen.Section)">
            <summary> Constructor, given an NXOpen.Section object</summary>
            <param name="section">An NXOpen.Section object</param>
        </member>
        <member name="M:Snap.NX.Section.op_Implicit(NXOpen.Section)~Snap.NX.Section">
            <summary> Implicit conversion of NXOpen.Section to NX.Section</summary>
            <param name="section"> An NXOpen.Section object</param>
            <returns>The corresponding NX.Section object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Section.op_Implicit(Snap.NX.Section)~NXOpen.Section">
            <summary> Implicit conversion of NX.Section to NXOpen.Section</summary>
            <param name="section"> AN NX.Section object</param>
            <returns>The enclosed NXOpen.Section object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Section.op_Implicit(Snap.NX.Curve)~Snap.NX.Section">
            <summary> Implicit conversion of NX.Curve to NX.Section</summary>
            <param name="curve"> An NX.Curve object</param>
            <returns>The corresponding NX.section object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Section.op_Implicit(Snap.NX.Edge)~Snap.NX.Section">
            <summary> Implicit conversion of NX.Edge to NX.Section</summary>
            <param name="edge"> An NX.Edge object</param>
            <returns>The corresponding NX.section object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Section.op_Implicit(Snap.NX.Curve[])~Snap.NX.Section">
            <summary> Implicit conversion of NX.Curve array to NX.Section</summary>
            <param name="curves"> An NX.Curve array</param>
            <returns>The corresponding NX.section object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Section.op_Implicit(Snap.NX.Edge[])~Snap.NX.Section">
            <summary> Implicit conversion of NX.Edge array to NX.Section</summary>
            <param name="edges"> An NX.Curve array</param>
            <returns>The corresponding NX.section object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Section.CreateSection(Snap.NX.ICurve,System.Boolean)">
            <summary>Sets the help point and calls AddToSection function </summary>
            <param name="icurve">Input curve</param>
            <param name="reverse">If true, help point is set to the curve's end point. Otherwise, it is set to the start point.</param>
            <returns>The section (an NX.Section object)</returns>
            <returns>A <see cref="T:Snap.NX.Section">NX.Section</see> object</returns>
        </member>
        <member name="M:Snap.NX.Section.AddICurve(System.Boolean,Snap.NX.ICurve)">
            <summary>Sets the help point and calls AddToSection function</summary>
            <param name="reverse">If true, help point is set to the curve's end point. Otherwise, it is set to the start point.</param>
            <param name="icurve">Input curve</param>
            <returns>The section (an NX.Section object)</returns>
            <returns>A <see cref="T:Snap.NX.Section">NX.Section</see> object</returns>
        </member>
        <member name="T:Snap.NX.Sew">
            <summary>
            Represents a Snap.NX.Sew feature (interchangeable with <see cref="T:NXOpen.Features.Sew">NXOpen.Features.Sew</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Sew object, use the <see cref="M:Snap.Create.Sew(Snap.NX.Body,Snap.NX.Body[])">Snap.Create.Sew</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Sew class:
            <code title="Properties of an NX.Sew object: " lang="VB.NET" source="Sew_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.Sew(Snap.NX.Body,Snap.NX.Body[])">Snap.Create.Sew</seealso>
        </member>
        <member name="P:Snap.NX.Sew.NXOpenSew">
            <summary>The enclosed NXOpen.Features.Sew object</summary>
        </member>
        <member name="P:Snap.NX.Sew.SewBuilder">
            <summary>The enclosed NXOpen.Features.SewBuilder object</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Sew feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.SewBuilder">NXOpen.Features.SewBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Sew.#ctor(NXOpen.Features.Sew)">
            <summary> Constructor, given an NXOpen.Features.Sew object</summary>
            <param name="sew">An NXOpen.Features.Sew object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Sew.op_Implicit(NXOpen.Features.Sew)~Snap.NX.Sew">
            <summary>Implicit conversion of NXOpen.Features.Sew to NX.Sew</summary>
            <param name="sew">The NXOpen.Features.Sew to be converted (enclosed)</param>
            <returns>A new NX.Sew object enclosing the given NXOpen.Features.Sew</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Sew.op_Implicit(Snap.NX.Sew)~NXOpen.Features.Sew">
            <summary>Implicit conversion of NX.Sew to NXOpen.Features.Sew</summary>
            <param name="datumAxis">The NX.Sew to be converted</param>
            <returns>The NXOpen.Features.Sew object enclosed by the given NX.Sew</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Sew.CreateSew(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Creates a sew object</summary>
            <param name="targetBody">The target sheet body</param>
            <param name="toolBodies">The array of tool sheet bodies</param>
            <returns>An NX.Sew object</returns>
        </member>
        <member name="M:Snap.NX.Sew.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Sew tag to a Snap.NX.Sew</summary>
            <param name="nxopenSewTag">The tag of an NXOpen.Features.Sew object to be converted</param>
            <returns>The Snap.NX.Sew object formed by wrapping the NXOpen.Features.Sew having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Sew object</exception>
        </member>
        <member name="T:Snap.NX.Sphere">
            <summary>
            Represents a Snap.NX.Sphere feature (interchangeable with <see cref="T:NXOpen.Features.Sphere">NXOpen.Features.Sphere</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Sphere object, use the <see cref="O:Snap.Create.Sphere">Snap.Create.Sphere</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Sphere class:
            <code title="Properties of an NX.Sphere object: " lang="VB.NET" source="Sphere_04.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Sphere">Snap.Create.Sphere</seealso>
        </member>
        <member name="P:Snap.NX.Sphere.NXOpenSphere">
            <summary>The enclosed NXOpen.Features.Sphere object</summary>
        </member>
        <member name="P:Snap.NX.Sphere.Center">
            <summary>The position of the center of the sphere</summary>
        </member>
        <member name="P:Snap.NX.Sphere.Diameter">
            <summary>The diameter of sphere</summary>
        </member>
        <member name="P:Snap.NX.Sphere.SphereBuilder">
            <summary>The NXOpen.Features.SphereBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Sphere feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.SphereBuilder">NXOpen.Features.SphereBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Sphere.#ctor(NXOpen.Features.Sphere)">
            <summary> Constructor, given an NXOpen.Features.Sphere object</summary>
            <param name="sphere">An NXOpen.Features.Sphere object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Sphere.op_Implicit(NXOpen.Features.Sphere)~Snap.NX.Sphere">
            <summary> Implicit conversion of NXOpen.Features.Sphere to NX.Sphere</summary>
            <param name="sphere"> An NXOpen.Features.Sphere object</param>
            <returns>The corresponding NX.Sphere object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Sphere.op_Implicit(Snap.NX.Sphere)~NXOpen.Features.Sphere">
            <summary> Implicit conversion of NX.Sphere to NXOpen.Features.Sphere</summary>
            <param name="sphere"> AN NX.Sphere object</param>
            <returns>The enclosed NXOpen.Features.Sphere object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Sphere.CreateSphere(Snap.NX.Point,Snap.Number)">
            <summary>Creates a sphere feature, given a center point and diameter expression</summary>
            <param name="center">Center point</param>
            <param name="diameter">Diameter</param>
            <returns>An NX.Sphere object</returns>
        </member>
        <member name="M:Snap.NX.Sphere.CreateSphere(Snap.Position,Snap.Number)">
            <summary>Creates a sphere feature, given a center position and diameter</summary>
            <param name="center">Center point</param>
            <param name="diameter">String representing diameter</param>
            <returns>An NX.Sphere object</returns>
        </member>
        <member name="M:Snap.NX.Sphere.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Sphere tag to a Snap.NX.Sphere</summary>
            <param name="nxopenSphereTag">The tag of an NXOpen.Features.Sphere object to be converted</param>
            <returns>The Snap.NX.Sphere object formed by wrapping the NXOpen.Features.Sphere having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Sphere object</exception>
            <example> 
            This example shows how to convert an NXOpen.Features.Sphere tag to a Snap.NX.Sphere:
            <code title="Convert an NXOpen.Features.Sphere tag to a Snap.NX.Sphere" lang="VB.NET" source="Sphere_05.vb"> 
            </code>
            </example>
        </member>
        <member name="T:Snap.NX.Spline">
            <summary>
            Represents a Snap.NX.Spline object (interchangeable with <see cref="T:NXOpen.Spline">NXOpen.Spline</see>)
            </summary>
            <remarks>
            <para>
            The representation used here consists of
            <list type = "bullet">
            <item>Knots -- An array of n+k knot values : t[0], ... , t[n+k-1]</item>
            <item>Poles -- An array of n 3D positions representing poles (control vertices)</item>
            <item>Weights -- An array of n weight values</item>
            </list>
            The order and degree of the curve can be inferred from the sizes of these arrays. If we let
            <list type = "bullet">
            <item>n = number of poles = Poles.Length (or Weights.Length)</item>
            <item>npk = n+k = number of knots = Knots.Length</item>
            </list>    
            Then Order = k = npk - n, and as usual, Degree = Order - 1
            </para>
            <para>To create an NX.Spline object, use the <see cref="O:Snap.Create.Spline">Snap.Create.Spline</see> functions.</para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Spline class:
            <code title="Properties of an NX.Spline object: " lang="VB.NET" source="Spline_06.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.BezierCurve">Snap.Create.BezierCurve</seealso>      
            <seealso cref="M:Snap.Create.BezierCurveFit(Snap.Create.CurvePositionFunction,System.Object,System.Int32)">Snap.Create.BezierCurveFit</seealso>   
            <seealso cref="O:Snap.Create.BezierCurveThroughPoints">Snap.Create.BezierCurveThroughPoints</seealso>   
            <seealso cref="M:Snap.Create.JoinCurves(Snap.NX.ICurve[])">Snap.Create.JoinCurves</seealso>   
            <seealso cref="O:Snap.Create.Spline">Snap.Create.Spline</seealso>   
            <seealso cref="O:Snap.Create.SplineThroughPoints">Snap.Create.SplineThroughPoints</seealso>
            <seealso cref="T:Snap.Math.SplineMath">Snap.Math.SplineMath</seealso>
            <seealso cref="M:Snap.NX.Edge.ToSpline">Snap.NX.Edge.ToSpline</seealso>
            <seealso cref="M:Snap.NX.Curve.ToSpline">Snap.NX.Curve.ToSpline</seealso>      
        </member>
        <member name="P:Snap.NX.Spline.NXOpenSpline">
            <summary>The enclosed NXOpen.Spline object</summary>
        </member>
        <member name="P:Snap.NX.Spline.Geometry">
            <summary>The geometric data of the spline curve</summary>
            <example> 
            The following example shows how to use this property: 
            <code title="Geometry of a spline" lang="VB.NET" source="GeomSpline_02a.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.NX.Spline.Poles">
            <summary> Array of 3D positions representing poles (control points)</summary>
            <remarks> There will be n poles, with indices 0,1,2,...,n-1 </remarks>
        </member>
        <member name="P:Snap.NX.Spline.Weights">
            <summary> Array of values representing weights</summary>
            <remarks> 
            <para>
            There will be n weights, with indices 0,1,2,...,n-1.
            The weights must be strictly positive. This is not checked.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Spline.Degree">
            <summary>The degree of the spline, m (equal to order - 1)</summary>
        </member>
        <member name="P:Snap.NX.Spline.Order">
            <summary>The order of the spline, k (equal to degree + 1)</summary>
        </member>
        <member name="P:Snap.NX.Spline.Knots">
            <summary>Array of knot values </summary>
            <remarks> There will be n+k knots, with indices 0,1,2,...,n+k-1, where k = Order </remarks>
        </member>
        <member name="P:Snap.NX.Spline.Prototype">
            <summary>
            Returns the prototype spline of this one (if it has one)
            </summary>
            <remarks>
            <para>
            The prototype of an occurrence object is the source object that supplies
            the data of the occurrence. See chapter&#160;11 of the SNAP Getting
            Started Guide for an introduction to assembly modeling,
            including the concepts of prototypes and occurrences.
            </para>
            <para>
            Only occurrence objects have prototypes, so this property
            returns <c>Nothing</c> if this spline is not an occurrence.
            </para>
            <para>
            You can determine whether an object is an occurrence by using its
            <see cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence</see> property. 
            </para>
            </remarks>
            <seealso cref= "P:Snap.NX.NXObject.Prototype">NXObject Prototype property</seealso> 
            <seealso cref= "P:Snap.NX.NXObject.IsOccurrence">IsOccurrence property</seealso>
        </member>
        <member name="M:Snap.NX.Spline.#ctor(NXOpen.Spline)">
            <summary> Constructor, given an NXOpen.Spline object</summary>
            <param name="spline">An NXOpen.Spline object</param>
        </member>
        <member name="M:Snap.NX.Spline.#ctor(NXOpen.Tag)">
            <summary>Constructor, given the NXOpen.Tag of a spline</summary>
            <param name="splineTag">The NXOpen.Tag of a spline</param>
        </member>
        <member name="M:Snap.NX.Spline.op_Implicit(NXOpen.Spline)~Snap.NX.Spline">
            <summary>Implicit conversion of NXOpen.Spline to NX.Spline</summary>
            <param name="spline">The NXOpen.Spline to be converted (enclosed)</param>
            <returns>A new NX.Spline object enclosing the given NXOpen.Spline</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Spline.op_Implicit(Snap.NX.Spline)~NXOpen.Spline">
            <summary>Implicit conversion of NX.Spline to NXOpen.Spline</summary>
            <param name="spline">The NX.Spline to be converted</param>
            <returns>The NXOpen.Spline object enclosed by the given NX.Spline</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Spline.CreateSpline(System.Double[],Snap.Position[],System.Double[])">
            <summary>Creates a spline curve from knots and poles</summary>
            <param name="knots">Knots -- an array of n+k knot values</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <param name="weights">An array of n weight values</param>
            <returns>An NX.Spline object</returns>     
        </member>
        <member name="M:Snap.NX.Spline.CreateSpline(System.Double[],Snap.Position[])">
            <summary>Creates a polynomial spline curve from knots and poles</summary>
            <param name="knots">Knots -- an array of n+k knot values : t[0], ... , t[n+k-1]</param>
            <param name="poles">An array of n 3D positions representing poles</param>
            <returns>A <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> object</returns>
        </member>
        <member name="M:Snap.NX.Spline.CreateSplineThroughPoints(Snap.Position[],System.Double[],System.Double[])">
            <summary>Creates a spline curve interpolating given points at given parameter values</summary>
            <param name="qpts">The n points to be interpolated</param>
            <param name="tau">The n parameter values (nodes) at which to interpolate</param>
            <param name="t">Knot sequence : n+k values t[0], ... , t[n+k-1]</param>
            <returns>An NXOpen.Spline object</returns>
        </member>
        <member name="M:Snap.NX.Spline.CreateSplineThroughPoints(Snap.Position[],Snap.Vector,Snap.Vector)">
            <summary>Creates a cubic spline curve interpolating given points and end tangents</summary>
            <param name="qpts">The n points to be interpolated</param>
            <param name="startTangent">The desired tangent vector at the start of the curve (magnitude doesn't matter)</param>
            <param name="endTangent">The desired tangent vector at the end of the curve (magnitude doesn't matter)</param>
            <returns>An NXOpen.Spline object</returns>
            <remarks>
            <para>
            Only the directions of the input start and end tangents are used by this function, so the magnitudes
            of these vectors have no effect on the shape of the resulting curve.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Spline.Copy">
            <summary>Copies an NX.Spline (with a null transform)</summary>
            <returns>A copy of the input point</returns>
            <remarks>
            <para>
            The new spline will be on the same layer as the original one. 
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Spline.Copy(Snap.Geom.Transform)">
            <summary>Transforms/copies an NX.Spline</summary>
            <param name="xform">Transform to be applied</param>
            <returns>A transformed copy of NX.Spline</returns>      
        </member>
        <member name="M:Snap.NX.Spline.Copy(Snap.NX.Spline[])">
            <summary>Copies an array of NX.Spline (with no transform)</summary>
            <param name="original">Original NX.Spline array</param>
            <returns>A copy of the input splines</returns>
            <remarks>
            <para>
            The new splines will be on the same layers as the original ones.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Spline.Copy(Snap.Geom.Transform,Snap.NX.Spline[])">
            <summary>Transforms/copies an array of NX.Spline objects</summary>
            <param name="xform">Transform to be applied</param>
            <param name="original">Original NX.Spline array</param>
            <returns>A copy of the input splines</returns>
        </member>
        <member name="M:Snap.NX.Spline.Divide(System.Double[])">
            <summary>Divide a spline at an array of parameter values</summary>
            <param name="parameters">The parameter values at which the spline should be divided</param>
            <returns>An array of <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> objects</returns>
            <remarks>The function will create new splines by dividing the original one.</remarks>
            <example> 
            This example shows how to divide a spline: 
            <code title="Divide a curve" lang="VB.NET" source="DivideCurve_01.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Spline.Divide(Snap.NX.ICurve,Snap.Position)">
            <summary>Divide a spline at an intersection with another curve</summary>
            <param name="boundingCurve">Bounding curve to be used to divide the given spline</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> objects</returns>
            <remarks>The function will create two new splines by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Spline.Divide(Snap.NX.Face,Snap.Position)">
            <summary>Divide a spline at an intersection with a given face</summary>
            <param name="face">A face to be used to divide the given spline</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> objects</returns>
            <remarks>The function will create two new splines by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Spline.Divide(Snap.Geom.Surface.Plane,Snap.Position)">
            <summary>Divide a spline at an intersection with a given plane</summary>
            <param name="geomPlane">A plane to be used to divide the given spline</param>
            <param name="helpPoint">A point near the desired dividing point</param>
            <returns>An array of two <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> objects</returns>
            <remarks>The function will create two new splines by dividing the original one.</remarks>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Spline.SplineArray(Snap.NX.Curve[])">
            To avoid having four identical copies of the same code
        </member>
        <member name="M:Snap.NX.Spline.Divide">
            <summary>Divide a spline into segments at its knots</summary>
            <returns>An array of <see cref="T:Snap.NX.Spline">Snap.NX.Spline</see> objects</returns>
            <remarks>
            <para>
            The function will create new splines by dividing the original one. 
            </para>
            Each of the new splines will be a Bezier curve (a spline with only one segment).
            </remarks>
            <example> 
            This example shows how to divide a spline at its knots: 
            <code title="Divide a spline" lang="VB.NET" source="DivideCurve_02.vb"> 
            </code>
            </example>
            <seealso cref="M:Snap.NX.Curve.Trim(System.Double,System.Double)">Snap.NX.Curve.Trim</seealso>
        </member>
        <member name="M:Snap.NX.Spline.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Spline tag to a Snap.NX.Spline</summary>
            <param name="nxopenSplineTag">The tag of an NXOpen.Spline object to be converted</param>
            <returns>The Snap.NX.Spline object formed by wrapping the NXOpen.Spline having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Spline object</exception>
        </member>
        <member name="T:Snap.NX.SplitBody">
            <summary>
            Represents a Snap.NX.SplitBody feature (interchangeable with <see cref="T:NXOpen.Features.SplitBody">NXOpen.Features.SplitBody</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.SplitBody object, use the <see cref="O:Snap.Create.SplitBody">Snap.Create.SplitBody</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.SplitBody class:
            <code title="Properties of an NX.SplitBody feature: " lang="VB.NET" source="Split_01.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.SplitBody">Snap.Create.SplitBody</seealso>
        </member>
        <member name="P:Snap.NX.SplitBody.NXOpenSplitBody">
            <summary>The enclosed NXOpen.Features.SplitBody object</summary>
        </member>
        <member name="P:Snap.NX.SplitBody.SplitBodyBuilder">
            <summary>The NXOpen.Features.SplitBodyBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.SplitBody feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.SplitBodyBuilder">NXOpen.Features.SplitBodyBuilder</seealso>
        </member>
        <member name="M:Snap.NX.SplitBody.#ctor(NXOpen.Features.SplitBody)">
            <summary> Constructor, given an NXOpen.Features.SplitBody object</summary>
            <param name="split">An NXOpen.Features.SplitBody object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.SplitBody.op_Implicit(NXOpen.Features.SplitBody)~Snap.NX.SplitBody">
            <summary>Implicit conversion of NXOpen.Features.SplitBody to NX.SplitBody</summary>
            <param name="split">The NXOpen.Features.SplitBody to be converted (enclosed)</param>
            <returns>A new NX.SplitBody object enclosing the given NXOpen.Features.SplitBody</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.SplitBody.op_Implicit(Snap.NX.SplitBody)~NXOpen.Features.SplitBody">
            <summary>Implicit conversion of NX.SplitBody to NXOpen.Features.SplitBody</summary>
            <param name="split">The NX.SplitBody to be converted</param>
            <returns>The NXOpen.Features.SplitBody object enclosed by the given NX.SplitBody</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.SplitBody.CreateSplitBody(Snap.NX.Body,Snap.NX.Face[])">
            <summary>Creates a SplitBody feature</summary>
            <param name="targetBody">The target body will be split</param>
            <param name="toolFaces">The array of faces used to split target body</param>
            <returns>An NX.SplitBody feature</returns>
        </member>
        <member name="M:Snap.NX.SplitBody.CreateSplitBody(Snap.NX.Body,Snap.NX.Body[])">
            <summary>Creates a split object</summary>
            <param name="targetBody">The target body will be split</param>
            <param name="toolBodies">The array of sheet bodies used to split target body</param>
            <returns>An NX.SplitBody object</returns>
        </member>
        <member name="M:Snap.NX.SplitBody.CreateSplitBody(Snap.NX.Body,Snap.NX.DatumPlane[])">
            <summary>Creates a split object</summary>
            <param name="targetBody">The target body will be split</param>
            <param name="toolDatumPlanes">The array of datum planes used to split target body</param>
            <returns>An NX.SplitBody object</returns>
        </member>
        <member name="M:Snap.NX.SplitBody.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.SplitBody tag to a Snap.NX.SplitBody</summary>
            <param name="nxopenSplitBodyTag">The tag of an NXOpen.Features.SplitBody object to be converted</param>
            <returns>The Snap.NX.SplitBody object formed by wrapping the NXOpen.Features.SplitBody having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.SplitBody object</exception>
        </member>
        <member name="T:Snap.NX.TextStyle">
            <summary>An object describing the style (font, color, etc.) of text</summary>
            <remarks>
            <para>
            TextStyle objects are used to specify the properties of text used in 
            <seealso cref= "T:Snap.NX.Note">notes</seealso> and in 
            <seealso cref= "M:Snap.Draw.DrawText(Snap.NX.View,System.Drawing.Color,Snap.Position,System.String[])">drawing temporary text</seealso>
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the TextStyle class:
            <code title="Properties of a TextStyle object: " lang="VB.NET" source="TextStyle_01.vb"> 
            </code> 
            </example>
            <seealso cref= "T:Snap.NX.Note">Widget</seealso>
            <seealso cref= "M:Snap.Draw.DrawText(Snap.NX.View,System.Drawing.Color,Snap.Position,System.String[])">Snap.Draw.DrawScreenText</seealso>
        </member>
        <member name="P:Snap.NX.TextStyle.Color">
            <summary>The color of the text</summary>
        </member>
        <member name="P:Snap.NX.TextStyle.FontIndex">
            <summary>The index of the font within the part file's font table</summary>
            <remarks>
            <para>
            It is this index that actually determines the font used to display the note, not the font name. 
            Therefore, if the entries in the font table are re-organized, a different font may be used,
            so the appearance of the text will change.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.TextStyle.FontName">
            <summary>The name of the primary font</summary>
            <remarks>
            <para>
            When setting this property, we first try to find a system (TrueType) font with the given name.
            If this fails, we look for a traditional NX font, instead. If you want more control over the
            search process, please use the SetFont function, instead.
            </para>
            </remarks>
            <seealso cref="M:Snap.NX.TextStyle.SetFont(System.String,Snap.NX.TextStyle.FontType)">Snap.NX.TextStyle.SetFont</seealso>
        </member>
        <member name="M:Snap.NX.TextStyle.SetFont(System.String,Snap.NX.TextStyle.FontType)">
            <summary>Sets the primary font for text</summary>
            <param name="fontName">The name of the font to be used</param>
            <param name="fontType">The type of font (either a standard system font or an NX font)</param>      
        </member>
        <member name="P:Snap.NX.TextStyle.StrokeWidth">
            <summary>The width (thickness) of the strokes used to draw the font</summary>
            <remarks>This only makes sense for old-style NX fonts, not “system” (Truetype) fonts.</remarks>
        </member>
        <member name="P:Snap.NX.TextStyle.FontSize">
            <summary>The font size (in points)</summary>
        </member>
        <member name="P:Snap.NX.TextStyle.FontStyle">
            <summary>The style of the text (bold, italic, etc.)</summary>
            <remarks>
            <para>
            To find out which styles are supported by a given font, use the Windows
            Font control panel. As you will see, most fonts include the styles
            "Regular", "Bold", Italic", and "Bold Italic". But, with some fonts,
            more exotic style names are used. For example, the Lucida Sans font
            has a style called "Demibold Roman".
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.TextStyle.NxFontSize">
            <summary>The font size, expressed in part units (mm or inches)</summary>
        </member>
        <member name="P:Snap.NX.TextStyle.CharSpaceFactor">
            <summary>A multiplier used to adjust the spacing between characters</summary>
        </member>
        <member name="P:Snap.NX.TextStyle.AspectRatio">
            <summary>A multiplier used to adjust the shapes of characters. Values greater than 1 will make characters wider than normal. </summary>
        </member>
        <member name="P:Snap.NX.TextStyle.LineSpaceFactor">
            <summary>A multiplier used to adjust the spacing between lines of text</summary>
        </member>
        <member name="P:Snap.NX.TextStyle.HorizontalTextJustification">
            <summary>The horizontal  justification of the text (left, center, or right)</summary>
            <remarks>This takes effect only when the text has two or more lines</remarks>
        </member>
        <member name="P:Snap.NX.TextStyle.AlignmentPosition">
            <summary>One of nine "sites" used to locate the text</summary>
            <example> 
            The following example creates notes with different alignment types:
            <code title="Create notes" lang="VB.NET" source="Note_04.vb">
            </code>
            </example>
        </member>
        <member name="P:Snap.NX.TextStyle.LineAngle">
            <summary>The angle between the baseline of the text and the horizontal</summary>
        </member>
        <member name="P:Snap.NX.TextStyle.IsVertical">
            <summary>If true, indicates that the text will be oriented vertically, not horizontally</summary>
            <remarks>
            <para>
            In "vertical" text, the characters are still upright, but are arranged in a vertical column. 
            If you want to take a line of text and simply rotate it into a vertical position, you should
            </para>
            set LineAngle equal to plus or minus 90 degrees.
            </remarks>
        </member>
        <member name="M:Snap.NX.TextStyle.#ctor">
            <summary>Construct a text style</summary>      
            <remarks>The properties of the text are obtained from the settings in Annotation Preferences</remarks>
        </member>
        <member name="T:Snap.NX.TextStyle.TextJustification">
            <summary> Represents the horizontal text justification</summary>
            <remarks>This takes effect only when the text has two or more lines</remarks>
        </member>
        <member name="F:Snap.NX.TextStyle.TextJustification.Center">
            <summary>Center</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.TextJustification.Left">
            <summary>Left</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.TextJustification.Right">
            <summary>Right</summary>
        </member>
        <member name="T:Snap.NX.TextStyle.AlignmentPositions">
            <summary>Specifies the site location in the text box which can be used to locate a drafting object</summary>
            <remarks>
            <para>
            The following diagram explains the different alignment types: 
            </para>
            <para>
            <img src="../Images/TextStyle_01.png"/>
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.TopLeft">
            <summary>Top left of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.TopCenter">
            <summary>Top center of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.TopRight">
            <summary>Top right of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.MidLeft">
            <summary>Mid left of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.MidCenter">
            <summary>Mid center of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.MidRight">
            <summary>Mid right of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.BottomLeft">
            <summary>Bottom left of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.BottomCenter">
            <summary>Bottom center of the bounding rectangle</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.AlignmentPositions.BottomRight">
            <summary>Bottom right of the bounding rectangle</summary>
        </member>
        <member name="T:Snap.NX.TextStyle.FontType">
            <summary>Specifies the type of font</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.FontType.NX">
            <summary>NX font</summary>
        </member>
        <member name="F:Snap.NX.TextStyle.FontType.Standard">
            <summary>Standard system font</summary>
        </member>
        <member name="T:Snap.NX.Thicken">
            <summary>
            Represents a Snap.NX.Thicken feature (interchangeable with <see cref="T:NXOpen.Features.Thicken">NXOpen.Features.Thicken</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Thicken object, use the <see cref="M:Snap.Create.Thicken(Snap.Number,Snap.Number,Snap.NX.Body[])">Snap.Create.Thicken</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Thicken class:
            <code title="Properties of an NX.Thicken object: " lang="VB.NET" source="Thicken_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.Thicken(Snap.Number,Snap.Number,Snap.NX.Body[])">Snap.Create.Thicken</seealso>
        </member>
        <member name="P:Snap.NX.Thicken.NXOpenThicken">
            <summary>The enclosed NXOpen.Features.Thicken object</summary>
        </member>
        <member name="P:Snap.NX.Thicken.ThickenBuilder">
            <summary>The NXOpen.Features.ThickenBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Thicken feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ThickenBuilder">NXOpen.Features.ThickenBuilder</seealso>
        </member>
        <member name="P:Snap.NX.Thicken.Offset1">
            <summary>The first offset distance</summary>
            <remarks>
            <para>
            Thickening is controlled by two offset distances, which can be either positive or negative.
            Positive values indicate an offset to one side of the original sheet body, and negative
            values indicate the other side. The thickened body lies between these two offsets.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.Thicken.Offset2">
            <summary>The second offset distance</summary>
            <remarks>
            <para>
            Thickening is controlled by two offset distances, which can be either positive or negative.
            Positive values indicate an offset to one side of the original sheet body, and negative
            values indicate the other side. The thickened body lies between these two offsets.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.NX.Thicken.#ctor(NXOpen.Features.Thicken)">
            <summary> Constructor, given an NXOpen.Features.Thicken object</summary>
            <param name="thicken">An NXOpen.Features.Thicken object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Thicken.op_Implicit(NXOpen.Features.Thicken)~Snap.NX.Thicken">
            <summary>Implicit conversion of NXOpen.Features.Thicken to NX.Thicken</summary>
            <param name="thicken">The NXOpen.Features.Thicken to be converted (enclosed)</param>
            <returns>A new NX.Thicken object enclosing the given NXOpen.Features.Thicken</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Thicken.op_Implicit(Snap.NX.Thicken)~NXOpen.Features.Thicken">
            <summary>Implicit conversion of NX.Thicken to NXOpen.Features.Thicken</summary>
            <param name="thicken">The NX.Thicken to be converted</param>
            <returns>The NXOpen.Features.Thicken object enclosed by the given NX.Thicken</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Thicken.CreateThicken(Snap.NX.Body[],Snap.Number,Snap.Number)">
            <summary>Creates a thicken object</summary>
            <param name="targetBodies">The array of sheet bodies will be thickened</param>
            <param name="offset1">The thickness of the generated body</param>
            <param name="offset2">The distance from the target body</param>
            <returns>An NX.Thicken object</returns>
        </member>
        <member name="M:Snap.NX.Thicken.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Thicken tag to a Snap.NX.Thicken</summary>
            <param name="nxopenThickenTag">The tag of an NXOpen.Features.Thicken object to be converted</param>
            <returns>The Snap.NX.Thicken object formed by wrapping the NXOpen.Features.Thicken having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Thicken object</exception>
        </member>
        <member name="T:Snap.NX.ThroughCurveMesh">
            <summary>
            Represents a Snap.NX.ThroughCurveMesh feature (interchangeable with <see cref="T:NXOpen.Features.ThroughCurveMesh">NXOpen.Features.ThroughCurveMesh</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.ThroughCurveMesh object, use the <see cref="M:Snap.Create.ThroughCurveMesh(Snap.NX.ICurve[],Snap.NX.ICurve[])">Snap.Create.ThroughCurveMesh</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of an NX.ThroughCurveMesh feature:
            <code title="Properties of an NX.ThroughCurveMesh object: " lang="VB.NET" source="ThroughCurveMesh_01.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.ThroughCurveMesh">Snap.Create.ThroughCurveMesh</seealso>
            <seealso cref="O:Snap.Create.ThroughCurves">Snap.Create.ThroughCurves</seealso>
        </member>
        <member name="P:Snap.NX.ThroughCurveMesh.NXOpenThroughCurveMesh">
            <summary>The enclosed NXOpen.Features.ThroughCurveMesh object</summary>
        </member>
        <member name="P:Snap.NX.ThroughCurveMesh.ThroughCurveMeshBuilder">
            <summary>The NXOpen.Features.ThroughCurveMeshBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.ThroughCurveMesh feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.ThroughCurveMeshBuilder">NXOpen.Features.ThroughCurveMeshBuilder</seealso>
        </member>
        <member name="M:Snap.NX.ThroughCurveMesh.op_Implicit(NXOpen.Features.ThroughCurveMesh)~Snap.NX.ThroughCurveMesh">
            <summary> Implicit conversion of NXOpen.Features.ThroughCurveMesh to NX.ThroughCurveMesh</summary>
            <param name="throughCurveMesh"> An NXOpen.Features.ThroughCurveMesh object</param>
            <returns>The corresponding NX.ThroughCurveMesh object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ThroughCurveMesh.op_Implicit(Snap.NX.ThroughCurveMesh)~NXOpen.Features.ThroughCurveMesh">
            <summary> Implicit conversion of NX.ThroughCurveMesh to NXOpen.Features.ThroughCurveMesh</summary>
            <param name="throughCurveMesh"> AN NX.ThroughCurveMesh object</param>
            <returns>The enclosed NXOpen.Features.ThroughCurveMesh object</returns>
            <exclude/>        
        </member>
        <member name="M:Snap.NX.ThroughCurveMesh.CreateThroughCurveMesh(Snap.NX.ICurve[],Snap.NX.ICurve[])">
            <summary>Creates a ThroughCurveMesh object</summary>
            <param name="primaryCurves">The array of primary curves (curves or edges)</param>
            <param name="crossCurves">The array of primary curves (curves or edges)</param>
            <returns> A <see cref="T:Snap.NX.ThroughCurveMesh">Snap.NX.ThroughCurveMesh</see> object</returns>
        </member>
        <member name="M:Snap.NX.ThroughCurveMesh.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.ThroughCurveMesh tag to a Snap.NX.ThroughCurveMesh</summary>
            <param name="nxopenThroughCurveMeshTag">The tag of an NXOpen.Features.ThroughCurveMesh object to be converted</param>
            <returns>The Snap.NX.ThroughCurveMesh object formed by wrapping the NXOpen.Features.ThroughCurveMesh having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.ThroughCurveMesh object</exception>
        </member>
        <member name="T:Snap.NX.ThroughCurves">
            <summary>
            Represents a Snap.NX.ThroughCurves feature (interchangeable with <see cref="T:NXOpen.Features.ThroughCurves">NXOpen.Features.ThroughCurves</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.ThroughCurves object, use the <see cref="O:Snap.Create.ThroughCurves">Snap.Create.ThroughCurves</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to create a ThroughCurves feature: 
            <code title="Create a through curves feature" lang="VB.NET" source="ThroughCurves_01.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.ThroughCurves">Snap.Create.ThroughCurves</seealso>
            <seealso cref="O:Snap.Create.ThroughCurveMesh">Snap.Create.ThroughCurveMesh</seealso>
            <seealso cref="O:Snap.Create.Ruled">Snap.Create.Ruled</seealso>
        </member>
        <member name="P:Snap.NX.ThroughCurves.NXOpenThroughCurves">
            <summary>The enclosed NXOpen.Features.ThroughCurves object</summary>
        </member>
        <member name="P:Snap.NX.ThroughCurves.ThroughCurvesBuilder">
            <summary>The NXOpen.Features.ThroughCurvesBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.ThroughCurves feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.ThroughCurves.ICurves">
            <summary>The ICurves which are associated with the through curves object</summary>
        </member>
        <member name="M:Snap.NX.ThroughCurves.op_Implicit(NXOpen.Features.ThroughCurves)~Snap.NX.ThroughCurves">
            <summary> Implicit conversion of NXOpen.Features.ThroughCurves to NX.ThroughCurves</summary>
            <param name="throughCurves"> An NXOpen.Features.ThroughCurves object</param>
            <returns>The corresponding NX.ThroughCurves object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.ThroughCurves.op_Implicit(Snap.NX.ThroughCurves)~NXOpen.Features.ThroughCurves">
            <summary> Implicit conversion of NX.ThroughCurves to NXOpen.Features.ThroughCurves</summary>
            <param name="throughCurves"> AN NX.ThroughCurves object</param>
            <returns>The enclosed NXOpen.Features.ThroughCurves object</returns>
            <exclude/>        
        </member>
        <member name="M:Snap.NX.ThroughCurves.CreateThroughCurves(Snap.NX.ICurve[])">
            <param name="icurves">The icurves array</param>
            <returns> A <see cref="T:Snap.NX.ThroughCurves">Snap.NX.ThroughCurves</see> object. </returns>
        </member>
        <member name="M:Snap.NX.ThroughCurves.CreateThroughCurves(Snap.NX.ICurve[],System.Boolean[])">
            <summary>Creates a ThroughCurves object</summary>
            <param name="icurves">The icurves array</param>
            <param name="reverse">The array of booleans which decide whether direction of respective curve in the curves array has to reversed.
            If true, direction of curve is reversed</param>
            <returns> A <see cref="T:Snap.NX.ThroughCurves">Snap.NX.ThroughCurves</see> object. </returns>
        </member>
        <member name="M:Snap.NX.ThroughCurves.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.ThroughCurves tag to a Snap.NX.ThroughCurves</summary>
            <param name="nxopenThroughCurvesTag">The tag of an NXOpen.Features.ThroughCurves object to be converted</param>
            <returns>The Snap.NX.ThroughCurves object formed by wrapping the NXOpen.Features.ThroughCurves having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.ThroughCurves object</exception>
        </member>
        <member name="T:Snap.NX.Torus">
            <summary>
            Represents a Snap.NX.Torus object (a special kind of NX.Revolved object) (interchangeable with <see cref="T:NXOpen.Features.Revolve">NXOpen.Features.Revolve</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Torus object, use the <see cref="O:Snap.Create.Torus">Snap.Create.Torus</see> functions.
            </para>
            <para>
            A torus is formed by rotating a circle around an axis that lies in its plane. 
            Torus shapes can look quite different, depending on the relative values of the MinorRadius
            and MajorRadius properties.
            </para>
            <list type="bullet">
                <item>If MinorRadius &lt; MajorRadius, then a donut shape is produced.</item>
                <item>If MinorRadius &gt; Abs(MajorRadius) and MajorRadius &gt; 0, we get an "apple" shape.</item>
                <item>If MinorRadius &gt; Abs(MajorRadius) and MajorRadius &lt; 0, we get a "lemon" or "barrel" shape.</item>
            </list>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Torus class:
            <code title="Properties of an NX.Torus object: " lang="VB.NET" source="Torus_01.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.Torus">Snap.Create.Torus</seealso>  
        </member>
        <member name="P:Snap.NX.Torus.AxisPoint">
            <summary>Axis point</summary>
        </member>
        <member name="P:Snap.NX.Torus.AxisVector">
            <summary>Axis vector</summary>
        </member>
        <member name="P:Snap.NX.Torus.MajorRadius">
            <summary>Major radius. The radius of the "spine" circle, which can be either positive or negative</summary>
        </member>
        <member name="P:Snap.NX.Torus.MinorRadius">
            <summary>Minor radius. The radius of the "section" circle, which must be positive.</summary>
        </member>
        <member name="M:Snap.NX.Torus.#ctor(NXOpen.Features.Revolve)">
            <summary> Constructor, given an NXOpen.Features.Revolve object</summary>
            <param name="torus">An NXOpen.Features.Revolve object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Torus.CreateTorus(Snap.Position,Snap.Orientation,System.Double,System.Double,Snap.Geom.Box2d)">
            <summary>Creates a toroidal surface, given center, matrix, major radius, minor radius, and  parameter limits</summary>
            <param name="center">Center point</param>
            <param name="matrix">Orientation of the torus. AxisZ is the axis of revolution</param>
            <param name="majorRadius">Major radius (radius of "spine" circle)</param>
            <param name="minorRadius">Minor radius (radius of "section" circle)</param>
            <param name="boxUV">The UV parameter box of the surface (MinU, MinV, MaxU, MaxV)</param>
            <returns>A <see cref="T:Snap.NX.Torus">Snap.NX.Torus</see> NX.Torus object</returns>     
        </member>
        <member name="M:Snap.NX.Torus.CreateTorus(Snap.Position,Snap.Vector,System.Double,System.Double)">
            <summary>Creates an NX.Torus solid body (complete 360 degrees), given center, major radius and minor radius</summary>
            <param name="axisPoint">Center point</param>
            <param name="axisVector">Vector along axis of revolution (length doesn't matter)</param>
            <param name="majorRadius">Major radius (radius of "spine" circle)</param>
            <param name="minorRadius">Minor radius (radius of "section" circle)</param>
            <returns>A <see cref="T:Snap.NX.Torus">Snap.NX.Torus</see> NX.Torus object</returns>
        </member>
        <member name="T:Snap.NX.TrimBody">
            <summary>
            Represents a Snap.NX.TrimBody feature (interchangeable with <see cref="T:NXOpen.Features.TrimBody2">NXOpen.Features.TrimBody2</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.TrimBody object, use the <see cref="O:Snap.Create.TrimBody">Snap.Create.TrimBody</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of an NX.TrimBody feature:
            <code title="Properties of an NX.TrimBody feature: " lang="VB.NET" source="Trim_03.vb"> 
            </code> 
            </example>
            <seealso cref="O:Snap.Create.TrimBody">Snap.Create.TrimBody</seealso>
        </member>
        <member name="P:Snap.NX.TrimBody.NXOpenTrimBody">
            <summary>The enclosed NXOpen.Features.TrimBody2 object</summary>
        </member>
        <member name="P:Snap.NX.TrimBody.TrimBodyBuilder">
            <summary>The NXOpen.Features.TrimBody2Builder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.TrimBody feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.TrimBody2Builder">NXOpen.Features.TrimBody2Builder</seealso>
        </member>
        <member name="M:Snap.NX.TrimBody.#ctor(NXOpen.Features.TrimBody2)">
            <summary> Constructor, given an NXOpen.Features.TrimBody2 object</summary>
            <param name="trim">An NXOpen.Features.TrimBody2 object</param>
            <exclude/>
        </member>
        <member name="M:Snap.NX.TrimBody.op_Implicit(NXOpen.Features.TrimBody2)~Snap.NX.TrimBody">
            <summary>Implicit conversion of NXOpen.Features.TrimBody2 to NX.TrimBody</summary>
            <param name="trim">The NXOpen.Features.TrimBody2 to be converted (enclosed)</param>
            <returns>A new NX.TrimBody object enclosing the given NXOpen.Features.TrimBody2</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.TrimBody.op_Implicit(Snap.NX.TrimBody)~NXOpen.Features.TrimBody2">
            <summary>Implicit conversion of NX.TrimBody to NXOpen.Features.TrimBody2</summary>
            <param name="trim">The NX.TrimBody to be converted</param>
            <returns>The NXOpen.Features.TrimBody2 object enclosed by the given NX.TrimBody</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.TrimBody.CreateTrimBody(Snap.NX.Body,Snap.NX.Face,System.Boolean)">
            <summary>Creates a Snap.NX.TrimBody feature</summary>
            <param name="targetBody">The target body to be trimmed</param>
            <param name="toolFace">The face used to trim target body</param>
            <param name="direction">Trim direction. The default direction is the normal of the face.</param>
            <returns> A <see cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</see> object</returns>
        </member>
        <member name="M:Snap.NX.TrimBody.CreateTrimBody(Snap.NX.Body,Snap.NX.Body,System.Boolean)">
            <summary>Creates a Snap.NX.TrimBody feature</summary>
            <param name="targetBody">The target body will be trimmed</param>
            <param name="toolBody">The sheet body used to trim target body</param>
            <param name="direction">Trim direction. The default direction is the normal of the sheet body.</param>
            <returns> A <see cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</see> feature</returns>
        </member>
        <member name="M:Snap.NX.TrimBody.CreateTrimBody(Snap.NX.Body,Snap.NX.DatumPlane,System.Boolean)">
            <summary>Creates a Snap.NX.TrimBody feature</summary>
            <param name="targetBody">The target body will be trimmed</param>
            <param name="toolDatumPlane">The datum plane used to trim target body</param>
            <param name="direction">Trim direction. The default direction is the normal of the datum plane.</param>
            <returns> A <see cref="T:Snap.NX.TrimBody">Snap.NX.TrimBody</see> feature</returns>
        </member>
        <member name="M:Snap.NX.TrimBody.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.TrimBody2 tag to a Snap.NX.TrimBody</summary>
            <param name="nxopenTrimBodyTag">The tag of an NXOpen.Features.TrimBody2 object to be converted</param>
            <returns>The Snap.NX.TrimBody object formed by wrapping the NXOpen.Features.TrimBody2 having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.TrimBody2 object</exception>
        </member>
        <member name="T:Snap.NX.Tube">
            <summary>
            Represents a Snap.NX.Tube feature (interchangeable with <see cref="T:NXOpen.Features.Tube">NXOpen.Features.Tube</see>)
            </summary>
            <remarks>
            <para>
            To create an NX.Tube object, use the <see cref="M:Snap.Create.Tube(Snap.NX.Curve,System.Boolean,Snap.Number,Snap.Number)">Snap.Create.Tube</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use the properties of the NX.Tube class:
            <code title="Properties of an NX.Tube object: " lang="VB.NET" source="Tube_01.vb"> 
            </code> 
            </example>
            <seealso cref="M:Snap.Create.Tube(Snap.NX.Curve,System.Boolean,Snap.Number,Snap.Number)">Snap.Create.Tube</seealso> 
        </member>
        <member name="P:Snap.NX.Tube.Spine">
            <summary>Curve used in creation -- the centerline of the tube</summary>
        </member>
        <member name="P:Snap.NX.Tube.NXOpenTube">
            <summary>The enclosed NXOpen.Features.Tube object</summary>
        </member>
        <member name="P:Snap.NX.Tube.OuterDiameter">
            <summary>The outer diameter of the tube</summary>
        </member>
        <member name="P:Snap.NX.Tube.InnerDiameter">
            <summary>The inner diameter of the tube</summary>
        </member>
        <member name="P:Snap.NX.Tube.TubeBuilder">
            <summary>The NXOpen.Features.TubeBuilder object.</summary>
            <remarks>
            <para>
            By using this builder, you can set the properties of the Snap.NX.Tube feature.
            After you have finished using the builder, you should call its Destroy() function to free memory.
            </para>
            </remarks>
            <seealso cref="T:NXOpen.Features.TubeBuilder">NXOpen.Features.TubeBuilder</seealso>
        </member>
        <member name="M:Snap.NX.Tube.#ctor(NXOpen.Features.Tube)">
            <summary> Constructor, given an NXOpen.Features.Tube object</summary>
            <param name="tube">An NXOpen.Features.Tube object</param>
        </member>
        <member name="M:Snap.NX.Tube.op_Implicit(NXOpen.Features.Tube)~Snap.NX.Tube">
            <summary> Implicit conversion of NXOpen.Features.Tube to NX.Tube</summary>
            <param name="tube"> An NXOpen.Features.Tube object</param>
            <returns>The corresponding NX.Tube object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Tube.op_Implicit(Snap.NX.Tube)~NXOpen.Features.Tube">
            <summary> Implicit conversion of NX.Tube to NXOpen.Features.Tube</summary>
            <param name="tube"> AN NX.Tube object</param>
            <returns>The enclosed NXOpen.Features.Tube object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Tube.CreateTube(Snap.NX.Curve,Snap.Number,Snap.Number,System.Boolean)">
            <summary>Creates a tube feature, given spine and inner/outer diameters</summary>
            <param name="spine">The centerline (spine) of the tube</param>
            <param name="outerDiameter">Outer diameter</param>        
            <param name="innerDiameter">Inner diameter</param>
            <param name="createBsurface">If true, creates a single b-surface for the inner and outer faces of the tube</param>
            <returns>An NX.Tube object</returns>
        </member>
        <member name="M:Snap.NX.Tube.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Features.Tube tag to a Snap.NX.Tube</summary>
            <param name="nxopenTubeTag">The tag of an NXOpen.Features.Tube object to be converted</param>
            <returns>The Snap.NX.Tube object formed by wrapping the NXOpen.Features.Tube having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Features.Tube object</exception>
        </member>
        <member name="T:Snap.NX.ObjectTypes">
            <summary>Contains enumerations representing NX object types and subtypes</summary>
            <example> 
            This example shows how to use the members of the NX.ObjectTypes class:
            <code title="Members of NX.ObjectTypes class: " lang="VB.NET" source="UI_Type_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.NX.ObjectTypes.Type">
            <summary>Types of NX objects</summary>
            <remarks>
            <para>
            The type codes used here are the same as those in NXOpen.UF.UFConstants and in uf_object_types.h, in most cases.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Arc">
            <summary>Arc/circle type (NXOpen.UF.UFConstants.UF_circle_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Body">
            <summary>Body type. Note: *any* body, solid or sheet (NXOpen.UF.UFConstants.UF_solid_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Camera">
            <summary>Camera type</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Circle">
            <summary>Arc/circle type (NXOpen.UF.UFConstants.UF_circle_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Component">
            <summary>Component type (NXOpen.UF.UFConstants.UF_component_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Conic">
            <summary>Conic type (NXOpen.UF.UFConstants.UF_conic_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Constraint">
            <summary>Constraint type (NXOpen.UF.UFConstants.UF_constraint_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.CoordinateSystem">
            <summary>CoordinateSystem type (NXOpen.UF.UFConstants.UF_coordinate_system_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.DatumAxis">
            <summary>    DatumAxis type (not equal to NXOpen.UF.UFConstants.UF_datum_axis_type)</summary>
            <remarks>
            <para>
            Note that this corresponds to an NXOpen.Features.DatumAxisFeature,
            not to an NXOpen.DatumAxis. So, the value is not equal to
            NXOpen.UF.UFConstants.UF_datum_axis_type.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.DatumPlane">
            <summary>    DatumPlane type (not equal to NXOpen.UF.UFConstants.UF_datum_plane_type)</summary>
            <remarks>
            <para>
            Note that this corresponds to an NXOpen.Features.DatumPlaneFeature,
            not to an NXOpen.DatumPlane. So, the value is not equal to
            NXOpen.UF.UFConstants.UF_datum_plane_type.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Dimension">
            <summary>Dimension type (NXOpen.UF.UFConstants.UF_dimension_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.DraftingEntity">
            <summary>DraftingEntity type (NXOpen.UF.UFConstants.UF_drafting_entity_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Drawing">
            <summary>Drawing type (NXOpen.UF.UFConstants.UF_drawing_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Edge">
            <summary>Edge type (no corresponding code in NXOpen.UF.UFConstants)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Face">
            <summary>Face type (no corresponding code in NXOpen.UF.UFConstants)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.FacettedModel">
            <summary>FacettedModel type (NXOpen.UF.UFConstants.UF_faceted_model_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Feature">
            <summary>Feature type. (NXOpen.UF.UFConstants.UF_feature_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Group">
            <summary>Group type (NXOpen.UF.UFConstants.UF_group_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.LayerCategory">
            <summary>LayerCategory type (NXOpen.UF.UFConstants.UF_layer_category_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Layout">
            <summary>Layout type (NXOpen.UF.UFConstants.UF_layout_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Line">
            <summary>Line type (NXOpen.UF.UFConstants.UF_line_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.LightSource">
            <summary>Light source type (NXOpen.UF.UFConstants.UF_line_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Matrix">
            <summary>Matrix type (NXOpen.UF.UFConstants.UF_matrix_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.ParameterObject">
            <summary>Parameter object, used for global data (NXOpen.UF.UFConstants.UF_parameter_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.PartAttribute">
            <summary>PartAttribute type (NXOpen.UF.UFConstants.UF_part_attribute_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Pattern">
            <summary>Pattern type (NXOpen.UF.UFConstants.UF_pattern_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Plane">
            <summary>Plane type (NXOpen.UF.UFConstants.UF_plane_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Point">
            <summary>Point type (NXOpen.UF.UFConstants.UF_point_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.ReferenceSet">
            <summary>ReferenceSet type (NXOpen.UF.UFConstants.UF_reference_set_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Skeleton">
            <summary>Skeleton object, used for grids, borders, etc. (NXOpen.UF.UFConstants.UF_skeleton_ent_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Spline">
            <summary>Spline type (NXOpen.UF.UFConstants.UF_spline_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.TraceLine">
            <summary>TraceLine type (NXOpen.UF.UFConstants.UF_traceline_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.View">
            <summary>View type (NXOpen.UF.UFConstants.UF_view_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Scalar">
            <summary>Scalar type (NXOpen.UF.UFConstants.UF_scalar_type)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.Type.Direction">
            <summary>Direction type (NXOpen.UF.UFConstants.UF_direction_type)</summary>
        </member>
        <member name="T:Snap.NX.ObjectTypes.SubType">
            <summary>Subtypes of NX objects</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.BodyGeneral">
            <summary>Body subtype: General (either a sheet body or a solid body)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.BodySolid">
            <summary>Body subtype: Solid</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.BodySheet">
            <summary>Body subtype: Sheet</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ComponentGeneral">
            <summary>Component subtype: General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.PartOccurrenceGeneral">
            <summary>Component subtype: Occurrence General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.PartOccurrenceShadow">
            <summary>Component subtype: Occurrence Shadow</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ConicEllipse">
            <summary>Conic subtype: Ellipse (NXOpen.UF.UFConstants.UF_conic_ellipse_subtype)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ConicParabola">
            <summary>Conic subtype: Parabola (NXOpen.UF.UFConstants.UF_conic_parabola_subtype)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ConicHyperbola">
            <summary>Conic subtype: Hyperbola (NXOpen.UF.UFConstants.UF_conic_hyperbola_subtype)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.CsysGeneral">
            <summary>CoordinateSystem subtype: General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.CsysWcs">
            <summary>CoordinateSystem subtype: Wcs</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.CsysCylindrical">
            <summary>CoordinateSystem subtype: Cylindrical</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.CsysSpherical">
            <summary>CoordinateSystem subtype: Spherical</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionHorizontal">
            <summary>Dimension subtype: Horizontal</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionVertical">
            <summary>Dimension subtype: Vertical</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionParallel">
            <summary>Dimension subtype: Parallel</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionCylindrical">
            <summary>Dimension subtype: Cylindrical</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionPerpendicular">
            <summary>Dimension subtype: Perpendicular</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionAngularMinor">
            <summary>Dimension subtype: Angular Minor</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionAngularMajor">
            <summary>Dimension subtype: Angular Major</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionArclength">
            <summary>Dimension subtype: Arc Length</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionRadius">
            <summary>Dimension subtype: Radius</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionDiameter">
            <summary>Dimension subtype: Diameter</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionHole">
            <summary>Dimension subtype: Hole</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionConcCircle">
            <summary>Dimension subtype: Concentric Circles</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionOrdinateHoriz">
            <summary>Dimension subtype: Ordinate Horizontal</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionOrdinateVert">
            <summary>Dimension subtype: Ordinate Vertical</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DimensionAssortedParts">
            <summary>Dimension subtype: Assorted Parts</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityNote">
            <summary>Drafting Entity subtype: Note</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityLabel">
            <summary>Drafting Entity subtype: Label</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityIdSymbol">
            <summary>Drafting Entity subtype: Id Symbol</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityFpt">
            <summary>Drafting Entity subtype: Fpt</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityCenterline">
            <summary>Drafting Entity subtype: Centerline</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityCrosshatch">
            <summary>Drafting Entity subtype: Crosshatch</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.DraftingEntityAssortedParts">
            <summary>Drafting Entity subtype: Assorted Parts</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeLine">
            <summary>Edge subtype: Line</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeArc">
            <summary>Edge subtype: Arc (or circle)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeCircle">
            <summary>Edge subtype: Arc (or circle)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeEllipse">
            <summary>Edge subtype: Ellipse</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeIntersection">
            <summary>Edge subtype: Intersection curve</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeSpline">
            <summary>Edge subtype: Spline</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeSpCurve">
            <summary>Edge subtype: SpCurve (parameter space curve)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeIsoCurve">
            <summary>Edge subtype: IsoCurve (isoparametric curve)</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.EdgeUnknown">
            <summary>Edge subtype: Unknown</summary>
            <remarks>
            <para>
            This is used to denote the type of an edge that is suppressed (because it belongs
            to a suppressed feature). Edges of suppressed features still exist, but they
            have no geometric data.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FacePlane">
            <summary>Face subtype: Plane</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceCylinder">
            <summary>Face subtype: Cylinder</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceCone">
            <summary>Face subtype: Cone</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceSphere">
            <summary>Face subtype: Sphere</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceTorus">
            <summary>Face subtype: Torus</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceBsurface">
            <summary>Face subtype: Bsurface</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceBlend">
            <summary>Face subtype: Blend</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceOffset">
            <summary>Face subtype: Offset</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceExtruded">
            <summary>Face subtype: Extruded</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceRevolved">
            <summary>Face subtype: Revolved</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.FaceUnknown">
            <summary>Face subtype: Unknown</summary>
            <remarks>
            <para>
            This is used to denote the type of a face that is suppressed (because it belongs
            to a suppressed feature). Faces of suppressed features still exist, but they
            have no geometric data.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.LayoutGeneral">
            <summary>Layout subtype: General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.LayoutCanned">
            <summary>Layout subtype: Canned</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.LineGeneral">
            <summary>Line subtype: General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.LineInfinite">
            <summary>Line subtype: Infinite</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.PatternGeneral">
            <summary>Pattern subtype: General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.PatternPoint">
            <summary>Pattern subtype: Point</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.PartAttributeGeneral">
            <summary>Part Attribute subtype: General</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.PartAttributeCache">
            <summary>Part Attribute subtype: Cache</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ReferenceDesign">
            <summary>ReferenceSet subtype: Design</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewSection">
            <summary>View Subtype : Section</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewInstance">
            <summary>View Subtype : Instance</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewImported">
            <summary>View Subtype : Imported</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewBaseMember">
            <summary>View Subtype : Base Member</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewOrthographic">
            <summary>View Subtype : Orthographic</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewAuxiliary">
            <summary>View Subtype : Auxiliary</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewDetail">
            <summary>View Subtype : Detail</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.SubType.ViewModeling">
            <summary>View Subtype : Modeling</summary>
        </member>
        <member name="P:Snap.NX.ObjectTypes.AllCurves">
            <summary>Returns an array containing all the NX curve types</summary>
        </member>
        <member name="P:Snap.NX.ObjectTypes.AllCurvesPrivate">
            <summary>Returns an array containing all the NX curve types</summary>
        </member>
        <member name="T:Snap.NX.ObjectTypes.TypeCombo">
            <summary>A combination of a type and a subtype</summary>
            <remarks>
            <para>
            TypeCombo objects are used to control filtering in Selection. 
            Specifically, you can use TypeCombo objects as input to the
            <see cref= "M:Snap.UI.Block.SelectObject.SetFilter(Snap.NX.ObjectTypes.TypeCombo[])">SetFilter</see> functions.
            </para>
            </remarks>
            <seealso cref= "M:Snap.UI.Block.SelectObject.SetFilter(Snap.NX.ObjectTypes.TypeCombo[])">Snap.UI.Block.SelectObject.SetFilter</seealso>
        </member>
        <member name="F:Snap.NX.ObjectTypes.TypeCombo.Type">
            <summary>Object type (e.g. "conic")</summary>
        </member>
        <member name="F:Snap.NX.ObjectTypes.TypeCombo.SubType">
            <summary>Object subtype (e.g. "ellipse")</summary>
        </member>
        <member name="M:Snap.NX.ObjectTypes.TypeCombo.#ctor(Snap.NX.ObjectTypes.Type,Snap.NX.ObjectTypes.SubType)">
            <summary>Constructs a new TypeCombo from a given type and subtype</summary>
            <param name="type">The object type</param>
            <param name="subtype">The object subtype</param>
        </member>
        <member name="M:Snap.NX.ObjectTypes.TypeCombo.#ctor(Snap.NX.ObjectTypes.Type)">
            <summary>Constructs a new TypeCombo from a given type</summary>
            <param name="type">The object type (subtype is set to zero)</param>
        </member>
        <member name="T:Snap.NX.Unit">
            <summary>
            Represents a Snap.NX.Unit object (interchangeable with <see cref="T:NXOpen.Unit">NXOpen.Unit</see>)
            </summary>
            <remarks>
            <para>
            The most common way to obtain a Snap.NX.Unit object is to simply get the length unit of
            the work part. You can do this using the 
            <see cref= "P:Snap.Globals.PartUnit">Snap.Globals.PartUnit</see> property.
            </para>
            <para>
            Alternatively, there are "constant" units called 
            <see cref= "F:Snap.NX.Unit.Millimeter">Snap.NX.Unit.Millimeter</see>, 
            <see cref= "F:Snap.NX.Unit.Inch">Snap.NX.Unit.Inch</see>, 
            <see cref= "F:Snap.NX.Unit.Degree">Snap.NX.Unit.Degree</see>, and 
            <see cref= "F:Snap.NX.Unit.Radian">Snap.NX.Unit.Radian</see>.
            </para>
            </remarks>
            <seealso cref="P:Snap.Globals.PartUnit">Snap.Globals.PartUnit</seealso>
            <seealso cref= "F:Snap.NX.Unit.Millimeter">Snap.NX.Unit.Millimeter</seealso>
            <seealso cref= "F:Snap.NX.Unit.Inch">Snap.NX.Unit.Inch</seealso>
            <seealso cref= "F:Snap.NX.Unit.Degree">Snap.NX.Unit.Degree</seealso>
            <seealso cref= "F:Snap.NX.Unit.Radian">Snap.NX.Unit.Radian</seealso>
        </member>
        <member name="P:Snap.NX.Unit.NXOpenUnit">
            <summary>The enclosed NXOpen.Unit object</summary>
        </member>
        <member name="P:Snap.NX.Unit.Name">
            <summary>The name of the unit</summary>
        </member>
        <member name="P:Snap.NX.Unit.Abbreviation">
            <summary>The abbreviated name of the unit</summary>
        </member>
        <member name="F:Snap.NX.Unit.Inch">
            <summary>A Snap.NX.Unit object representing "Inches"</summary>
        </member>
        <member name="F:Snap.NX.Unit.Millimeter">
            <summary>A Snap.NX.Unit object representing "Millimeters"</summary>
        </member>
        <member name="F:Snap.NX.Unit.Degree">
            <summary>A Snap.NX.Unit object representing "Degrees"</summary>
        </member>
        <member name="F:Snap.NX.Unit.Radian">
            <summary>A Snap.NX.Unit object representing "Radians"</summary>
        </member>
        <member name="M:Snap.NX.Unit.#ctor(NXOpen.Unit)">
            <summary> Constructor, given an NXOpen.Unit object</summary>
            <param name="unit">An NXOpen.Unit object</param>
        </member>
        <member name="M:Snap.NX.Unit.op_Implicit(NXOpen.Unit)~Snap.NX.Unit">
            <summary> Implicit conversion of NXOpen.Unit to NX.Unit</summary>
            <param name="unit"> An NXOpen.Unit object</param>
            <returns>The corresponding NX.Unit object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Unit.op_Implicit(Snap.NX.Unit)~NXOpen.Unit">
            <summary> Implicit conversion of NX.Unit to NXOpen.Unit</summary>
            <param name="unit"> An NX.Unit object</param>
            <returns>The corresponding NXOpen.Unit object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.Unit.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.Unit tag to a Snap.NX.Unit</summary>
            <param name="nxopenUnitTag">The tag of an NXOpen.Unit object to be converted</param>
            <returns>The Snap.NX.Unit object formed by wrapping the NXOpen.Unit having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.Unit object</exception>
        </member>
        <member name="T:Snap.NX.View">
            <summary>Represents a View object (interchangeable with <see cref="T:NXOpen.View">NXOpen.View</see>)
            </summary>
            <remarks>
            <para>
            Currently, there are no SNAP functions for creating views, but you can use the Work View
            and the standard views (Top, Front, Right, etc.)
            </para>
            </remarks>
            <seealso cref= "P:Snap.Globals.WorkView">Snap.Globals.WorkView</seealso>
            <seealso cref= "T:Snap.NX.View.Standard">Snap.NX.View.Standard</seealso>
        </member>
        <member name="P:Snap.NX.View.NXOpenView">
            <summary>The enclosed NXOpen.View object</summary>
        </member>
        <member name="P:Snap.NX.View.Name">
            <summary>The name of the view</summary>
        </member>
        <member name="P:Snap.NX.View.NXOpenTag">
            <summary>Get the NXOpen.Tag from this NX.View</summary>
        </member>
        <member name="M:Snap.NX.View.op_Implicit(NXOpen.View)~Snap.NX.View">
            <summary> Implicit conversion of NXOpen.View to NX.View</summary>
            <param name="view"> An NXOpen.View object</param>
            <returns>The corresponding NX.View object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.View.op_Implicit(Snap.NX.View)~NXOpen.View">
            <summary> Implicit conversion of NX.View to NXOpen.View</summary>
            <param name="view"> An NX.View object</param>
            <returns>The corresponding NXOpen.View object</returns>
            <exclude/>
        </member>
        <member name="M:Snap.NX.View.CreateView(System.String)">
            <summary>Creates a view with a given name</summary>
            <param name="name">Name of view</param>
            <returns>An NX.View object </returns>
        </member>
        <member name="M:Snap.NX.View.FindByName(System.String)">
            <summary>Find the view in the work part that has a given name</summary>
            <param name="name">Name of the view</param>
            <returns>The NX.View object having the given name, or <c>Nothing</c></returns>
            <remarks>
            <para>
            You can use this function to find out whether a view having a given name
            already exists. Specifically, if <c>FindByName("myView")</c> returns
             <c>Nothing</c>, then a view called "myView" does not yet exist.
            </para>
            </remarks>
            <seealso cref="T:Snap.NX.View">Snap.NX.View</seealso>
        </member>
        <member name="M:Snap.NX.View.Wrap(NXOpen.Tag)">
            <summary>Convert an NXOpen.View tag to a Snap.NX.View</summary>
            <param name="nxopenViewTag">The tag of an NXOpen.View object to be converted</param>
            <returns>The Snap.NX.View object formed by wrapping the NXOpen.View having the given tag</returns>
            <remarks>
            <para>
            In many cases, you can just use an NXOpen object directly in SNAP functions, without wrapping. 
            The main reason for wrapping is to allow use of the properties of the resulting SNAP object.
            </para>
            <para>
            For more information about wrapping NXOpen objects, please see the section entitled "Mixing
            SNAP and NX Open" in the SNAP Getting Started Guide; it's the last section in chapter&#160;16.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input tag is NXOpen.Tag.Null, or it doesn't belong to an NXOpen.View object</exception>
        </member>
        <member name="M:Snap.NX.View.ToString">
            <summary>
            Returns a string representation of the view
            </summary>
            <returns>A string containing the object type (view) and its NXOpen tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this view is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.NX.View.Standard">
            <summary>A class containing standard or "canned" views (top, front, right, etc.)</summary>
            <remarks>
            <para>
            These views are present in every NX part file, and they cannot be deleted or renamed.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Top">
            <summary>The standard or "canned" top view</summary>
            <remarks>
            <para>
            This view has
            <list type = "bullet">
            <item>The X-axis pointing from left to right</item>
            <item>The Y-axis pointing upwards</item>
            <item>The Z-axis pointing out of the screen</item>         
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Front">
            <summary>The standard or "canned" front view</summary>
            <remarks>
            <para>
            This view has
            <list type = "bullet">
            <item>The X-axis pointing from left to right</item>
            <item>The Z-axis pointing upwards</item>
            <item>The Y-axis pointing out of the screen</item>         
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Right">
            <summary>The standard or "canned" right side view</summary>
            <remarks>
            <para>
            This view has
            <list type = "bullet">
            <item>The Y-axis pointing from left to right</item>
            <item>The Z-axis pointing upwards</item>
            <item>The X-axis pointing out of the screen</item>         
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Back">
            <summary>The standard or "canned" back view</summary>
            <remarks>
            <para>
            This view has
            <list type = "bullet">
            <item>The X-axis pointing from right to left</item>
            <item>The Z-axis pointing upwards</item>
            <item>The Y-axis pointing out of the screen</item>         
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Bottom">
            <summary>The standard or "canned" bottom view</summary>
            <remarks>
            <para>
            This view has
            <list type = "bullet">
            <item>The X-axis pointing from left to right</item>
            <item>The Y-axis pointing downwards</item>
            <item>The Z-axis pointing into the screen</item>         
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Left">
            <summary>The standard or "canned" left side view</summary>
            <remarks>
            <para>
            This view has
            <list type = "bullet">
            <item>The Y-axis pointing from right to left</item>
            <item>The Z-axis pointing upwards</item>
            <item>The X-axis pointing into the screen</item>         
            </list>
            </para>
            </remarks> 
        </member>
        <member name="P:Snap.NX.View.Standard.Isometric">
            <summary>The standard or "canned" isometric view</summary>
            <remarks>
            <para>
            This is an isometric view in which the top, front, and right-hand faces
            of the object are visible. The Z-axis appears to be vertical, in this view.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.NX.View.Standard.Trimetric">
            <summary>The standard or "canned" trimetric view</summary>
            <remarks>
            <para>
            This is a trimetric view in which the top, front, and right-hand faces
            of the object are visible. The Z-axis appears to be vertical, in this view.
            </para>
            </remarks>         
        </member>
        <member name="T:Snap.Topology.Fin">
            <summary>A fin is "half" of an edge -- an oriented use of an edge by a loop</summary>
            <remarks>
            <para>
            A fin has:
            <list type="bullet">
            <item>
            A logical 'sense' indicating whether the fin's orientation, 
            and therefore the orientation of its owning loop, is the same as its owning edge
            </item>
            <item>A curve, which may be <c>Nothing</c> if geometry is attached to the fin's edge, instead. 
            </item>
            </list>
            </para>
            <para>
            In some software systems, fins are called "half-edges" or "co-edges".
            </para>
            <para>
            The picture below shows the fins and edges on three faces of a cube.
            The thick blue lines are edges, and the thin red ones are fins.
            </para>
            <img src="../Images/fins.png"/>
            <para>
            Note how each edge has two corresponding fins, which have opposite
            senses. On the vertical edge, E3, for example, fin F4 has a positive 
            sense (i.e. the same direction as E3), and fin F5 has a negative sense.
            </para>
            <para>
            Within each loop, the fins have a consistent direction,
            and, when walking along the loop in this direction, the loop's face
            lies on your left. In simple cases, this means that
            peripheral loops will have a counterclockwise direction, and hole loops
            will have a clockwise direction, when viewed from outside the body.
            </para>
            <para>
            The red vertex is the start vertex of fins F2, F3 and F5, and it is the
            end vertex of fins F1, F4, and F6.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Topology.Fin.Body">
            <summary>The body on which this fin lies</summary>
        </member>
        <member name="P:Snap.Topology.Fin.Loop">
            <summary>The loop to which this fin belongs</summary>
        </member>
        <member name="P:Snap.Topology.Fin.Face">
            <summary>The face to which this fin belongs</summary>
            <remarks>
            <para>
            Actually, the relationship between the fin and the face is indirect:
            the fin belongs to a loop, and that loop then belongs to a face.
            This property just provides a shortcut that allows you to get to the face
            in one step instead of two.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Topology.Fin.Edge">
            <summary>The edge to which this fin belongs</summary>
        </member>
        <member name="P:Snap.Topology.Fin.Next">
            <summary>The next fin in the loop</summary>
            <remarks>
            <para>
            You can use this function to cycle through the fins in a loop, one at a time, 
            in the "forward" direction (i.e. in the order returned by
            <see cref= "P:Snap.Topology.Loop.Fins">Snap.Topology.Loop.Fins</see>. 
            The ordering is cyclic, so the first fin is returned again after the last one.
            </para>
            <para>
            If there is only one fin in the loop, then this property returns the current fin.
            </para>
            </remarks>
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and cycles through
            the fins of one of its loops.. 
            <code title="Cycling through fins" lang="VB.NET" source="FinNext_01.vb">
            </code> 
            </example>
            <seealso cref= "T:Snap.Topology.Loop">Snap.Topology.Loop</seealso>
            <seealso cref= "P:Snap.Topology.Fin.Previous">Snap.Topology.Fin.Previous</seealso>
            <seealso cref= "P:Snap.Topology.Loop.Fins">Snap.Topology.Loop.Fins</seealso>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
        </member>
        <member name="P:Snap.Topology.Fin.Previous">
            <summary>The previous fin in the loop</summary>
            <remarks>
            <para>
            You can use this function to cycle through the fins in a loop, one at a time, 
            in the "reverse" direction (i.e. the opposite of the order returned by
            <see cref= "P:Snap.Topology.Loop.Fins">Snap.Topology.Loop.Fins</see>. 
            The ordering is cyclic, so the last fin is returned again after the first one.
            </para>
            <para>
            If there is only one fin in the loop, then this property returns the current fin.
            </para>
            </remarks>
            <seealso cref= "T:Snap.Topology.Loop">Snap.Topology.Loop</seealso>
            <seealso cref= "P:Snap.Topology.Fin.Next">Snap.Topology.Fin.Next</seealso>
            <seealso cref= "P:Snap.Topology.Loop.Fins">Snap.Topology.Loop.Fins</seealso>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
        </member>
        <member name="P:Snap.Topology.Fin.Sense">
            <summary>The sense of the fin with respect to its owning edge</summary>
            <remarks>
            <para>
            If a given edge has two fins, then these two fins will have opposite senses.
            </para>
            <para>
            The fin sense allows you to determine the "forward" direction of the fin
            and its loop.
            This is important because you can then find the "left" side
            of the fin, which is where its face lies.
            </para>
            </remarks>
            <example> 
            In the following example, we use the fin sense to construct a vector that points
            to the left of the fin, into the interior of its face.
            <code title="Finding the left side of a fin" lang="VB.NET" source="FinSense_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Topology.Fin.StartVertex">
            <summary>The start vertex of the fin</summary>
            <remarks>
            <para>
            There are three possible cases:
            <list type = "bullet">
            <item>
            If the fin has no vertices, this property returns <c>Nothing</c>
            </item>
            <item>
            If the fin has one vertex (because its start and end points are coincident), 
            then this property returns the common start/end vertex. This case is rare.
            </item>
            <item>
            If the fin has two vertices, this property returns the one that is shared
            by this fin and the previous fin in the loop.
            </item>
            </list>
            </para>
            </remarks>
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and gets the start and
            end vertices of the fins in one of its loops.
            <code title="Getting a fin's vertices" lang="VB.NET" source="FinVertices_01.vb"> 
            </code> 
            </example>
            <seealso cref= "P:Snap.Topology.Fin.Previous">Snap.Topology.Fin.Previous</seealso>
            <seealso cref= "P:Snap.Topology.Fin.EndVertex">Snap.Topology.Fin.EndVertex</seealso>
        </member>
        <member name="P:Snap.Topology.Fin.EndVertex">
            <summary>The end vertex of the fin</summary>
            <remarks>
            <para>
            There are three possible cases:
            <list type = "bullet">
            <item>
            If the fin has no vertices, this property returns <c>Nothing</c>
            </item>
            <item>
            If the fin has one vertex (because its start and end points are coincident), 
            then this property returns the common start/end vertex. This case is rare.
            </item>
            <item>
            If the fin has two vertices, this property returns the one that is shared
            by this fin and the next fin in the loop.
            </item>
            </list>
            </para>
            </remarks>
            <seealso cref= "P:Snap.Topology.Fin.Next">Snap.Topology.Fin.Next</seealso>
            <seealso cref= "P:Snap.Topology.Fin.StartVertex">Snap.Topology.Fin.StartVertex</seealso>
        </member>
        <member name="M:Snap.Topology.Fin.ToString">
            <summary>
            Returns a string representation of the fin
            </summary>
            <returns>A string containing the object type and its Parasolid tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this object is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Topology.Loop">
            <summary>A loop is a connected sequence of fins that form part of the boundary of a face</summary>
            <remarks>
            <para>
            Typically, a face will have one peripheral loop and perhaps some hole loops in its interior.
            </para>
            <para>
            Within each loop, the fins have a consistent direction,
            and, when walking along the loop in this direction, the loop's face
            lies on your left. In simple cases, this means that
            peripheral loops will have a counterclockwise direction, and hole loops
            will have a clockwise direction, when viewed from outside the body.
            </para>
            <para>
            Note that you can not use "loop" as the name of a variable in your code,
            because it is a reserved word in the Visual Basic language.
            </para>
            </remarks>
            <seealso cref= "T:Snap.Topology.Fin">Snap.Topology.Fin</seealso>
        </member>
        <member name="P:Snap.Topology.Loop.Body">
            <summary>The body on which this loop lies</summary>
        </member>
        <member name="P:Snap.Topology.Loop.Face">
            <summary>The face on which this loop lies</summary>
        </member>
        <member name="P:Snap.Topology.Loop.Vertices">
            <summary>The array of vertices in the loop</summary>
            <remarks>
            <para>
            If the loop has no vertices (a loop containing
            a single circular edge, for example), 
            this property will return an array of length zero.
            </para>
            </remarks>
            <seealso cref= "T:Snap.Topology.Vertex">Snap.Topology.Vertex</seealso>
        </member>
        <member name="P:Snap.Topology.Loop.Fins">
            <summary>The array of fins in the loop</summary>
            <remarks>
            <para>
            The fins are ordered nose-to-tail around the loop, so that the end of each fin coincides with
            the beginning of the next fin in the list, and the end of the last fin
            coincides with the start of the first one.
            </para>
            <para>
            If you were to walk along the fin, with the face normal pointing from your 
            feet up towards your head, then the face that owns the fin would be on your left.
            </para>
            <para>
            If you prefer to get the fins of a loop one at a time, rather than
            getting them all at once, you can use the 
            <see cref= "P:Snap.Topology.Fin.Next">Next</see> or
            <see cref= "P:Snap.Topology.Fin.Previous">Previous</see> properties
            to cycle through them.
            </para>
            </remarks>
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and gets information
            about the fins in the outer loop of one of its faces.. 
            <code title="Finding fin information" lang="VB.NET" source="LoopFins_01.vb">
            </code> 
            </example>
            <seealso cref= "T:Snap.Topology.Fin">Snap.Topology.Fin</seealso>
            <seealso cref= "P:Snap.Topology.Fin.Next">Snap.Topology.Fin.Next</seealso>
            <seealso cref= "P:Snap.Topology.Fin.Previous">Snap.Topology.Fin.Previous</seealso>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
        </member>
        <member name="P:Snap.Topology.Loop.Edges">
            <summary>The array of edges in the loop</summary>
            <remarks>
            <para>
            There are cases where a loop has no edges. For example, at the tip of
            cone, there is a loop that contains one vertex and zero edges. In this
            case, this function will return an array with length zero.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Topology.Loop.Type">
            <summary>The type of the loop (peripheral, hole, etc.)</summary>
            <seealso cref= "T:Snap.Topology.LoopType">Snap.Topology.LoopType</seealso>
        </member>
        <member name="M:Snap.Topology.Loop.ToString">
            <summary>
            Returns a string representation of the loop
            </summary>
            <returns>A string containing the object type and its Parasolid tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this object is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Topology.Shell">
            <summary>A shell is a connected set of faces forming part of the boundary of a body</summary>
            <remarks>
            <para>
            Two faces can belong to the same shell only if they are "connected"
            in the sense that they share a common edge.
            </para>
            <para>
            A typical solid body has a single outer shell and perhaps some inner shells
            that define internal voids.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Topology.Shell.Faces">
            <summary>The array of <see cref= "T:Snap.NX.Face">faces</see> in the shell</summary>>
            <seealso cref= "T:Snap.NX.Face">Snap.NX.Face</seealso>
        </member>
        <member name="P:Snap.Topology.Shell.Type">
            <summary>The type of the shell (Outer, Inner, or Open)</summary>
            <seealso cref= "T:Snap.Topology.ShellType">Snap.Topology.ShellType</seealso>
        </member>
        <member name="P:Snap.Topology.Shell.Body">
            <summary>The body that contains this shell</summary>
        </member>
        <member name="M:Snap.Topology.Shell.ToString">
            <summary>
            Returns a string representation of the shell
            </summary>
            <returns>A string containing the object type and its Parasolid tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this object is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Topology.Sense">
            <summary>
            A plus/minus value used to indicate the sense of a
            <see cref= "T:Snap.NX.Face">Face</see>,
            <see cref= "T:Snap.NX.Edge">Edge</see>, or
            <see cref= "T:Snap.Topology.Fin">Fin</see>.
            </summary>
        </member>
        <member name="F:Snap.Topology.Sense.Positive">
            <summary>The items are aligned (they have the same sense)</summary>
        </member>
        <member name="F:Snap.Topology.Sense.Negative">
            <summary>The items are anti-aligned (they have opposite senses)</summary>
        </member>
        <member name="T:Snap.Topology.ShellType">
            <summary>
            The type of a 
            <see cref= "T:Snap.Topology.Shell">Shell</see> object.
            </summary>
        </member>
        <member name="F:Snap.Topology.ShellType.Outer">
            <summary>The shell represents the exterior surface of a solid body</summary>
        </member>
        <member name="F:Snap.Topology.ShellType.Inner">
            <summary>The shell represents a void inside a solid body</summary>
        </member>
        <member name="F:Snap.Topology.ShellType.Open">
            <summary>The shell represents a sheet body</summary>
        </member>
        <member name="T:Snap.Topology.LoopType">
            <summary>
            The type of a 
            <see cref= "T:Snap.Topology.Loop">Loop</see> object.
            </summary>
            <remarks>
            <para>
            For planes and other non-periodic surfaces, all loops are either
            of type Outer or Inner. Each face has one 
            peripheral loop (type Outer) and possibly some holes (type Inner).
            </para>
            <para>
            For cylindrical topology, i.e. surfaces that are periodic in one
            parameter direction only, closed loops that wind once around the periodic
            parameter space are of type Winding. To define the
            periphery of a face in this situation, you
            need either an Outer loop or a matched pair of Winding loops.
            </para>
            <para>
            A winding loop that completely surrounds the tip (singularity) of a cone
            has type InnerSingular.
            </para>
            <para>
            On spheres and donut tori, it is sometimes not clear whether
            a loop represents a periphery or a hole. This is the reason
            for the loop types LikelyOuter, LikelyInner, and Unknown.
            </para>
            </remarks>
            <example> 
            The following example creates a 
            <see cref= "M:Snap.Create.Widget">Widget</see> object and lists its loop types
            <code title="Listing loop types" lang="VB.NET" source="LoopType_01.vb"> 
            </code> 
            </example>
            <seealso cref= "M:Snap.Create.Widget">Widget</seealso>
            <seealso cref= "T:Snap.Topology.Loop">Snap.Topology.Loop</seealso>   
        </member>
        <member name="F:Snap.Topology.LoopType.Outer">
            <summary>A simple peripheral loop</summary>    
        </member>
        <member name="F:Snap.Topology.LoopType.Inner">
            <summary>A simple hole loop</summary>    
        </member>
        <member name="F:Snap.Topology.LoopType.Winding">
            <summary>A winding loop on a periodic surface e.g. a circle on a cylinder or doughnut</summary>    
        </member>
        <member name="F:Snap.Topology.LoopType.InnerSingular">
            <summary>A hole loop around a surface singularity, e.g. chopping the top off a cone</summary>    
        </member>
        <member name="F:Snap.Topology.LoopType.LikelyOuter">
            <summary>An apparently peripheral loop on a doubly closed surface</summary>    
        </member>
        <member name="F:Snap.Topology.LoopType.LikelyInner">
            <summary>An apparent hole in a doubly closed surface</summary>    
        </member>
        <member name="F:Snap.Topology.LoopType.Unknown">
            <summary>Unknown    loop type </summary>    
        </member>
        <member name="T:Snap.Topology.Topo">
            <summary>An abstract class representing any topology object</summary>
            <remarks>
            <para>
            You will probably never use a Topo object directly. Instead, you will
            use more concrete objects like fins, loops, shells, and vertices, which inherit
            from the Topo class.
            </para>
            <para>
            In some sense, 
            <see cref= "T:Snap.NX.Face">Snap.NX.Face</see> and
            <see cref= "T:Snap.NX.Edge">Snap.NX.Edge</see> objects also represent "topology".
            But the Snap.NX objects are persistent (stored in NX part files), whereas the 
            Snap.Topology objects are transient. As soon as your SNAP program has finished executing,
            all of your fins, loops, shells, and vertices are gone.
            </para>
            </remarks>
            <seealso cref= "T:Snap.NX.Face">Snap.NX.Face</seealso>
            <seealso cref= "T:Snap.NX.Edge">Snap.NX.Edge</seealso>
        </member>
        <member name="P:Snap.Topology.Topo.PsTopology">
            <summary>Gets the corresponding Parasolid topology object</summary>
        </member>
        <member name="P:Snap.Topology.Topo.PsTag">
            <summary>Gets the Parasolid tag of the corresponding Parasolid topology object</summary>
        </member>
        <member name="M:Snap.Topology.Topo.#ctor(PLMComponents.Parasolid.PK_.Unsafe.TOPOL_t)">
            <summary>Create a new Snap.Topology.Topo object</summary>
            <param name="psTopo"></param>
        </member>
        <member name="M:Snap.Topology.Topo.ToString">
            <summary>
            Returns a string representation of the object
            </summary>
            <returns>A string containing the object type and its Parasolid tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this object is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Topology.NamespaceDoc">
            <summary>
            Contains objects and functions that help you get detailed information about the topology of a body
            (how the faces and edges are connected to each other). 
            </summary>
            <remarks>
            <para>
            You can do basic topological enquiries using the
            <see cref= "T:Snap.NX.Face">Snap.NX.Face</see> and
            <see cref= "T:Snap.NX.Edge">Snap.NX.Edge</see> objects.
            But the 
            <see cref= "T:Snap.Topology.Loop">Loop</see>,
            <see cref= "T:Snap.Topology.Fin">Fin</see>, and
            <see cref= "T:Snap.Topology.Vertex">Vertex</see> objects
            here in the Topology namespace allow you to get more detailed information.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.Topology.Vertex">
            <summary>A vertex is a place where several edges meet</summary>
            <remarks>
            <para>
            An edge may have zero, one, or two vertices.
            <list type="bullet">
            <item>An edge with zero vertices is a closed ring shape. Its start and end points coincide,
            and the start/end junction is smooth. 
            Examples are edges E1 and E2 in the image below.</item>
            <item>An edge with one vertex is again a closed ring shape whose start and end points coincide.
            But it has a distinct corner at the start/end junction point.
            Examples are edges E3 and E4 in the image below.</item>
            <item>An edge with two vertices is open; its start and end points are different. 
            An example is edge E5 in the image below.</item>      
            </list>
            </para>
            <para>
            <img src="../Images/vertices.png"/>
            </para>
            <para>
            Edges with one vertex are fairly unusual; most edges have either zero or two vertices.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.Topology.Vertex.Body">
            <summary>The body on which this vertex lies</summary>
        </member>
        <member name="P:Snap.Topology.Vertex.Shell">
            <summary>The shell that the vertex belongs to</summary>
            <remarks>
            <para>
            In NX objects, a vertex always belongs to exactly one shell.
            </para>
            </remarks>
            <seealso cref= "T:Snap.Topology.Shell">Snap.Topology.Shell</seealso>
        </member>
        <member name="P:Snap.Topology.Vertex.Faces">
            <summary>The faces on which the vertex lies</summary>
            <remarks>
            <para>
            A vertex might lie on one, two, or more faces. The most common
            situation is a vertex lying on three faces. 
            </para>
            </remarks>
            <example>
            This example shows how to cycle through vertices, finding the faces that meet at each one:
            <code title="Getting vertex faces" lang="VB.NET" source="VertexFaces_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.Topology.Vertex.Edges">
            <summary>The edges on which the vertex lies</summary>
            <remarks>
            <para>
            A vertex might lie on zero, one, two, or more edges.
            </para>
            <para>
            If the vertex lies on zero edges, this property will return an array of length zero.
            </para>
            </remarks>
            <example> 
            This example shows how to get the edges meeting at each vertex:
            <code title="Get the edges meeting at each vertex" lang="VB.NET" source="VertexEdges_01.vb"> 
            </code> 
            </example>
            <seealso cref= "T:Snap.NX.Edge">Snap.NX.Edge</seealso>
        </member>
        <member name="P:Snap.Topology.Vertex.Position">
            <summary>The position of the vertex</summary>
        </member>
        <member name="M:Snap.Topology.Vertex.ToString">
            <summary>
            Returns a string representation of the vertex
            </summary>
            <returns>A string containing the object type and its Parasolid tag</returns>
            <remarks>
            <para>
            Returns an empty zero-length string if this object is <c>Nothing</c>
            </para>
            </remarks>
        </member>
        <member name="T:Snap.UI.BlockDialog">
            <summary>The SNAP class representing an NX Block-Based Dialog</summary>
            <remarks>
            <para>
            A Snap.UI.BlockDialog is very similar to an NXOpen.BlockStyler.BlockDialog.
            You use the NX Block UI Styler application to place blocks on these dialogs
            and set the properties of these blocks.
            </para>
            <para>
            Please see Chapter 13 and Chapter 14 of the "Getting Started with SNAP" guide 
            for more information about BlockDialogs. 
            </para>
            <para>
            SNAP also provides another type of block-based dialog, called a 
            <see cref="T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>,
            which you can create without using Block UI Styler.
            </para>
            </remarks>
        </member>
        <member name="F:Snap.UI.BlockDialog.NXOpenBlockDialog">
            <summary>The NXOpen.BlockStyler.BlockDialog object encapsulated by this dialog</summary>
        </member>
        <member name="M:Snap.UI.BlockDialog.#ctor(System.String)">
            <summary>Creates a Snap.UI.BlockDialog from a given dlx file</summary>
            <param name="dlxPathName">The path name of the dlx file to be used to create the dialog</param>
        </member>
        <member name="M:Snap.UI.BlockDialog.#ctor">
            <summary>Creates a Snap.UI.BlockDialog with a <c>Nothing</c> NXOpenBlockDialog field</summary>
        </member>
        <member name="P:Snap.UI.BlockDialog.Cue">
            <summary>The message to be displayed in the Cue line</summary>
        </member>
        <member name="P:Snap.UI.BlockDialog.Title">
            <summary>The text to be displayed in the title bar of the dialog </summary>
        </member>
        <member name="M:Snap.UI.BlockDialog.Show">
            <summary>Displays the dialog</summary>
            <returns>Response</returns>
        </member>
        <member name="M:Snap.UI.BlockDialog.Show(Snap.UI.DialogMode)">
            <summary>Displays the dialog</summary>
            <param name="mode">Display mode (create or edit)</param>
            <returns>Response</returns>
            <remarks>
            <para>
            The mode controls the display of the Apply button
            <list type = "bullet">
            <item>mode = DialogMode.Create : the Apply button is shown </item>
            <item>mode = DialogMode.Edit   : the Apply button is not shown </item>
            </list>
            </para>
            </remarks>      
        </member>
        <member name="M:Snap.UI.BlockDialog.Dispose">
            <summary>Releases memory and other resources used by the dialog</summary>      
        </member>
        <member name="T:Snap.UI.DialogMode">
            <summary>The options of showing the dialog</summary>
        </member>
        <member name="F:Snap.UI.DialogMode.Create">
            <summary>
            When the user presses OK or Apply on the dialog, the user's inputs are saved
            in dialog memory and the next time that the dialog is shown in Create mode,
            the dialog is initialized using the user's previous inputs.
            </summary>
        </member>
        <member name="F:Snap.UI.DialogMode.Edit">
            <summary>
            The Apply button is not shown. The user's inputs are not saved in dialog
            memory and the dialog is not initialized with the user's previous inputs.
            </summary>
        </member>
        <member name="T:Snap.UI.BlockForm">
            <summary>Represents a Snap.UI.BlockForm (a type of block-based dialog)</summary>
            <remarks>
            <para>
            A Snap.UI.BlockForm is a type of block-based dialog. In your code, you 
            first create a BlockForm, and then you create blocks, adjust their 
            properties, and add them to your BlockForm. 
            </para>
            <para>
            Please see Chapter 13 of the "Getting Started with SNAP" guide for more information
            about BlockForms. 
            </para>
            <para>
            SNAP also provides another type of block-based dialog, called a 
            <see cref="T:Snap.UI.BlockDialog">Snap.UI.BlockDialog</see>,
            which you create using the NX Block UI Styler application.
            </para>
            </remarks>
            <example> 
            This example shows how to use a BlockForm:
            <code title="Using a BlockForm:" lang="VB.NET" source="UI_Block_SpokesForm_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.UI.BlockForm.Cue">
            <summary>The message to be displayed in the Cue line</summary>
        </member>
        <member name="P:Snap.UI.BlockForm.Title">
            <summary>The text to be displayed in the title bar of the form </summary>
        </member>
        <member name="M:Snap.UI.BlockForm.#ctor">
            <summary>Creates a new BlockForm</summary>
            <remarks>The default title is "SnapDialog", and the default cue is the empty string.</remarks>
        </member>
        <member name="M:Snap.UI.BlockForm.#ctor(System.String,System.String)">
            <summary>Creates a new BlockForm with a given cue and title</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="title">Text shown in the title bar of the dialog window</param>
        </member>
        <member name="M:Snap.UI.BlockForm.#ctor(System.String)">
            <summary>Creates a new BlockForm with a given title</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
        </member>
        <member name="M:Snap.UI.BlockForm.Show">
            <summary>Displays the BlockForm</summary>
            <returns>Response</returns>
            <remarks>
            <para>
            An exception will be raised if the BlockForm does not contain any blocks.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The BlockForm does not contain any blocks.</exception>
        </member>
        <member name="M:Snap.UI.BlockForm.Show(Snap.UI.DialogMode)">
            <summary>Displays the BlockForm</summary>
            <param name="mode">Display mode (create or edit)</param>
            <returns>Response</returns>
            <remarks>
            <para>
            The mode controls the display of the Apply button
            <list type = "bullet">
            <item>mode = DialogMode.Create : the Apply button is shown </item>
            <item>mode = DialogMode.Edit   : the Apply button is not shown </item>
            </list>
            An exception will be raised if the BlockForm does not contain any blocks.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The BlockForm does not contain any blocks.</exception>
        </member>
        <member name="M:Snap.UI.BlockForm.Dispose">
            <summary>Releases memory and other resources used by the BlockForm</summary>      
        </member>
        <member name="M:Snap.UI.BlockForm.AddBlocks(Snap.UI.Block.General[])">
            <summary>Add blocks to a BlockForm</summary>
            <param name="blocks">The array of blocks to be added</param>
            <example> 
            This example shows how to add blocks to a BlockForm:
            <code title="Adding blocks to a BlockForm: " lang="VB.NET" source="UI_Block_SphereCap_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.BlockForm.OnApply">
            <summary>The BlockForm's callback function for the "Apply" event</summary>
            <remarks>
            <para>
            This callback function is executed when the user clicks on the Apply button in your dialog.
            </para>
            <para>
            You should over-ride this function with your own version, which should contain the code
            you want to have executed when the Apply event occurs.
            </para>
            <para>
            For more information about how to use BlockForm callbacks, please refer to chapter&#160;13
            and chapter&#160;14 in the SNAP Getting Started Guide.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.BlockForm.OnOK">
            <summary>The BlockForm's callback function for the "OK" event</summary>
            <remarks>
            <para>
            This callback function is executed when the user clicks on the OK button in your dialog.
            </para>
            <para>
            You should over-ride this function with your own version, which should contain the code
            you want to have executed when the OK event occurs.
            </para>
            <para>
            For more information about how to use BlockForm callbacks, please refer to chapter&#160;13
            and chapter&#160;14 in the SNAP Getting Started Guide.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.BlockForm.OnCancel">
            <summary>The BlockForm's callback function for the "Cancel" event</summary>
            <remarks>
            <para>
            This callback function is executed when the user clicks on the Cancel button in your dialog.
            </para>
            <para>
            You should over-ride this function with your own version, which should contain the code
            you want to have executed when the Cancel event occurs.
            </para>
            <para>
            For more information about how to use BlockForm callbacks, please refer to chapter&#160;13
            and chapter&#160;14 in the SNAP Getting Started Guide.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.BlockForm.OnUpdate(Snap.UI.Block.General)">
            <summary>Update callback function</summary>
            <param name="changedBlock">The block in which the user made a change</param>
            <remarks>
            <para>
            This callback function is executed when the user changes some value in some block on your BlockForm.
            </para>
            <para>
            You should over-ride this function with your own version, which should contain the code
            you want to have executed when the change occurs.
            </para>
            <para>
            Typically, your code will first test the <paramref name="changedBlock"/> parameter,
            to find out which block it is, and then react accordingly.
            </para>
            <para>
            For more information about how to use BlockForm callbacks, please refer to chapter&#160;13
            and chapter&#160;14 in the SNAP Getting Started Guide.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.BlockForm.OnShow">
            <summary>The BlockForm's callback function for the "Show" event</summary>
            <remarks>
            <para>
            This callback function is executed immediately before your BlockForm is shown (displayed to the user).
            </para>
            <para>
            You should over-ride this function with your own version, which should contain the code
            you want to have executed when the Show event occurs.
            </para>
            <para>
            Execution of the code in this function is the last thing that happens before your BlockForm is displayed,
            so it gives you one last chance to over-ride values and settings in the dialog. Specifically, you can
            over-write values that were retrieved from "dialog memory", if you want to.
            </para>
            <para>
            For more information about how to use BlockForm callbacks, please refer to chapter&#160;13
            and chapter&#160;14 in the SNAP Getting Started Guide.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.BlockForm.InventBlockID(Snap.UI.Block.General)">
            <summary>Creates a name (sometimes called a BlockID) for a given block</summary>
            <param name="inputBlock">The block to be named</param>
            <returns>The name we invented. Names look like [inputBlock.Type]nnn, where nnn is a count. E.g. Button3, ListBox5</returns>
        </member>
        <member name="T:Snap.UI.Input">
            <summary>Functions to support simple input of information (numbers, positions, vectors, etc.)</summary>
            <example>
            This example shows how to use the functions of the Snap.UI.Input class:
            <code title="Using the Snap.UI.Input functions: " lang="VB.NET" source="UI_Dialog_01.vb"> 
            </code>
            </example>   
        </member>
        <member name="M:Snap.UI.Input.GetChoice(System.String[],System.String,System.String,System.String,Snap.UI.Block.EnumPresentationStyle)">
            <summary>Display a simple dialog allowing the user to choose one from a set of items</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed next to the list of choices</param>
            <param name="items">The array of items to choose from</param>
            <param name="style">Presentation style. Optional. Default = Snap.UI.Block.EnumPresentationStyle.RadioBox</param>
            <returns>The index of the chosen item in the array (zero based)</returns>
            <example> 
            This example shows how to choose an item:
            <code title="Get a choice" lang="VB.NET" source="UI_Dialog_07.vb">
            </code>
            The first call to GetChoice displays a drop-down option menu (EnumPresentationStyle.OptionMenu):
            <para>
            <img src="../Images/get_choice_dropdown.PNG"/>
            </para>
            The second one uses the default radio box style (EnumPresentationStyle.RadioBox):
            <para>
            <img src="../Images/get_choice_radio.PNG"/>
            </para>
            </example>
        </member>
        <member name="M:Snap.UI.Input.GetChoices(System.String[],System.String,System.String,System.String)">
            <summary>Display a simple dialog allowing the user to choose (one or more) items from a list</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed above the list of choices</param>
            <param name="items">The array of items to choose from</param>
            <returns>The indices of the chosen items in the array (zero-based)</returns>
            <example> 
            This example shows how to specify a choice:
            <code title="Get a choice" lang="VB.NET" source="UI_Dialog_12.vb">
            </code>
            The call to GetChoices displays the following dialog:
            <para>
            <img src="../Images/get_choices.PNG"/>
            </para>
            </example>
        </member>
        <member name="M:Snap.UI.Input.GetDouble(System.String,System.String,System.String,System.Double)">
            <summary>Display a simple dialog allowing the user to input a floating point number</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed to the left of the numerical entry field</param>
            <param name="initialValue">The initial value to be displayed in the numerical entry field.  Optional. Default = 0.0</param>
            <returns>The number the user entered</returns>
            <example> 
            This example shows how to get a double: 
            <code title="Get a double" lang="VB.NET" source="UI_Dialog_02.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.UI.Input.GetDoubles(System.String,System.String[],System.Double[])">
            <summary>Display a simple dialog allowing the user to input floating point numbers</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="labels">Labels displayed to the left of the numerical entry fields</param>
            <param name="initialValues">The initial values to be displayed in the numerical entry fields</param>
            <returns>The numbers the user entered</returns>
            <example> 
            This example shows how to get floating point numbers: 
            <code title="Get double numbers" lang="VB.NET" source="UI_Dialog_09.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Input.GetInteger(System.String,System.String,System.String,System.Int32)">
            <summary>Display a simple dialog allowing the user to input an integer number</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed to the left of the numerical entry field</param>
            <param name="initialValue">The initial value to be shown in the numerical entry field. Optional. Default = 0</param>
            <returns>The integer the user entered</returns>
            <example> 
            This example shows how to get an integer: 
            <code title="Get an integer" lang="VB.NET" source="UI_Dialog_03.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.UI.Input.GetIntegers(System.String,System.String[],System.Int32[])">
            <summary>Display a simple dialog allowing the user to input integer numbers</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="labels">Labels displayed to the left of the numerical entry fields</param>
            <param name="initialValues">The initial values to be displayed in the numerical entry fields</param>
            <returns>The integer numbers the user entered</returns>
            <example> 
            This example shows how to get integer numbers: 
            <code title="Get integer numbers" lang="VB.NET" source="UI_Dialog_10.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Input.GetPlane(System.String,System.String)">
            <summary>Display a simple dialog allowing the user to specify a plane</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed to the left of the plane specified field</param>
            <returns>Structure containing the specified plane</returns>
            <example> 
            This example shows how to specify a plane: 
            <code title="Specify a plane" lang="VB.NET" source="UI_Dialog_08.vb">
            </code> 
            </example>      
        </member>
        <member name="T:Snap.UI.Input.PlaneResult">
            <summary>Represents the result returned when the user specifies a plane</summary>
            <remarks>
            <para>
            A PlaneResult is returned when calling the 
            <see cref= "M:Snap.UI.Input.GetPlane(System.String,System.String)">Snap.UI.GetPlane</see> function.
            </para>
            </remarks>
            <seealso cref= "M:Snap.UI.Input.GetPlane(System.String,System.String)">Snap.UI.GetPlane</seealso> function.
        </member>
        <member name="P:Snap.UI.Input.PlaneResult.Response">
            <summary>The response</summary>
        </member>
        <member name="P:Snap.UI.Input.PlaneResult.Plane">
            <summary>The plane the user specified</summary>
        </member>
        <member name="M:Snap.UI.Input.GetPosition(System.String,System.String)">
            <summary>Display a simple dialog allowing the user to specify a position</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed to the left of the position specified field</param>
            <returns>Structure containing the specified position</returns>
            <example> 
            This example shows how to specify a position: 
            <code title="Specify a position" lang="VB.NET" source="UI_Dialog_05.vb">
            </code> 
            </example>      
        </member>
        <member name="T:Snap.UI.Input.PositionResult">
            <summary>Represents the result returned when the user species a point (position)</summary> 
            <remarks>
            <para>
            A PositionResult is returned when calling the 
            <see cref= "M:Snap.UI.Input.GetPosition(System.String,System.String)">Snap.UI.GetPosition</see> function.
            </para>
            </remarks>
            <seealso cref= "M:Snap.UI.Input.GetPosition(System.String,System.String)">Snap.UI.GetPosition</seealso> function.
        </member>
        <member name="P:Snap.UI.Input.PositionResult.Response">
            <summary>The response</summary>
        </member>
        <member name="P:Snap.UI.Input.PositionResult.Position">
            <summary>The position specified by the user</summary>
        </member>
        <member name="M:Snap.UI.Input.GetString(System.String,System.String,System.String,System.String)">
            <summary>Display a simple dialog allowing the user to input a string</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed to the left of the string entry field</param>
            <param name="initialValue">The initial value to be displayed in the input field</param>
            <returns>The string the user entered</returns>
            <example> 
            This example shows how to get a string: 
            <code title="Get a string" lang="VB.NET" source="UI_Dialog_04.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.UI.Input.GetStrings(System.String,System.String[],System.String[])">
            <summary>Display a simple dialog allowing the user to input a string array</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="labels">Labels displayed to the left of the string entry fields</param>
            <param name="initialValues">The initial value to be displayed in the input fields</param>
            <returns>The string array the user entered</returns>
            <example> 
            This example shows how to get a string array: 
            <code title="Get a string array" lang="VB.NET" source="UI_Dialog_11.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Input.GetVector(System.String,System.String)">
            <summary>Display a simple dialog allowing the user to specify a vector</summary>
            <param name="title">Text shown in the title bar of the dialog window</param>
            <param name="label">Label displayed to the left of the vector specified field</param>
            <returns>Structure containing the specified vector</returns>
            <example> 
            This example shows how to specify a vector: 
            <code title="Specify a vector" lang="VB.NET" source="UI_Dialog_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="T:Snap.UI.Input.VectorResult">
            <summary>Represents the result returned when the user species a vector</summary> 
            <remarks>
            <para>
            A VectorResult is returned when calling the 
            <see cref= "M:Snap.UI.Input.GetVector(System.String,System.String)">Snap.UI.GetVector</see> function.
            </para>
            </remarks>
            <seealso cref= "M:Snap.UI.Input.GetVector(System.String,System.String)">Snap.UI.GetVector</seealso> function.
        </member>
        <member name="P:Snap.UI.Input.VectorResult.Response">
            <summary>The response</summary>
        </member>
        <member name="P:Snap.UI.Input.VectorResult.Point">
            <summary>The origin point of the vector the user specified</summary>
        </member>
        <member name="P:Snap.UI.Input.VectorResult.Direction">
            <summary>The direction of the vector the user specified</summary>
        </member>
        <member name="T:Snap.UI.Response">
            <summary>The user response for the selection operation.</summary>
        </member>
        <member name="F:Snap.UI.Response.Back">
            <summary>User clicked Back button</summary>
        </member>
        <member name="F:Snap.UI.Response.Cancel">
            <summary>User clicked Cancel button</summary>
        </member>
        <member name="F:Snap.UI.Response.Ok">
            <summary>User clicked Ok button</summary>
        </member>
        <member name="T:Snap.UI.WinForm">
            <summary>A Windows form for use in NX/Open applications</summary>   
        </member>
        <member name="M:Snap.UI.WinForm.#ctor">
            <summary>Constructs a new NX WinForm</summary>      
        </member>
        <member name="M:Snap.UI.WinForm.SetApplicationIcon(System.Windows.Forms.Form)">
            <summary>Sets the icon for the supplied form the same as the icon used by NX</summary>
            <param name="form">A form object with type System.Windows.Forms.Form</param>      
        </member>
        <member name="M:Snap.UI.WinForm.ReparentForm(System.Windows.Forms.Form)">
            <summary>Set the parent for the form window of the SNAP application.</summary>
            <param name="form">A form object with type System.Windows.Forms.Form</param>      
        </member>
        <member name="T:Snap.UI.Selection">
            <summary> Provides tools related to selection of NX objects </summary>
            <remarks>
            <para>
            For an introduction to the ideas related to selection, please see Chapter 15
            of the SNAP "Getting Started" guide.
            </para>
            <para>
            To display a dialog that lets the user select objects, the basic steps are:
            <list type = "bullet">
            <item>Use the <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog;</item>
            <item>Use the <see cref="O:Snap.UI.Selection.Dialog.SetFilter">SetFilter</see> functions to set the selection filter, which
            will determine what types of objects are eligible for selection;</item>
            <item>Use the <see cref="M:Snap.UI.Selection.Dialog.Show">Show</see> function to display the dialog;</item>
            <item>Use the <see cref="T:Snap.UI.Selection.Result">Result</see> object returned by the Show function to find
            out which objects the user selected, and then do something useful.</item>   
            </list>
            </para>
            </remarks>
            <example> 
            This example shows how to use the functions in the Snap.UI.Selection class:
            <code title="Using Snap.UI.Selection functions: " lang="VB.NET" source="UI_Selection_02.vb"> 
            </code> 
            </example>   
        </member>
        <member name="M:Snap.UI.Selection.SelectObject(System.String)">
            <summary>Creates a selection dialog</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            After creating the dialog, use the <see cref="O:Snap.UI.Selection.Dialog.SetFilter">SetFilter</see> functions 
            to set the selection filter, which will determine what types of objects are eligible for selection.
            </para>
            </remarks>
            <example> 
            This example shows how to select a single object:
            <code title="Select a single object: " lang="VB.NET" source="UI_Selection_01.vb"> 
            </code> 
            </example>      
        </member>
        <member name="M:Snap.UI.Selection.SelectObject(System.String,Snap.NX.ObjectTypes.TypeCombo[])">
            <summary>Creates a selection dialog that allows selection of a single object</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="combos">Array of TypeCombos indicating which types of objects are eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            then use the <see cref="O:Snap.UI.Selection.Dialog.SetFilter">SetFilter</see> functions to set the selection filter.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObject(System.String,Snap.NX.ObjectTypes.Type[])">
            <summary>Creates a selection dialog that allows selection of a single object</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="types">Array of object types that are to be eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            then use the <see cref="O:Snap.UI.Selection.Dialog.SetFilter">SetFilter</see> functions to set the selection filter.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObject(System.String,Snap.NX.ObjectTypes.Type,Snap.NX.ObjectTypes.SubType)">
            <summary>Creates a selection dialog that allows selection of a single object</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="type">Object type that is to be eligible for selection</param>
            <param name="subtype">Object subtype that is to be eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            then use the <see cref="O:Snap.UI.Selection.Dialog.SetFilter">SetFilter</see> functions to set the selection filter.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObject(System.String,NXOpen.Selection.MaskTriple[])">
            <summary>Creates a selection dialog that allows selection of a single object</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="maskTripleArray">Mask indicating which types of objects are eligible for selection</param>
            <returns>The selection dialog</returns>      
        </member>
        <member name="M:Snap.UI.Selection.SelectObjects(System.String)">
            <summary>Creates a selection dialog that allows selection of multiple objects of any type</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            set the <see cref="P:Snap.UI.Selection.Dialog.AllowMultiple">AllowMultiple</see> property to allow the user
            to select several objects.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObjects(System.String,Snap.NX.ObjectTypes.TypeCombo[])">
            <summary>Creates a selection dialog that allows selection of multiple objects of specified types</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="combos">Array of TypeCombos indicating which types of objects are eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            set the <see cref="P:Snap.UI.Selection.Dialog.AllowMultiple">AllowMultiple</see> property to allow the user
            to select several objects.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObjects(System.String,Snap.NX.ObjectTypes.Type[])">
            <summary>Creates a selection dialog that allows selection of multiple objects of specified types</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="types">Array of object types that are to be eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            set the <see cref="P:Snap.UI.Selection.Dialog.AllowMultiple">AllowMultiple</see> property to allow the user
            to select several objects.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObjects(System.String,Snap.NX.ObjectTypes.Type,Snap.NX.ObjectTypes.SubType)">
            <summary>Creates a selection dialog that allows selection of multiple objects of specified types</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="type">Object type that is to be eligible for selection</param>
            <param name="subtype">Object subtype that is to be eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and 
            set the <see cref="P:Snap.UI.Selection.Dialog.AllowMultiple">AllowMultiple</see> property to allow the user
            to select several objects.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectObjects(System.String,NXOpen.Selection.MaskTriple[])">
            <summary>Creates a selection dialog that allows selection of multiple objects of specified types</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="maskTripleArray">Mask indicating which types of objects are eligible for selection</param>
            <returns>The selection dialog</returns>      
        </member>
        <member name="M:Snap.UI.Selection.SelectICurve(System.String)">
            <summary>Creates a selection dialog that allows selection of a single ICurve (curve or edge)</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and then
            use the <see cref="O:Snap.UI.Selection.Dialog.SetCurveFilter">SetCurveFilter</see> functions
            to indicate which types of curves should be eligible for selection.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectICurve(System.String,Snap.NX.ObjectTypes.Type[])">
            <summary>Creates a selection dialog that allows selection of a single ICurve (curve or edge)</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="types">Array of edge/curve types that are to be eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and then
            use the <see cref="O:Snap.UI.Selection.Dialog.SetCurveFilter">SetCurveFilter</see> functions
            to indicate which types of curves should be eligible for selection.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectFace(System.String)">
            <summary>Creates a selection dialog that allows selection of a single face (of any type)</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and then
            use the <see cref="O:Snap.UI.Selection.Dialog.SetFaceFilter">SetFaceFilter</see> functions
            to indicate which types of faces should be eligible for selection.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Selection.SelectFace(System.String,Snap.NX.ObjectTypes.SubType[])">
            <summary>Creates a selection dialog that allows selection of a single face of a specified type</summary>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="faceTypes">Array of face types that are to be eligible for selection</param>
            <returns>The selection dialog</returns>
            <remarks>
            <para>
            This function is obsolete. 
            </para>
            <para>
            Please use the 
            <see cref="M:Snap.UI.Selection.SelectObject(System.String)">SelectObject</see> function to create the dialog, and then
            use the <see cref="O:Snap.UI.Selection.Dialog.SetFaceFilter">SetFaceFilter</see> functions
            to indicate which types of faces should be eligible for selection.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.UI.Selection.Result">
            <summary>The result returned from showing a selection dialog</summary>
        </member>
        <member name="P:Snap.UI.Selection.Result.Objects">
            <summary>The selected objects (possibly zero or one)</summary>
        </member>
        <member name="P:Snap.UI.Selection.Result.Object">
            <summary>The first selected object. Always equal to Objects[0]</summary>
        </member>
        <member name="P:Snap.UI.Selection.Result.Response">
             <summary>The user's response</summary>
            <remarks>
             The possible values of the response are:
             <list type = "bullet">
             <item>Back -- the user clicked the "Back" button</item>
             <item>Cancel -- the user clicked the "Cancel" button</item>
             <item>Ok -- the user clicked the "OK" button</item>
             <item>ObjectSelectedByName -- the user selected an object by entering its name</item>
             <item>ObjectSelected -- the user selected an object using the mouse</item>
             </list>
             </remarks>
        </member>
        <member name="P:Snap.UI.Selection.Result.CursorRay">
            <summary>The cursor ray</summary>
            <remarks>
            <para>
            You can think of selection as a process of shooting an infinite line (the cursor ray) at your model.
            The object that gets selected is one that this ray hits, or the one that's closest to the ray.
            Sometimes, rather than just knowing which object was selected, you want to know where
            on the object the user clicked. You can figure this out by using the cursor ray. For example,
            you can find out where the ray intersects the model, or you can find out which end of a curve
            is closest to the ray. An example in chapter&#160;15 of the SNAP "Getting Started" guide gives
            the details.
            </para>
            <para>In some situations (like selecting by rectangle, selecting by name, or selecting
            multiple objects) the Selection.Result returned will have its CursorRay set to <c>Nothing</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Selection.Result.PickPoint">
            <summary>The cursor position at selected object</summary>
            <remarks>
            <para>
            The "pick point" is a point on the selected object. It is either
            the place where the cursor ray pierces the object, or the closest
            point of the object to the cursor ray. Please see chapter&#160;15 of the 
            SNAP Getting Started Guide for an explanation of the cursor ray.
            </para>
            <para>
            If the user selects multiple objects, the PickPoint property
            will have the value <c>Nothing</c>.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.UI.Selection.Dialog">
            <summary> Represents a selection dialog, which can be displayed to allow the user to select objects </summary>
            <remarks>
            <para>
            To create a selection dialog, use the 
            <see cref="O:Snap.UI.Selection.SelectObject">SelectObject</see> functions.  
            </para>
            <para>
            If you want a selection block on a dialog, rather than a standalone selection dialog, 
            please use a
            <see cref= "T:Snap.UI.Block.SelectObject">Snap.UI.Block.SelectObject</see> object.
            </para>
            </remarks>
            <seealso cref= "T:Snap.UI.Block.SelectObject">Snap.UI.Block.SelectObject</seealso>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.Show">
            <summary>Displays the dialog and gets a result</summary>
            <returns>The Selection.Result</returns>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.AddFeatures(NXOpen.Selection.MaskTriple[])">
            <summary>Constructs an augmented mask array by adding a "features" entry</summary>
            <param name="inMask">The original mask array (which might be null)</param>
            <returns>The augmented mask array (with features appended)</returns>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.Title">
            <summary> Title to be displayed on the selection dialog</summary>
            <remarks>If you do not specify a title, the default is "Select Object"</remarks>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.Cue">
            <summary>Message to be displayed in the Cue line during selection</summary>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.Scope">
            <summary> The scope of the selection (work part, or assembly, etc.)</summary>
            <remarks>If you do not specify a scope, the default is "AnyInAssembly"</remarks>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.KeepHighlighted">
            <summary>If true, the selected objects are kept highlighted after selection</summary>
            <remarks>If you do not specify a value for this option, the default is "false"</remarks>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.MaskTripleArray">
            <summary> An array of mask triples indicating which types of objects will be selectable</summary>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.IncludeFeatures">
            <summary>If true, features will be eligible for selection</summary>
            <remarks>If you do not specify a value for this option, the default is "false"</remarks>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.AllowMultiple">
            <summary>If true, selection of multiple objects will be allowed</summary>
            <example> 
            This example shows how to allow selection of multiple objects:
            <code title="Selecting multiple points: " lang="VB.NET" source="UI_Selection_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.UI.Selection.Dialog.Result">
            <summary>The result, after displaying the dialog and getting user input</summary>
        </member>
        <member name="T:Snap.UI.Selection.Dialog.SelectionScope">
            <summary>Indicates the scope for selecting objects.</summary>
        </member>
        <member name="F:Snap.UI.Selection.Dialog.SelectionScope.UseDefault">
            <summary>Use the default selection scope</summary>
        </member>
        <member name="F:Snap.UI.Selection.Dialog.SelectionScope.WorkPart">
            <summary>Use the work part</summary>
        </member>
        <member name="F:Snap.UI.Selection.Dialog.SelectionScope.AnyInAssembly">
            <summary>Use any occurrence in the assembly</summary>
        </member>
        <member name="F:Snap.UI.Selection.Dialog.SelectionScope.WorkPartAndOccurrence">
            <summary>Use the work part or any occurrence</summary>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetFilter(Snap.NX.ObjectTypes.TypeCombo[])">
            <summary>Sets the selection filter using TypeCombo objects</summary>
            <param name="combos">TypeCombos indicating which types of objects are eligible for selection</param>
            <example> 
            This example shows how to set the selection filter by using type combos:
            <code title="Selecting holes: " lang="VB.NET" source="UI_Selection_03.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetFilter(Snap.NX.ObjectTypes.Type[])">
            <summary>Sets the selection filter using given object types</summary>
            <param name="types">Object types that are to be eligible for selection</param>
            <example> 
            This example shows how to set the selection filter with given types:
            <code title="Selecting bodies or datum planes: " lang="VB.NET" source="UI_Selection_09.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetFilter(Snap.NX.ObjectTypes.Type,Snap.NX.ObjectTypes.SubType)">
            <summary>Sets the selection filter using a given type and subtype</summary>
            <param name="type">Object type that is to be eligible for selection</param>
            <param name="subtype">Object subtype that is to be eligible for selection</param>
            <example> 
            This example shows how to set the selection filter with a given type and subtype:
            <code title="Selecting notes: " lang="VB.NET" source="UI_Selection_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetCurveFilter">
            <summary>Sets the filter to allow selection of curves or edges</summary>
            <example> 
            This example shows how to select any curve or edge:
            <code title="Selecting any curve or edge: " lang="VB.NET" source="UI_Selection_11.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetCurveFilter(Snap.NX.ObjectTypes.Type[])">
            <summary>Sets the selection filter using an array of edge/curve types</summary>
            <param name="types">Array of edge/curve types that are to be eligible for selection</param>
            <remarks> 
            <para>
            A single type code is used to refer to both curves and edges. So, for example, to make circular curves and
            circular edges eligible for selection, pass NX.ObjectTypes.Types.Circle as the argument to this function.
            </para>
            </remarks>
            <example> 
            This example shows how to set the selection filter using given curve types:
            <code title="Selecting a circular curve or edge: " lang="VB.NET" source="UI_Selection_12.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetFaceFilter">
            <summary>Sets the filter to allow selection of faces (of any type)</summary>
            <example> 
            This example shows how to select faces of any type:
            <code title="Selecting any face: " lang="VB.NET" source="UI_Selection_13.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.SetFaceFilter(Snap.NX.ObjectTypes.SubType[])">
            <summary>Sets the selection filter using an array of face types</summary>
            <param name="faceTypes">Face types that are to be eligible for selection</param>
            <example> 
            This example shows how to set the selection filter with given face types:
            <code title="Selecting cylindrical or conical faces: " lang="VB.NET" source="UI_Selection_07.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.#ctor(System.Boolean,System.String)">
            <summary>Creates a Selection dialog</summary>
            <param name="allowMultiple">If true, selection of multiple objects is allowed</param>
            <param name="cue">Prompt to be displayed in Cue line</param>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.#ctor(System.Boolean,System.String,NXOpen.Selection.MaskTriple[])">
            <summary>Creates a Selection dialog</summary>
            <param name="allowMultiple">If true, selection of multiple objects is allowed</param>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="maskTripleArray">Mask indicating which types of objects are eligible for selection</param>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.#ctor(System.Boolean,System.String,Snap.NX.ObjectTypes.TypeCombo[])">
            <summary>Creates a Selection dialog</summary>
            <param name="allowMultiple">If true, selection of multiple objects is allowed</param>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="combos">Array of TypeCombos indicating which types of objects are eligible for selection</param>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.#ctor(System.Boolean,System.String,Snap.NX.ObjectTypes.Type[])">
            <summary>Creates a Selection dialog</summary>
            <param name="allowMultiple">If true, selection of multiple objects is allowed</param>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="types">Array of object types that are to be eligible for selection</param>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.#ctor(System.Boolean,System.String,Snap.NX.ObjectTypes.Type,Snap.NX.ObjectTypes.SubType)">
            <summary>Creates a Selection dialog</summary>
            <param name="allowMultiple">If true, selection of multiple objects is allowed</param>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="type">Object type that is to be eligible for selection</param>
            <param name="subtype">Object subtype that is to be eligible for selection</param>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.#ctor(System.String,System.Boolean,Snap.NX.ObjectTypes.Type[])">
            <summary>Creates a Selection dialog ( Only support selection of icurves)</summary>
            <param name="allowMultiple">If true, selection of multiple objects is allowed</param>
            <param name="cue">Prompt to be displayed in Cue line</param>
            <param name="types">Array of object types that are to be eligible for selection</param>
        </member>
        <member name="M:Snap.UI.Selection.Dialog.GetCursorRay(System.String,Snap.Position)">
            <summary>Gets the cursor ray (ray "beneath" the cursor in the view of selection)</summary>
            <param name="viewName">Name of view in which selection occurred</param>
            <param name="cursor">Cursor position returned from selection procedure</param>
            <returns>The ray</returns>
        </member>
        <member name="T:Snap.UI.MaskTriple">
            <summary>Represents a triplet of integers used to perform object type filtering in NX/Open selection functions</summary>
        </member>
        <member name="M:Snap.UI.MaskTriple.BuildFromTypeCombos(Snap.NX.ObjectTypes.TypeCombo[])">
            <summary>Constructs an array of Mask Triples from a given array of NX.ObjectTypes.TypeCombos</summary>
            <param name="combos">The given NX.ObjectTypes.TypeCombo array</param>
            <returns>The array of corresponding Mask Triple</returns>
        </member>
        <member name="M:Snap.UI.MaskTriple.BuildFromTypeCombo(Snap.NX.ObjectTypes.TypeCombo)">
            <summary>Constructs a Mask Triple from a given NX.ObjectTypes.TypeCombo</summary>
            <param name="combo">The given NX.ObjectTypes.TypeCombo</param>
            <returns>The corresponding Mask Triple</returns>       
        </member>
        <member name="M:Snap.UI.MaskTriple.BuildFromType(Snap.NX.ObjectTypes.Type)">
            <summary>Constructs a Mask Triple from a given NX.ObjectTypes.Type</summary>
            <param name="type">The given NX.ObjectTypes.Type</param>
            <returns>The corresponding Mask Triple</returns>       
        </member>
        <member name="M:Snap.UI.MaskTriple.BuildFromICurveType(Snap.NX.ObjectTypes.Type)">
            <summary>Construct a mask triple array for selecting curves or edges</summary>
            <param name="curveType">Type to be selected (a curve type)</param>
            <returns>Mask triple array describing curves and edges of the specified type</returns>
        </member>
        <member name="M:Snap.UI.MaskTriple.BuildFromICurveTypes(Snap.NX.ObjectTypes.Type[])">
            <summary>Construct a mask triple array for selecting curves or edges</summary>
            <param name="curveTypes">Type to be selected (a curve type)</param>
            <returns>Mask triple array describing curves and edges of the specified types</returns>
        </member>
        <member name="T:Snap.UI.Block.NamespaceDoc">
            <summary>Contains classes for various types of dialog blocks</summary>
        </member>
        <member name="T:Snap.UI.Block.General">
            <summary>
            Abstract class to serve as the base class for other block (interchangeable with <see cref="T:NXOpen.BlockStyler.UIBlock">NXOpen.BlockStyler.UIBlock</see>)
            </summary>      
        </member>
        <member name="F:Snap.UI.Block.General.PropertyDictionary">
            <summary>The property dictionary for this block</summary>
            <remarks>
            <para>
            The dictionary serves as a temporary storage area for block properties, during the time
            period before the "real" NX/Open block exists. Once the NX/Open block does exist,
            properties are copied into it from the dictionary.
            Within the dictionary, the keys are {Type, Name} pairs. We call this pair a "PropertyKey".
              -- The "Type" of a property indicates which NX/Open function is used to access it
              -- The "Name" is the magic string that's passed to the NX/Open access function
            Note that the Name alone is not enough to identify the property. For example, an
            Enumeration block has three properties that all have the name "Value". The string "Value"
            gets passed to three different access functions to get three different property values.
            Note that examining dictionary contents in the Visual Studio debugger is complicated. You use:
            dictionary object -> Keys -> Non-Public members -> dictionary -> Non-Public members -> entries -> [0]
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.General.NXOpenBlock">
            <summary>The corresponding NXOpen.BlockStyler.NXOpenBlock object</summary>
        </member>
        <member name="F:Snap.UI.Block.General.privateName">
            <summary>
            A cached name, needed in situations where neither the Property Dictionary nor the associated 
            NXOpen block exists. This can happen in initialize_cb following an "Apply", for example. 
            This name is crucially important, because we use it to find the associated NXOpen block (by calling FindBlock).
            </summary>
        </member>
        <member name="P:Snap.UI.Block.General.Name">
            <summary>The name of the block. Sometimes called the "Block ID".</summary>
        </member>
        <member name="P:Snap.UI.Block.General.Show">
            <summary>If true, indicates that this block should be displayed in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.General.Type">
            <summary>The type of the block</summary> 
        </member>
        <member name="M:Snap.UI.Block.General.#ctor(NXOpen.BlockStyler.UIBlock)">
            <summary> Constructor, given an NXOpen.BlockStyler.UIBlock object</summary>
            <param name="uiBlock">An NXOpen.BlockStyler.UIBlock object</param>         
        </member>
        <member name="M:Snap.UI.Block.General.#ctor">
            <summary>Construct a general block</summary>
        </member>
        <member name="M:Snap.UI.Block.General.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type General in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="blockName">The name (Block ID) assigned to the General block</param>
            <returns>The Toggle object</returns>
        </member>
        <member name="M:Snap.UI.Block.General.CopyFromDictionary(Snap.UI.BlockForm)">
            <summary>Copies property data from this block's Property Dictionary into fields of the NX/Open block</summary>
            <remarks>
            <para>
            This can only be done after the NX/Open block comes into existence, of course.
            </para>
            </remarks> 
        </member>
        <member name="M:Snap.UI.Block.General.BlockToDictionary(Snap.UI.BlockForm)">
            <summary>Copy property data back from the NXOpen block to the block's Property Dictionary</summary>
            <remarks>
            <para>
            This copying is done when the user clicks Apply, to capture any changes that the user
            made in the dialog. In fact, we create a new dictionary object and then replace the old one.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.General.CreateUiBlock(NXOpen.BlockStyler.UIBlock)">
            <summary>
            Creates a Snap.UI.Block.General object of the most specific type possible
            </summary>
            <remarks>
            <para>
            The returned block's static type is still Snap.UI.Block.General, but, where
            possible, the Snap.UI.Block.General variable now contains a block object whose run-time type
            is more specific, so that it can be successfully cast to that more specific type
            by the caller.
            </para>
            <para>
            This function should be used instead of the UI.Block constructors, to guarantee
            that properly downcast objects are created whenever possible.
            </para>
            </remarks>
            <param name="uiBlock">uiBlock</param>The input NXOpen.BlockStyler.UIBlock
            <returns>A Snap.UI.Block.General object that has the most specific type possible</returns>
        </member>
        <member name="M:Snap.UI.Block.General.GetSelectedObjects">
            <summary>Get selected objects (from dictionary or real block)</summary>
            <returns>An array of NX.NXObject objects</returns>
        </member>
        <member name="M:Snap.UI.Block.General.SetSelectedObjects(Snap.NX.NXObject[])">
            <summary>Set selected objects (in dictionary or real block)</summary>
        </member>
        <member name="M:Snap.UI.Block.General.op_Equality(Snap.UI.Block.General,Snap.UI.Block.General)">
            <summary>If true, indicates that the given two block are the same block</summary>
            <param name="block1">First Snap.UI.Block.General object</param>
            <param name="block2">Second Snap.UI.Block.General object</param>
            <returns>A <c>Boolean</c> object</returns>
        </member>
        <member name="M:Snap.UI.Block.General.op_Inequality(Snap.UI.Block.General,Snap.UI.Block.General)">
            <summary>If true, indicates that the given two block are not the same block</summary>
            <param name="block1">First Snap.UI.Block.General object</param>
            <param name="block2">Second Snap.UI.Block.General object</param>
            <returns>A <c>Boolean</c> object</returns>
        </member>
        <member name="M:Snap.UI.Block.General.Equals(System.Object)">
            <summary>Determines whether the specified System.Object is equal to the current System.Object.</summary>
            <param name="obj">The System.Object to compare with the current System.Object.</param>
            <returns>True if the specified System.Object is equal to the current System.Object; otherwise, false.</returns>
        </member>
        <member name="M:Snap.UI.Block.General.GetHashCode">
            <summary>Returns the hash code for block name</summary>
            <returns>A signed integer hash code</returns>
        </member>
        <member name="T:Snap.UI.Block.LabelBlock">
            <summary>A textual label and/or a bitmap used to explain an item on the dialog</summary>      
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.HighQualityBitmap">
            <summary>If true, indicates that a high-quality (24-bit) version of the Bitmap should be displayed</summary>
            <remarks>
            <para>
            This property is relevant only when the 
            <see cref= "P:Snap.UI.Block.LabelBlock.Bitmap">Bitmap</see> property uses the name of a 
            built-in NX icon bitmap. If you use a bitmap file, instead, then this property has no effect.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.LabelBlock.Bitmap">Bitmap</seealso> 
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LabelBlock.WordWrap">
            <summary>If true, indicates that the Label string should be wrapped</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.LabelBlock.#ctor">
            <summary>Construct a LabelBlock</summary>
        </member>
        <member name="M:Snap.UI.Block.LabelBlock.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type LabelBlock in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The LabelBlock block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Toggle">
            <summary>Allows the user to input a binary toggle value (yes/no, on/off, or true/false)</summary>      
        </member>
        <member name="P:Snap.UI.Block.Toggle.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Toggle.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Toggle.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Toggle.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Toggle.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.Toggle.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, nor in
            the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Toggle.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Toggle.Value">
            <summary>If true, indicates that the toggle is "checked"</summary>
        </member>
        <member name="M:Snap.UI.Block.Toggle.#ctor">
            <summary>Construct a Toggle (check box) block</summary>
        </member>
        <member name="M:Snap.UI.Block.Toggle.#ctor(System.String,System.Boolean)">
            <summary>Construct a Toggle (check box) block</summary>
            <param name="label">Label displayed to the right of the check box</param>
            <param name="value">If true, the toggle is checked</param>
        </member>
        <member name="M:Snap.UI.Block.Toggle.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Toggle in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Toggle block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Separator">
            <summary>A separator (horizontal line) used to delineate items on the dialog</summary>      
        </member>
        <member name="M:Snap.UI.Block.Separator.#ctor">
            <summary>Creates a new block of type Separator with default configuration</summary>
        </member>
        <member name="M:Snap.UI.Block.Separator.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Separator in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Separator block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Enumeration">
            <summary>Allows the user to choose from an enumerated set of options</summary>      
            <example> 
            This example shows how to use an Enumeration block: 
            <code title="A dialog with an Enumeration block" lang="VB.NET" source="UI_Block_SpokesForm_01.vb"> 
            </code> 
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/Spokes.PNG"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.HighQualityBitmap">
            <summary>If true, indicates that a high-quality (24-bit) version of the Bitmap should be displayed</summary>
            <remarks>
            <para>
            This property is relevant only when the 
            <see cref= "P:Snap.UI.Block.Enumeration.Bitmaps">Bitmaps</see> property uses names of  
            built-in NX icon bitmaps. If you use bitmap files, instead, then this property has no effect.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.Enumeration.Bitmaps">Bitmaps</seealso>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.LabelVisibility">
            <summary>If true, indicates that the Label string should be displayed</summary>
            <remarks>The block becomes wide (fills the entire width of the dialog) when this property is false
            <para>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.AllowShortcuts">
            <summary>If true, indicates that the enumeration options can be displayed as shortcuts</summary>
            <remarks>
            <para>
             Setting this property to "true" is useful only when the property PresentationStyle is set to "Option Menu", 
             IconsOnly is false, and the number of Bitmaps is equal to the number of enumeration options. 
             Shortcuts are not permitted when there are blank or duplicate icons
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks> 
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Layout">
            <summary>Indicates whether Radio Box choices should be arranged horizontally or vertically</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.IconsOnly">
            <summary>If true, indicates that the enumeration options should be displayed as icons only</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.BorderVisibility">
            <summary>If true, indicates that the border of the Radio Box will be visible</summary>
            <remarks>
            <para>
            Useful only when the property PresentationStyle is set to Radio Box.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.PresentationStyle">
            <summary>The presentation style: drop down option menu or radio buttons</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.NumberOfColumns">
            <summary>The number of columns used in the layout of the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Value">
            <summary>The index of the selected item (zero-based) -- same as "SelectedIndex"</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.SelectedIndex">
            <summary>The index of the selected item (zero-based) -- same as "Value"</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.SelectedItem">
            <summary>The selected item (as a string)</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Items">
            <summary>The list of items the user chooses from (as strings)</summary>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.Bitmaps">
            <summary>Names of bitmap images used to label this block</summary>
            <remarks>
            <para>
            Each name may be either the pathname of a bitmap file or the name of a built-in
            NX icon bitmap. If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Enumeration.InitialShortcuts">
            <summary>The set of shortcuts that are displayed when the dialog is initially displayed</summary>
            <remarks>
            <para>
            This property makes sense only if the enumeration options are shown as shortcuts and the number of 
            enumeration options is greater than the maximum number of shortcuts.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.Enumeration.#ctor">
            <summary>Construct an Enumeration block</summary>
        </member>
        <member name="M:Snap.UI.Block.Enumeration.#ctor(System.String,Snap.UI.Block.EnumPresentationStyle)">
            <summary>Construct an Enumeration block</summary>
            <param name="label">Label displayed next to the list of choices</param>
            <param name="style">Presentation style. Optional. Default = Snap.UI.Block.EnumPresentationStyle.OptionMenu</param>
        </member>
        <member name="M:Snap.UI.Block.Enumeration.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Enumeration in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Enumeration block object</returns>
        </member>
        <member name="T:Snap.UI.Block.String">
            <summary>Allows the user to enter/edit a String</summary>
            <example> 
            This example shows how to use a String block: 
            <code title="A dialog with a String block" lang="VB.NET" source="UI_Block_AttributeEditor_01.vb"> 
            </code> 
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/AttributeEditor.png"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.String.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.String.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.String.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.String.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.String.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.Value">
            <summary>The string to be displayed/edited</summary>
            <remarks>
            <para>
            Fully general Unicode strings are supported if AllowInternationalTextInput is set to "true"
            (which it always should be).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.WideValue">
            <summary>The string to be displayed/edited (ASCII only)</summary>
            <remarks>
            <para>
            This property is available only when property "AllowInternationalTextInput" is true. 
            Also, at any instance either this property or "Value" is available for the block.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.PresentationStyle">
            <summary>The presentation style of the block (how it is displayed)</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.MaxTextLength">
            <summary>The maximum number of characters accepted as input (integer between 1 and 1024)</summary>
        </member>
        <member name="P:Snap.UI.Block.String.ListItems">
            <summary>Contains the list of items for list box</summary>
            <remarks>
            <para>
            ListItems property will be available only if property PresentationStyle is List or Combo.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.String.ReadOnly">
            <summary>If true, indicates that the string cannot be modified</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.String.AllowInternationalTextInput">
            <summary>If true, indicates that international text characters supported by NX will be allowed as input</summary>
            <remarks>
            <para>
            There is not really any point in setting this value to "false". For this reason, it may be removed and 
            set to "true" internally in some future version of SNAP. 
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks> 
        </member>
        <member name="P:Snap.UI.Block.String.IsSecret">
            <summary>if true, characters typed will be displayed as asterisks(*).</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.String.#ctor">
            <summary>Construct a String block</summary>
        </member>
        <member name="M:Snap.UI.Block.String.#ctor(System.String)">
            <summary>Construct a String block</summary>
            <param name="label">Label displayed to the left of the string entry field</param>
        </member>
        <member name="M:Snap.UI.Block.String.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type String in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The String block object</returns>
        </member>
        <member name="T:Snap.UI.Block.MultilineString">
            <summary>Allows the user to enter/edit a Multiline String (an array of strings)</summary>      
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Value">
            <summary>The array of strings (one per line)</summary>
            <remarks>
            <para>
            In these strings, the full Unicode character set is supported.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.ResizeHeightWithDialog">
            <summary>If true, indicates that this block will resize as the dialog is resized</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Height">
            <summary>The number of lines of text in the multi-line string</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.MinimumHeight">
            <summary>Specifies the minimum number of rows shown on the dialog as it is resized</summary>
            <remarks>
            <para>
            This property is valid only if ResizeHeightWithDialog is true. 
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.MaximumHeight">
            <summary>Specifies the maximum number of rows shown on the dialog as it is resized</summary>
            <remarks>
            <para>
            This property is valid only if ResizeHeightWithDialog is true 
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.Width">
            <summary>The width of the area in which the image will be displayed, in pixels</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.MultilineString.MaximumCharactersAccepted">
            <summary>The maximum number of characters accepted by the block (the entire string array)</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.MultilineString.#ctor">
            <summary>Construct a MultilineString block</summary>
        </member>
        <member name="M:Snap.UI.Block.MultilineString.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type MultilineString in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The MultilineString block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Button">
            <summary>Provides a button that the user can click to cause an action</summary>      
            <example> 
            This example shows how to use Button block: 
            <code title="A dialog with a Button block" lang="VB.NET" source="UI_Block_FacePainter_01.vb">
            </code>
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/FacePainter.PNG"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.Button.Label">
            <summary>The text to display on the button</summary>
        </member>
        <member name="P:Snap.UI.Block.Button.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Button.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Button.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Button.HighQualityBitmap">
            <summary>If true, indicates that a high-quality (24-bit) version of the Bitmap should be displayed</summary>
            <remarks>
            <para>
            This property is relevant only when the 
            <see cref= "P:Snap.UI.Block.Button.Bitmap">Bitmap</see> property uses the name of a 
            built-in NX icon bitmap. If you use a bitmap file, instead, then this property has no effect.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.Button.Bitmap">Bitmap</seealso>
        </member>
        <member name="P:Snap.UI.Block.Button.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Button.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Button.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.Button.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Button.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Button.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.Button.#ctor">
            <summary>Construct a Button block</summary>
        </member>
        <member name="M:Snap.UI.Block.Button.#ctor(System.String)">
            <summary>Construct a Button block</summary>
            <param name="label">Label displayed at the center of the button</param>
        </member>
        <member name="M:Snap.UI.Block.Button.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Button in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Button block object</returns>
        </member>
        <member name="T:Snap.UI.Block.ListBox">
            <summary>Allows the user to choose from items in a List Box</summary>
            <remarks>
            <para>
            Zero, one, or more items can be chosen. You can optionally display the following 
            buttons next to the list: Add, Remove, Up and Down.
            </para>
            </remarks>      
            <example> 
            This example shows how to use ListBox block: 
            <code title="A dialog with a ListBox block" lang="VB.NET" source="UI_Block_AttributeEditor_01.vb"> 
            </code> 
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/AttributeEditor.png"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.ListBox.Label">
            <summary>Explanatory text displayed above the block, if it begins a group</summary>
            <remarks>
            <para>
            If the block has <c>BeginGroup = False</c>, then this text is not displayed.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ListBox.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ListBox.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.SingleSelect">
            <summary>If true, indicates that only a single item can be selected from the list box</summary>
        </member>
        <member name="P:Snap.UI.Block.ListBox.ShowAddButton">
            <summary>If true, indicates that an "add" button should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.ShowDeleteButton">
            <summary>If true, indicates that a Delete button should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.ShowMoveUpDownButtons">
            <summary>If true, indicates that Up/Down buttons should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.ListItems">
            <summary>The list of items (strings) displayed in the list box</summary>
            <remarks>
            <para>
            Note that the user can modify the contents of the list by using the Add and Delete,
            and can also re-order the items.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.ResizeHeightWithDialog">
            <summary>If true, indicates that this block will resize as the dialog is resized</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.Height">
            <summary>The number of items shown in the List Box</summary>
            <remarks>
            <para>
            A value less than or equal to zero means that the default height will be used.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.MinimumHeight">
            <summary>Specifies the minimum number of rows shown on the dialog as it is resized</summary>
            <remarks>
            <para>
            This property is valid only if ResizeHeightWithDialog is true. 
            </para>
            <para>
            It can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.MaximumHeight">
            <summary>Specifies the maximum number of rows shown on the dialog as it is resized</summary>
            <remarks>
            <para>
            This property is valid only if ResizeHeightWithDialog is true. 
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.MaximumStringLength">
            <summary>The maximum number of characters per row/item</summary>
            <remarks>A value less than or equal to zero means that there is no maximum.</remarks>
        </member>
        <member name="P:Snap.UI.Block.ListBox.IsAddButtonSensitive">
            <summary>If true, indicates that the "Add" button is sensitive (not grayed out)</summary>
        </member>
        <member name="P:Snap.UI.Block.ListBox.IsDeleteButtonSensitive">
            <summary>If true, indicates that the "Delete" button is sensitive (not grayed out)</summary>
        </member>
        <member name="P:Snap.UI.Block.ListBox.SelectedItems">
            <summary>The indices of the selected items (zero-based)</summary>
            <remarks>
            <para>
            The indices are zero-based. So, if <c>SelectedItems = {0, 2, 3}</c>, this means that the
            user chose the first, third, and fourth items in the list box.
            </para>
            <para>
            Note that the user can modify the list of items by using the Add, Delete, and Up/Down
            buttons on the dialog. These indices refer to the current modified list, not the original one.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.ListBox.#ctor">
            <summary>Construct a ListBox block</summary>
        </member>
        <member name="M:Snap.UI.Block.ListBox.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type ListBox in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The ListBox block object</returns>
        </member>
        <member name="T:Snap.UI.Block.ColorPicker">
            <summary>Allows the user to specify colors (color indices, actually)</summary>      
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.NumberSelectable">
            <summary>The number of colors the user will be allowed to select</summary>
            <remarks>
            <para>
            The user can select several colors by holding down the Control key. This property determines
            how many colors can be selected.
            </para>
            <para>
            Note that this property and the <see cref= "P:Snap.UI.Block.ColorPicker.ColorIndices">ColorIndices</see>
            property are related. Specifically, <c>NumberSelectable</c> must be at least as large as the
            number of items in the <c>ColorIndices</c> array.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.ColorIndices">
            <summary>The indices of the selected colors</summary>
            <remarks>
            <para>
            Each color index is an integer in the range 1 to 216 (inclusive).
            </para>
            <para>
            To obtain the corresponding System.Drawing.Color, you can call the  
            <see cref= "M:Snap.Color.WindowsColor(System.Int32)">Snap.Color.WindowsColor</see> function.
            </para>
            </remarks> 
            <seealso cref= "M:Snap.Color.WindowsColor(System.Int32)">Snap.Color.WindowsColor</seealso>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.ColorIndex">
            <summary>The index of the selected color (when only one is selected)</summary>
            <remarks>
            <para>
            ColorIndex is identical to ColorIndices(0).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ColorPicker.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.ColorPicker.#ctor">
            <summary>Construct a ColorPicker block</summary>
        </member>
        <member name="M:Snap.UI.Block.ColorPicker.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type ColorPicker in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The ColorPicker block object</returns>
        </member>
        <member name="T:Snap.UI.Block.RGBColorPicker">
            <summary>Allows the user to specify an RGB Color</summary>
            <remarks>
            <para>
            The Color property is a System.Drawing.Color
            </para>
            </remarks>      
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.Color">
            <summary>The color (as a System.Drawing.Color)</summary>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RGBColorPicker.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.RGBColorPicker.#ctor">
            <summary>Construct an RGBColorPicker block</summary>
        </member>
        <member name="M:Snap.UI.Block.RGBColorPicker.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type RGBColorPicker in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The RGBColorPicker block object</returns>
        </member>
        <member name="T:Snap.UI.Block.DrawingArea">
            <summary>Provides a drawing area on the dialog in which images/objects can be displayed</summary>      
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.Height">
            <summary>The height of the area in which the image will be displayed, in pixels</summary>
            <remarks>
            <para>
            The easiest approach is to just set the Height and Width properties to zero, in which
            case their values will be derived from the dimensions of the image you use.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.Width">
            <summary>The width of the area in which the image will be displayed, in pixels</summary>
            <remarks>
            <para>
            The easiest approach is to just set the Height and Width properties to zero, in which
            case their values will be derived from the dimensions of the image you use.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DrawingArea.Image">
            <summary>The pathname of the image to be shown (a JPG, BMP, PNG, GIF or TIF file).</summary>
        </member>
        <member name="M:Snap.UI.Block.DrawingArea.#ctor">
            <summary>Construct a DrawingArea block</summary>
        </member>
        <member name="M:Snap.UI.Block.DrawingArea.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type DrawingArea in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The DrawingArea block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Integer">
            <summary>Allows the user to enter/edit an Integer</summary>      
            <example> 
            This example shows how to use an Integer block: 
            <code title="Dialog with an Integer block" lang="VB.NET" source="UI_Block_SpokesForm_01.vb"> 
            </code> 
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/Spokes.PNG"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.Integer.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.LabelVisibility">
            <summary>If true, indicates that the label of the block should be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.PresentationStyle">
            <summary>The presentation style of the block (how it is displayed)</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.PageIncrement">
            <summary>The increment/decrement when the user presses the Page Up or Page Down keys on the keyboard</summary> 
            <remarks>Only available when PresentationStyle  is set to Scale or ScaleKeyin</remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.LineIncrement">
            <summary>The increment/decrement when the user presses the arrow keys on the keyboard</summary> 
            <remarks>Only available when PresentationStyle  is set to Scale or ScaleKeyin</remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.ShowScaleValue">
            <summary>If true, indicates that the value determined by the scale (slider) should be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.ScaleLimits">
            <summary>If true, indicates that the scale max and min labels should be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.ScaleMinLimitLabel">
            <summary>The label indicating the minimum scale limit</summary>
            <remarks>
            <para>
            Default is the value specified in MinimumValue property.  
            The label is only shown if ScaleLimits property is set to True.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.ScaleMaxLimitLabel">
            <summary>The label indicating the maximum scale limit</summary>
            <remarks>
            <para>
            Default is the value specified in MaximumValue property.  
            The label is only shown if ScaleLimits property is set to True.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.AdaptiveScaleLimits">
            <summary>If true, indicates that the scale should be adaptive</summary>
            <remarks>
            <para>
            If the scale is adaptive, its limits adjust to suitably bracket the user's
            current input value, which makes the scale much more useful.
            </para>
            <para>
            The scale can be adaptive when NumberPresentationStyle is equal to
            either Scale or ScaleKeyIn.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.Increment">
            <summary>The increment/decrement when the user clicks the up/down arrow buttons on the spin control</summary> 
            <remarks>Only available when PresentationStyle  is set to Spin</remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.WrapSpin">
            <summary>
            If true, indicates that the values shown in the block
            should "wrap" when passing beyond the minimum or maximum values.
            </summary>
            <remarks>
            <para>
            This setting applies only if PresentationStyle = Spin.
            </para>
            <para>
            Suppose the user repeatedly clicks on the "up" arrow, trying to
            increase the value beyond MaximumValue. The WrapSpin setting causes
            the following behavior:
            </para>
            <list type="bullet">
            <item>
            If WrapSpin = True, the value will "wrap" and will jump to MinimumValue.
            </item>
            <item>
            If WrapSpin = False, the value will "stick" at MaximumValue, and clicking the
            up arrow will have no further effect.
            </item>
            </list>
            Analogous behavior happens at the MinimumValue end of the range, too, of course.
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.MinInclusive">
            <summary>If true, indicates that a value equal to MinimumValue should be accepted as valid input</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.MaxInclusive">
            <summary>If true, indicates that a value equal to MaximumValue should be accepted as valid input</summary>
        </member>
        <member name="P:Snap.UI.Block.Integer.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
            <remarks>
            <para>
            The block automatically checks the user's input -- an error message will be displayed
            if the user tries to enter a value outside the valid range specified by the 
            MinimumValue and MaximumValue properties.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.MaximumValue">
            <summary>The maximum allowed integer value</summary>
            <remarks> 
            <para>
            Any value greater than this value is invalid.
            A value equal to this value is valid if the MaxInclusive property is 
            set to "true" or if PresentationStyle is set to scale or spin
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.MinimumValue">
            <summary>The minimum allowed integer value</summary>
            <remarks> 
            <para>
            Any value less than this value is invalid.
            A value equal to this value is valid if the MinInclusive property is 
            set to "true" or if PresentationStyle is set to scale or spin
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Integer.ReadOnly">
            <summary>If true, indicates that the value shown in the block is not editable</summary>
            <remarks>This property only takes effect when the PresentationStyle of the block is KeyIn</remarks>
        </member>
        <member name="M:Snap.UI.Block.Integer.#ctor">
            <summary>Construct an Integer block</summary>
        </member>
        <member name="M:Snap.UI.Block.Integer.#ctor(System.String,System.Int32)">
            <summary>Construct an Integer block</summary>
            <param name="label">Label displayed to the left of the numerical entry field</param>
            <param name="initialValue">The initial value to be shown in the numerical entry field</param>
        </member>
        <member name="M:Snap.UI.Block.Integer.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Integer in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="blockID">The name (blockID) of the Integer block</param>
            <returns>The Integer block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Double">
            <summary>Allows the user to enter a "double" (floating point number)</summary>      
            <example> 
            This example shows how to use a Double block: 
            <code title="A dialog with a Double block" lang="VB.NET" source="UI_Block_BoundingBox_01.vb">
            </code>
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/BoundingBox.PNG"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.Double.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.LabelVisibility">
            <summary>If true, indicates that the label of the block should be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.PresentationStyle">
            <summary>The presentation style of the block (how it is displayed)</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.PageIncrement">
            <summary>The increment/decrement when the user presses the Page Up or Page Down keys on the keyboard</summary> 
            <remarks>Only available when PresentationStyle  is set to Scale or ScaleKeyin</remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.LineIncrement">
            <summary>The increment/decrement when the user presses the arrow keys on the keyboard</summary> 
            <remarks>Only available when PresentationStyle  is set to Scale or ScaleKeyin</remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.ShowScaleValue">
            <summary>If true, indicates the value determined by the scale (slider) should be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.ScaleLimits">
            <summary>If true, indicates that the scale max and min labels should be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.ScaleMinLimitLabel">
            <summary>The label indicating the minimum scale limit</summary>
            <remarks>
            <para>
            Default is the value specified in MinimumValue property.  
            The label is only shown if ScaleLimits property is set to True.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.ScaleMaxLimitLabel">
            <summary>The label indicating the maximum scale limit</summary>
            <remarks>
            <para>
            Default is the value specified in MaximumValue property.  
            The label is only shown if ScaleLimits property is set to True.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.AdaptiveScaleLimits">
            <summary>If true, indicates that the scale should be adaptive</summary>
            <remarks>
            <para>
            If the scale is adaptive, its limits adjust to suitably bracket the user's
            current input value, which makes the scale much more useful.
            </para>
            <para>
            The scale can be adaptive when NumberPresentationStyle is equal to
            either Scale or ScaleKeyIn.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.Increment">
            <summary>The increment/decrement when the user clicks the up/down arrow buttons on the spin control</summary> 
            <remarks>Only available when PresentationStyle  is set to Spin</remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.WrapSpin">
            <summary>
            If true, indicates that the values shown in the block
            should "wrap" when passing beyond the minimum or maximum values.
            </summary>
            <remarks>
            <para>
            This setting applies only if PresentationStyle = Spin.
            </para>
            <para>
            Suppose the user repeatedly clicks on the "up" arrow, trying to
            increase the value beyond MaximumValue. The WrapSpin setting causes
            the following behavior:
            </para>
            <list type="bullet">
            <item>
            If WrapSpin = True, the value will "wrap" and will jump to MinimumValue.
            </item>
            <item>
            If WrapSpin = False, the value will "stick" at MaximumValue, and clicking the
            up arrow will have no further effect.
            </item>
            </list>
            Analogous behavior happens at the MinimumValue end of the range, too, of course.
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.MinInclusive">
            <summary>If true, indicates that a value equal to MinimumValue should be accepted as valid input</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.MaxInclusive">
            <summary>If true, indicates that a value equal to MaximumValue should be accepted as valid input</summary>
        </member>
        <member name="P:Snap.UI.Block.Double.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
            <remarks>
            <para>
            The block automatically checks the user's input -- an error message will be displayed
            if the user tries to enter a value outside the valid range specified by the 
            MinimumValue and MaximumValue properties.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.MaximumValue">
            <summary>The maximum allowed double value</summary>
            <remarks> 
            <para>
            Any value greater than this value is invalid.
            A value equal to this value is valid if the MaxInclusive property is 
            set to "true" or if PresentationStyle is set to scale or spin
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.MinimumValue">
            <summary>The minimum allowed double value</summary>
            <remarks> 
            <para>
            Any value less than this value is invalid.
            A value equal to this value is valid if the MinInclusive property is 
            set to "true" or if PresentationStyle is set to scale or spin
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Double.ReadOnly">
            <summary>If true, indicates that the value shown in the block is not editable</summary>
            <remarks>This property only takes effect when the PresentationStyle of the block is KeyIn</remarks>
        </member>
        <member name="M:Snap.UI.Block.Double.#ctor">
            <summary>Construct a Double block</summary>
        </member>
        <member name="M:Snap.UI.Block.Double.#ctor(System.String,System.Double)">
            <summary>Construct a Double block</summary>
            <param name="label">Label displayed to the left of the numerical entry field</param>
            <param name="initialValue">The initial value to be displayed in the numerical entry field.  Optional. Default = 0.0</param>
        </member>
        <member name="M:Snap.UI.Block.Double.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Double in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Double block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Expression">
            <summary>Allows the user to enter/edit an Expression</summary>
            <remarks>
            <para>
            The expression can be one that already exists in the part, or 
            a new one that is created on-the-fly.
            </para>
            <para>
            This block allows the user to type a number, just like the Double block,
            but it also provides access to Measurements, the Expression Editor and 
            the Insert Function command.
            </para>
            </remarks>            
        </member>
        <member name="P:Snap.UI.Block.Expression.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Expression.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Expression.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Expression.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.Expression.WithScale">
            <summary>If true, indicates that a scale (a slider bar) should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.Dimensionality">
            <summary>The dimensionality of the expression (e.g. Length, Angle, Mass)</summary>
            <remarks>
            <para>
            This determines the set of units options that are available for the quantity (e.g. for mm or in for Length, 
            degrees or radians for Angle, etc).      
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.HasUnitsMenu">
            <summary>If true, indicates that a menu will be displayed allowing the user to change units</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.Formula">
            <summary>Textual representation of the right-hand-side of the expression</summary>
            <remarks>
            <para>
            This property is just a "shortcut" to ExpressionObject.RightHandSide. So, you can not use
            this property until the ExpressionObject property has been properly set.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.ExpressionObject">
            <summary>The Expression object associated with the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.Units">
            <summary>The type of units used</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Expression.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.Expression.#ctor">
            <summary>Construct an Expression block</summary>
        </member>
        <member name="M:Snap.UI.Block.Expression.#ctor(System.String)">
            <summary>Construct an Expression block</summary>
            <param name="label">Label displayed to the left of the numerical entry field</param>
        </member>
        <member name="M:Snap.UI.Block.Expression.#ctor(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Creates a new block of type Expression</summary>
            <param name="dialog">The dialog in which the block will be created</param>
            <param name="blockID">The name (ID) to be assigned to the Expression block</param>
        </member>
        <member name="M:Snap.UI.Block.Expression.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Expression in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Expression block object</returns>
        </member>
        <member name="T:Snap.UI.Block.LinearDimension">
            <summary>Allows the user to specify a Linear Dimension</summary>
            <remarks>
            <para>
            In effect, this block defines an expression whose dimensionality is "length". 
            So, in some sense, it is a special case of the Expression block.
            </para>
            </remarks>      
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.WithScale">
            <summary>If true, indicates that a scale (a slider bar) should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.ExpressionObject">
            <summary>The Expression object associated with the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.Units">
            <summary>The type of units used</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.Formula">
            <summary>Textual representation of the formula for the expression. e.g. "4 + sin(30)"</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.ShowFocusHandle">
            <summary>If true, indicates that the GWIF should be displayed even when the focus is not on this block</summary>
            <remarks>
            <para>
            The "GWIF" is the Graphics Window Input Field.
            This property makes sense only when the property ShowHandle is set to "true".
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.ShowHandle">
            <summary>If true, indicates that a graphical handle should be displayed for dragging</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.HandleOrigin">
            <summary>Together with the HandleOrientation vector, specifies a line along which the handle can be dragged</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.HandleOrientation">
            <summary>Together with the HandleOrigin, specifies a line along which the handle can be dragged</summary>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.LinearDimension.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.LinearDimension.#ctor">
            <summary>Construct a LinearDimension block</summary>
        </member>
        <member name="M:Snap.UI.Block.LinearDimension.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type LinearDimension in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The LinearDimension block object</returns>
        </member>
        <member name="T:Snap.UI.Block.AngularDimension">
            <summary>Allows the user to specify an Angular Dimension</summary>
            <remarks>
            <para>
            In effect, this block defines an expression whose dimensionality is "angle". 
            So, in some sense, it is a special case of the Expression block.
            </para>
            </remarks>      
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.WithScale">
            <summary>If true, indicates that a scale (a slider bar) should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.ExpressionObject">
            <summary>The Expression object associated with the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.Units">
            <summary>The type of units used</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.Formula">
            <summary>Textual representation of the formula for the expression. e.g. "4 + sin(30)"</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.ShowFocusHandle">
            <summary>If true, indicates that the GWIF should be displayed even when the focus is not on this block</summary>
            <remarks>
            <para>
            The "GWIF" is the Graphics Window Input Field.
            This property makes sense only when the property ShowHandle is set to "true".
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.ShowHandle">
            <summary>If true, indicates that a graphical handle should be displayed for dragging</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.HandleRadius">
            <summary>The radius of the handle</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.HandleOrigin">
            <summary>The center point of the handle</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.HandleAxisX">
            <summary>The "3 o'clock" vector of the handle (from which angles are measured)</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.HandleAxisZ">
            <summary>The normal of the plane in which the handle lies</summary>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.AngularDimension.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.AngularDimension.#ctor">
            <summary>Construct an AngularDimension block</summary>
        </member>
        <member name="M:Snap.UI.Block.AngularDimension.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type AngularDimension in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The AngularDimension block object</returns>
        </member>
        <member name="T:Snap.UI.Block.RadiusDimension">
             <summary>Allows the user to specify a Radius Dimension</summary>
            <remarks>
            This block is identical to the LinearDimension block, except that it 
            only allows positive numbers to be input.
            </remarks> 
             <seealso cref= "T:Snap.UI.Block.LinearDimension">Snap.UI.Block.LinearDimension</seealso> 
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.WithScale">
            <summary>If true, indicates that a scale (a slider bar) should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.ExpressionObject">
            <summary>The Expression object associated with the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.Units">
            <summary>The type of units used</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.Formula">
            <summary>Textual representation of the formula for the expression. e.g. "4 + sin(30)"</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.ShowFocusHandle">
            <summary>If true, indicates that the GWIF should be displayed even when the focus is not on this block</summary>
            <remarks>
            <para>
            The "GWIF" is the Graphics Window Input Field.
            This property makes sense only when the property ShowHandle is set to "true".
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.ShowHandle">
            <summary>If true, indicates that a graphical handle should be displayed to assist editing</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.HandleOrigin">
            <summary>Together with the HandleOrientation vector, specifies a line along which the handle can be dragged</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.HandleOrientation">
            <summary>Together with the HandleOrigin, specifies a line along which the handle can be dragged</summary>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.RadiusDimension.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.RadiusDimension.#ctor">
            <summary>Construct a RadiusDimension block</summary>
        </member>
        <member name="M:Snap.UI.Block.RadiusDimension.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type RadiusDimension in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The RadiusDimension block object</returns>
        </member>
        <member name="T:Snap.UI.Block.OnPathDimension">
            <summary>Allows the user to specify an On Path Dimension</summary>
            <remarks>
            <para>
            This allows the user to specify a location along a chain of curves.
            The location can be specified by arclength, parameter value, or 
            by a given reference point.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.WithScale">
            <summary>If true, indicates that a scale (a slider bar) should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.ExpressionObject">
            <summary>The Expression object associated with the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Units">
            <summary>The type of units used</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Formula">
            <summary>Textual representation of the formula for the expression. e.g. "4 + sin(30)"</summary>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Value">
            <summary>The value shown in the block, to be edited by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.ShowFocusHandle">
            <summary>If true, indicates that the GWIF should be displayed even when the focus is not on this block</summary>
            <remarks>
            <para>
            The "GWIF" is the Graphics Window Input Field.
            This property makes sense only when the property ShowHandle is set to "true".
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.OptionMask">
            <summary>Determines which of the LocationOption choices should be available to the user</summary>
            <remarks>
            <para>
            The option mask is specified as a sum of integers. The individual integer values are:
            <list type="bullet">
            <item> &#xA0;= 1 : by arclength</item>
            <item> &#xA0;= 2 : by percentage arclength (a number between 0 and 100)</item>
            <item> &#xA0;= 4 : by parameter percentage (a number between 0 and 100)</item>
            <item> &#xA0;= 8 : by a point (which is projected onto the path)</item>
            </list>
            So, if you want the arclength and percentage arclength options to be available,
            you should specify a value of 1 + 2 = 3. A value of 15 will make all four options available.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.LocationOption">
            <summary>Specifies the type of technique used to locate the handle on the path.</summary>
            <remarks>
            <para>
            The options are:
            <list type="bullet">
            <item> &#xA0;= 0 : by arclength</item>
            <item> &#xA0;= 1 : by percentage arclength (a number between 0 and 100)</item>
            <item> &#xA0;= 2 : by parameter percentage (a number between 0 and 100)</item>
            <item> &#xA0;= 3 : by a point (which is projected onto the path)</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.Path">
            <summary>The path (curve, edge, section)</summary>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OnPathDimension.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.OnPathDimension.#ctor">
            <summary>Construct an OnPathDimension block</summary>
        </member>
        <member name="M:Snap.UI.Block.OnPathDimension.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type OnPathDimension in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The OnPathDimension block object</returns>
        </member>
        <member name="T:Snap.UI.Block.IntegerTable">
            <summary>Allows the user to enter/edit a table of integer values</summary> 
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
            <remarks>
            <para>
            This text will appear to the left of every cell in the table, so in
            most cases it's best to leave it blank. The row and column titles
            provide a better way to label the cells, usually.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.RowTitles">
            <summary>The row titles</summary>
            <remarks>
            <para>
            If the RowTitles array is <c>Nothing</c>, or has zero length, the table
            will not be displayed properly.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.ColumnTitles">
            <summary>The column titles</summary>
            <remarks>
            <para>
            If the ColumnTitles array is <c>Nothing</c>, or has zero length, the table
            will not be displayed properly.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.Values">
            <summary>The integer values to be displayed/edited</summary>
            <remarks>
            <para>
            The block automatically checks the user's input -- an error message will be displayed
            if the user tries to enter a value outside the valid range specified by the 
            MinimumValue and MaximumValue properties.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input array has a dimension that is zero</exception>
            <exception cref="T:System.ArgumentNullException">The input array is null (<c>Nothing</c>)</exception>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.MaximumValues">
            <summary>Array of the maximum allowed integer values</summary>
            <exception cref="T:System.ArgumentException">The input array has a dimension that is zero</exception>
            <exception cref="T:System.ArgumentNullException">The input array is null (<c>Nothing</c>)</exception>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.MinimumValues">
            <summary>Array of the minimum allowed integer values</summary>
            <exception cref="T:System.ArgumentException">The input array has a dimension that is zero</exception>
            <exception cref="T:System.ArgumentNullException">The input array is null (<c>Nothing</c>)</exception>
        </member>
        <member name="P:Snap.UI.Block.IntegerTable.Spin">
            <summary>If true, indicates that a Spin control should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.IntegerTable.#ctor">
            <summary>Construct an IntegerTable block</summary>
        </member>
        <member name="M:Snap.UI.Block.IntegerTable.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type IntegerTable in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The IntegerTable block object</returns>
        </member>
        <member name="T:Snap.UI.Block.DoubleTable">
            <summary>Allows the user to enter/edit a table of double (floating point) values</summary>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
            <remarks>
            <para>
            This text will appear to the left of every cell in the table, so in
            most cases it's best to leave it blank. The row and column titles
            provide a better way to label the cells, usually.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.RowTitles">
            <summary>The row titles</summary>
            <remarks>
            <para>
            If the RowTitles array is <c>Nothing</c>, or has zero length, the table
            will not be displayed properly.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.ColumnTitles">
            <summary>The column titles</summary>
            <remarks>
            <para>
            If the ColumnTitles array is <c>Nothing</c>, or has zero length, the table
            will not be displayed properly.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.Values">
            <summary>The double values to be displayed/edited</summary>
            <remarks>
            <para>
            The block automatically checks the user's input -- an error message will be displayed
            if the user tries to enter a value outside the valid range specified by the 
            MinimumValue and MaximumValue properties.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">The input array has a dimension that is zero</exception>
            <exception cref="T:System.ArgumentNullException">The input array is null (<c>Nothing</c>)</exception>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.MaximumValues">
            <summary>Array of the maximum allowed values in each table cell</summary>
            <exception cref="T:System.ArgumentException">The input array has a dimension that is zero</exception>
            <exception cref="T:System.ArgumentNullException">The input array is null (<c>Nothing</c>)</exception>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.MinimumValues">
            <summary>Array of the minimum allowed values in each table cell</summary>
            <exception cref="T:System.ArgumentException">The input array has a dimension that is zero</exception>
            <exception cref="T:System.ArgumentNullException">The input array is null (<c>Nothing</c>)</exception>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.Spin">
            <summary>If true, indicates that a Spin control should be displayed on each cell</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.DoubleTable.CellWidth">
            <summary>Width of each table cell, in characters</summary>
        </member>
        <member name="M:Snap.UI.Block.DoubleTable.#ctor">
            <summary>Construct a DoubleTable block</summary>
        </member>
        <member name="M:Snap.UI.Block.DoubleTable.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type DoubleTable in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The DoubleTable block object</returns>
        </member>
        <member name="T:Snap.UI.Block.Group">
            <summary>A collection of other blocks</summary>
            <remarks>
            <para>
            The create a new group, set the <c>BeginGroup</c> property of its first
            block to <c>True</c>. The new group will contain the current block and any 
            subsequent ones that have <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            On a BlockForm, setting  <c>BeginGroup = True</c> will add the current block to a new
            group, but not subsequent ones, so the result will be a group containing a single block. 
            If you want to create a dialog having a Group with multiple members, please use a 
            <see cref = "T:Snap.UI.BlockDialog">Snap.UI.BlockDialog</see>, rather than a BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Group.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Group.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Group.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.Group.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.Group.Members">
            <summary>Array of blocks that are contained within this group block.</summary>
        </member>
        <member name="P:Snap.UI.Block.Group.NumberOfColumns">
            <summary>The number of columns used in the layout of the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.Group.#ctor">
            <summary>Construct a Group block</summary>
        </member>
        <member name="M:Snap.UI.Block.Group.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type Group in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The Group block object</returns>
        </member>
        <member name="T:Snap.UI.Block.TableLayout">
            <summary>Provides a way to arrange dialog blocks in a tabular layout</summary>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.RetainValue">
            <summary>If true, indicates that the values in the block should be retained from one use of the dialog to the next</summary>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.HighQualityBitmap">
            <summary>If true, indicates that a high-quality (24-bit) version of the Bitmap should be displayed</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.Localize">
            <summary>If true, indicates that the Label string should be replaced by a localized version</summary>
            <remarks>
            <para>
            If the Label string matches an English string in the NX string localization database and the Localize 
            property is "true", then the Label string is translated to the current locale language.
            </para>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.Members">
            <summary>Array of blocks that are contained within this TableLayout block.</summary>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.NumberOfColumns">
            <summary>The number of columns used in the layout of the block.</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.TableLayout.HasColumnLabels">
            <summary>If true, indicates that the Table Layout Block has column labels </summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.TableLayout.#ctor">
            <summary>Construct a table layout block</summary>
        </member>
        <member name="M:Snap.UI.Block.TableLayout.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type TableLayout in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The TableLayout block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SelectObject">
            <summary>Allows the user to select one or more general NX objects</summary>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about selecting objects.
            </para>
            <para>
            If you want a standalone selection dialog, rather than a selection
            block on a dialog, please use a
            <see cref= "T:Snap.UI.Selection">Snap.UI.Selection</see> object and the 
            <see cref= "O:Snap.UI.Selection.SelectObject">Snap.UI.Selection.SelectObject</see> functions.
            </para>
            </remarks>
            <example> 
            This example shows how to use a SelectObject block: 
            <code title="A dialog with a SelectObject block" lang="VB.NET" source="UI_Block_FacePainter_01.vb">
            </code>
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/FacePainter.PNG"/>
            </example>
            <seealso cref= "T:Snap.UI.Selection">Snap.UI.Selection</seealso>
            <seealso cref= "O:Snap.UI.Selection.SelectObject">Snap.UI.Selection.SelectObject</seealso>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.Cue">
            <summary>Text to be displayed in the cue line. Accepts any text string.</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.AllowMultiple">
            <summary>If true, indicates selection of multiple objects is allowed</summary>
            <remarks>
            <para>
            If set to false, only a single object can be selected at a time, and the 
            focus then moves to the next block on the dialog if the AutomaticProgression property is True. 
            If set to true, multiple objects can be selected using rectangular or lasso selection, 
            in addition to single selection. In case of rectangular or lasso selection, the focus 
            remains on this block until focus is shifted manually to another block. 
            In other words, this option doesn't honor the AutomaticProgression property if objects are 
            selected using rectangular or lasso selection
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.MaskTriples">
            <summary>The mask triples defining the selection filter</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.PointOverlay">
            <summary>If true, allows the user to specify points on-the-fly, which will be added to the selection list</summary> 
            <remarks>This is done by providing access to the SNAP Point toolbar and the Point Constructor dialog</remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.SnapPointTypesEnabled">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
            <remarks>
            <para>
            The integer value is a Hexadecimal representation of the Bits option. 
            Integer values are generated in the code template.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.SnapPointTypesOnByDefault">
            <summary>The list of SNAP Point options that will be enabled by default on the SNAP Point toolbar</summary>
            <remarks>
            <para>
            The integer value is a Hexadecimal representation of the Bits option. 
            Integer values are generated in the code template.
            The options specified in SnapPointTypesOnByDefault must be a subset of those
            specified by SnapPointTypesEnabled.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.SnapPointStates">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.MaximumScope">
            <summary>The selection scope (work part, assembly, etc.)</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.LabelString">
            <summary>Text displayed before the object count on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.CreateInterpartLink">
            <summary>The state of the "Create Interpart Link" toggle on the Selection Bar</summary>
            <remarks>
            <para>
            Note that this toggle is only sensitive when working in-context and the InterpartSelection property 
            is set to "Controlled" (InterPartSelectionCopy.Controlled).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectObject.PickPoint">
            <summary>The "pick point" on the selected object</summary>
            <remarks>
            <para>
            The "pick point" is a point on the selected object. It is either
            the place where the cursor ray pierces the object, or the closest
            point of the object to the cursor ray. Please see chapter&#160;15 of the 
            SNAP Getting Started Guide for an explanation of the cursor ray.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.#ctor">
            <summary>Construct a SelectObject block</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.#ctor(System.String,System.String)">
            <summary>Construct a select object block</summary>
            <param name="cue">Message to be shown in the Cue line when the dialog is displayed</param>
            <param name="label">Label displayed to the left of the selection field</param>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SelectObject in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SelectObject block object</returns>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetFilter(Snap.NX.ObjectTypes.TypeCombo[])">
            <summary>Sets the selection filter using TypeCombos</summary>
            <param name="combos">TypeCombos indicating which types of objects should be eligible for selection</param>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example> 
            This example shows how to set the selection filter with TypeCombos:
            <code title="Selection filtering with TypeCombos: " lang="VB.NET" source="UI_BlockSelection_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetFilter(Snap.NX.ObjectTypes.Type[])">
            <summary>Sets the selection filter using object types</summary>
            <param name="types">Array of object types that are to be eligible for selection</param>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example> 
            This example shows how to set the selection filter with given types:
            <code title="Selection filtering with an array of types: " lang="VB.NET" source="UI_BlockSelection_04.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetFilter(Snap.NX.ObjectTypes.Type,Snap.NX.ObjectTypes.SubType)">
            <summary>Sets the selection filter using an object type and subtype</summary>
            <param name="type">Object type that is to be eligible for selection</param>
            <param name="subtype">Object subtype that is to be eligible for selection</param>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example> 
            This example shows how to set the selection filter with a given type and subtype:
            <code title="Filtering with a type and subtype: " lang="VB.NET" source="UI_BlockSelection_02.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetCurveFilter">
            <summary>Sets the filter to allow selection of any type of curve or edge objects</summary>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example>
            This example shows how to select any type of curve or edge:
            <code title="Selecting any curves or edge: " lang="VB.NET" source="UI_BlockSelection_05.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetCurveFilter(Snap.NX.ObjectTypes.Type[])">
            <summary>Sets the filter to allow selection of given types of curve or edge objects</summary>
            <param name="types">Array of edge/curve types that are to be eligible for selection</param>
            <remarks> 
            <para>
            A single type code is used to refer to both curves and edges. So, for example, to make circular curves and
            edges eligible for selection, pass NX.ObjectTypes.Types.Circle as the argument to this function.
            </para>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example> 
            This example shows how to set the filter with given curve/edge types:
            <code title="Selecting a circular curve or edge: " lang="VB.NET" source="UI_BlockSelection_06.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetFaceFilter">
            <summary>Sets the filter to allow selection of any type of face</summary>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example> 
            This example shows how to select any type of face:
            <code title="Selecting any type of face: " lang="VB.NET" source="UI_BlockSelection_07.vb"> 
            </code> 
            </example>
        </member>
        <member name="M:Snap.UI.Block.SelectObject.SetFaceFilter(Snap.NX.ObjectTypes.SubType[])">
            <summary>Sets the filter to allow selection of given types of faces</summary>
            <param name="faceTypes">Array of face types that are to be eligible for selection</param>
            <remarks>
            <para>
            Please see Chapter 15 of the "Getting Started with SNAP" guide for 
            more information about how to use selection filters. 
            </para>
            </remarks>         
            <example>
            This example shows how to set the filter with given face types:
            <code title="Selecting a cylindrical or conical face: " lang="VB.NET" source="UI_BlockSelection_03.vb">
            </code>
            </example>
        </member>
        <member name="T:Snap.UI.Block.SectionBuilder">
            <summary>Provides access to the Section Builder subfunction</summary>
            <remarks>
            <para>
            This block allows the user to select a collection of curves using Selection Intent (SI) rules.
            The flow direction of the section can be reversed either by clicking the Reverse Direction 
            button on the dialog, or by double-clicking on the direction handle in the graphics window.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.Cue">
            <summary>Text to be displayed in the cue line. Accepts any text string.</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.PointOverlay">
            <summary>If true, allows the user to specify points on-the-fly, which will be added to the selection list</summary> 
            <remarks>This is done by providing access to the SNAP Point toolbar and the Point Constructor dialog</remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.SnapPointTypesEnabled">
            <summary>The list of snapping options that will be selected (enabled by default) on the snap point toolbar</summary>
            <remarks>
            <para>
            See SpecifyPoint for more info
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.SnapPointTypesOnByDefault">
            <summary>The list of snapping options that will be selected (enabled by default) on the snap point toolbar</summary>
            <remarks>
            <para>
            See SpecifyPoint for more info
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.SnapPointStates">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.LabelString">
            <summary>Text displayed before the object count on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.CreateInterpartLink">
            <summary>The state of the "Create Interpart Link" toggle on the Selection Bar</summary>
            <remarks>
            <para>
            Note that this toggle is only sensitive when working in-context and the InterpartSelection property 
            is set to "Controlled" (InterPartSelectionCopy.Controlled).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.EntityType">
            <summary>Specifies the entity type(s) that will be allowed for selection</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
                 <item> AllowEdgesandCurves <c>  = (1 &lt;&lt; 2) = 2^2 =  4</c>  </item>
                 <item> AllowPoints         <c>  = (1 &lt;&lt; 3) = 2^3 =  8</c>  </item>
            </list>
            So, for example, if you want faces and bodies to be selectable, you
            should set <c>EntityType = 16 + 64 = 80</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.CurveRules">
            <summary>A bit-mask indicating which Selection Intent options should be shown on the Selection Bar.</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
             <item><c>                 SingleCurve = (1 &lt;&lt;  0) =     1  </c></item>
             <item><c>             ConnectedCurves = (1 &lt;&lt;  1) =     2  </c></item>
             <item><c>               TangentCurves = (1 &lt;&lt;  2) =     4  </c></item>
             <item><c>                   FaceEdges = (1 &lt;&lt;  3) =     8  </c></item>
             <item><c>                   BodyEdges = (1 &lt;&lt;  4) =    16  </c></item>
             <item><c>                  SheetEdges = (1 &lt;&lt;  5) =    32  </c></item>
             <item><c>               FeatureCurves = (1 &lt;&lt;  6) =    64  </c></item>
             <item><c>                 InferCurves = (1 &lt;&lt;  7) =   128  </c></item>
             <item><c>        RegionBoundaryCurves = (1 &lt;&lt; 11) =  2048  </c></item>
             <item><c>               CurvesinGroup = (1 &lt;&lt; 12) =  4096  </c></item>
             <item><c>           OuterEdgesofFaces = (1 &lt;&lt; 13) =  8192  </c></item>
             <item><c>             RibTopFaceEdges = (1 &lt;&lt; 14) =  2^14  </c></item>
            </list>
            So, if you want to enable the SingleCurve and BodyEdges options, you should
            set <c>CurveRules = 1 + 16 = 17</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.DefaultCurveRules">
            <summary>The Selection Intent option that will be pre-selected</summary>
            <remarks>
            <para>
            The integer value is one of the ones listed in the FaceRules property. So, for example,
            if you want the "Body Faces" option to be the default, you should set <c>DefaultFaceRules = 16</c>.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SectionBuilder.CurveRules">CurveRules</seealso>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.StopAtIntersection">
            <summary>The "Stop at Intersection" selection intent option on the Selection Bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.FollowFillet">
            <summary>The "Follow Fillet" selection intent option on the Selection Bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.ChainWithinFeature">
            <summary>The "Chain Within Feature" selection intent option on the Selection Bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.AllowStopAtIntersectionFollowFillet">
            <summary>If true, indicates that Stop at Intersection, Follow Fillet, and Chain within Feature are visible on the selection bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.AngularTolerance">
            <summary>The angular tolerance value used in constructing the section</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.ShowFlowDirectionAndOriginCurve">
            <summary>If true, indicates that the user can change the origin curve and flow direction</summary>
        </member>
        <member name="P:Snap.UI.Block.SectionBuilder.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="M:Snap.UI.Block.SectionBuilder.#ctor">
            <summary>Construct a SectionBuilder block</summary>
        </member>
        <member name="M:Snap.UI.Block.SectionBuilder.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SectionBuilder in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SectionBuilder block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SuperSection">
            <summary>Provides access to the Super Section subfunction</summary>
            <remarks>
            <para>
            This block allows the user to select a collection of existing curves (as
            in the SectionBuilder block), or to sketch on-the-fly.
            A full set of Selection Intent rules are used in curve selection.
            The Sketch command takes control when sketching on-the-fly. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.Cue">
            <summary>Text to be displayed in the cue line. Accepts any text string.</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.PointOverlay">
            <summary>If true, allows the user to specify points on-the-fly, which will be added to the selection list</summary> 
            <remarks>This is done by providing access to the SNAP Point toolbar and the Point Constructor dialog</remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.SnapPointTypesEnabled">
            <summary>The list of snapping options that will be selected (enabled by default) on the snap point toolbar</summary>
            <remarks>
            <para>
            See SpecifyPoint for more info
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.SnapPointTypesOnByDefault">
            <summary>The list of snapping options that will be selected (enabled by default) on the snap point toolbar</summary>
            <remarks>
            <para>
            See SpecifyPoint for more info
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.SnapPointStates">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.LabelString">
            <summary>Text displayed before the object count on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.CreateInterpartLink">
            <summary>The state of the "Create Interpart Link" toggle on the Selection Bar</summary>
            <remarks>
            <para>
            Note that this toggle is only sensitive when working in-context and the InterpartSelection property 
            is set to "Controlled" (InterPartSelectionCopy.Controlled).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.EntityType">
            <summary>Specifies the entity type(s) that will be allowed for selection</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
                 <item> AllowEdgesandCurves <c>  = (1 &lt;&lt; 2) = 2^2 =  4</c>  </item>
                 <item> AllowPoints         <c>  = (1 &lt;&lt; 3) = 2^3 =  8</c>  </item>
            </list>
            So, for example, if you want faces and bodies to be selectable, you
            should set <c>EntityType = 16 + 64 = 80</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.CurveRules">
            <summary>A bit-mask indicating which Selection Intent options should be shown on the Selection Bar.</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
             <item><c>                 SingleCurve = (1 &lt;&lt;  0) =     1  </c></item>
             <item><c>             ConnectedCurves = (1 &lt;&lt;  1) =     2  </c></item>
             <item><c>               TangentCurves = (1 &lt;&lt;  2) =     4  </c></item>
             <item><c>                   FaceEdges = (1 &lt;&lt;  3) =     8  </c></item>
             <item><c>                   BodyEdges = (1 &lt;&lt;  4) =    16  </c></item>
             <item><c>                  SheetEdges = (1 &lt;&lt;  5) =    32  </c></item>
             <item><c>               FeatureCurves = (1 &lt;&lt;  6) =    64  </c></item>
             <item><c>                 InferCurves = (1 &lt;&lt;  7) =   128  </c></item>
             <item><c>        RegionBoundaryCurves = (1 &lt;&lt; 11) =  2048  </c></item>
             <item><c>               CurvesinGroup = (1 &lt;&lt; 12) =  4096  </c></item>
             <item><c>           OuterEdgesofFaces = (1 &lt;&lt; 13) =  8192  </c></item>
             <item><c>             RibTopFaceEdges = (1 &lt;&lt; 14) =  2^14  </c></item>
            </list>
            So, if you want to enable the SingleCurve and BodyEdges options, you should
            set <c>CurveRules = 1 + 16 = 17</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.DefaultCurveRules">
            <summary>The Selection Intent option that will be pre-selected</summary>
            <remarks>
            <para>
            The integer value is one of the ones listed in the FaceRules property. So, for example,
            if you want the "Body Faces" option to be the default, you should set <c>DefaultFaceRules = 16</c>.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SectionBuilder.CurveRules">CurveRules</seealso>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.StopAtIntersection">
            <summary>The "Stop at Intersection" selection intent option on the Selection Bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.FollowFillet">
            <summary>The "Follow Fillet" selection intent option on the Selection Bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.ChainWithinFeature">
            <summary>The "Chain Within Feature" selection intent option on the Selection Bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.AllowStopAtIntersectionFollowFillet">
            <summary>If true, indicates that Stop at Intersection, Follow Fillet, and Chain within Feature are visible on the selection bar.</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.AngularTolerance">
            <summary>The angular tolerance value used in constructing the section</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.ShowFlowDirectionAndOriginCurve">
            <summary>If true, indicates that the user can change the origin curve and flow direction</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.SuperSection.SketchOnPath">
            <summary>If true, allows the user to switch between Sketch in Place and Sketch on Path</summary>
        </member>
        <member name="M:Snap.UI.Block.SuperSection.#ctor">
            <summary>Construct a SuperSection block</summary>
        </member>
        <member name="M:Snap.UI.Block.SuperSection.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SuperSection in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SuperSection block object</returns>
        </member>
        <member name="T:Snap.UI.Block.CurveCollector">
            <summary>Allows the user to select a collection of curves via Selection Intent</summary>
            <remarks>
            <para>
            Curve selection intent is used in this block, but it does not support the SI rule 
            options Stop at Intersection, Follow Fillet, Chain Between, and Chain within Feature.
            </para>
            <para>
            This block is commonly employed when edges but not curves are being selected.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>      
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.Cue">
            <summary>Text to be displayed in the cue line. Accepts any text string.</summary>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.AllowMultiple">
            <summary>If true, indicates selection of multiple objects is allowed</summary>
            <remarks>
            <para>
            If set to false, only a single object can be selected at a time, and the 
            focus then moves to the next block on the dialog if the AutomaticProgression property is True. 
            If set to true, multiple objects can be selected using rectangular or lasso selection, 
            in addition to single selection. In case of rectangular or lasso selection, the focus 
            remains on this block until focus is shifted manually to another block. 
            In other words, this option doesn't honor the AutomaticProgression property if objects are 
            selected using rectangular or lasso selection
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.LabelString">
            <summary>Text displayed before the object count on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.CreateInterpartLink">
            <summary>The state of the "Create Interpart Link" toggle on the Selection Bar</summary>
            <remarks>
            <para>
            Note that this toggle is only sensitive when working in-context and the InterpartSelection property 
            is set to "Controlled" (InterPartSelectionCopy.Controlled).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.EntityType">
            <summary>Specifies the entity type(s) that will be allowed for selection</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
                 <item> AllowEdges <c>  = (1 &lt;&lt; 0) = 2^0 =  1</c>  </item>
                 <item> AllowCurves <c> = (1 &lt;&lt; 2) = 2^2 =  4</c>  </item>
                 <item> AllowPoints  <c> = (1 &lt;&lt; 3) = 2^3 =  8</c>  </item>
                 <item> AllowFaces  <c> = (1 &lt;&lt; 4) = 2^4 =  16</c>  </item>
                 <item> AllowBodies <c> = (1 &lt;&lt; 6) = 2^6 = 64</c>  </item>
            </list>
            So, for example, if you want faces and bodies to be selectable, you
            should set <c>EntityType = 16 + 64 = 80</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.CurveRules">
            <summary>A bit-mask indicating which Selection Intent options should be shown on the Selection Bar.</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
             <item><c>                 SingleCurve = (1 &lt;&lt;  0) =     1  </c></item>
             <item><c>             ConnectedCurves = (1 &lt;&lt;  1) =     2  </c></item>
             <item><c>               TangentCurves = (1 &lt;&lt;  2) =     4  </c></item>
             <item><c>                   FaceEdges = (1 &lt;&lt;  3) =     8  </c></item>
             <item><c>                   BodyEdges = (1 &lt;&lt;  4) =    16  </c></item>
             <item><c>                  SheetEdges = (1 &lt;&lt;  5) =    32  </c></item>
             <item><c>               FeatureCurves = (1 &lt;&lt;  6) =    64  </c></item>
             <item><c>                 VertexEdges = (1 &lt;&lt;  8) =   256  </c></item>
             <item><c>          VertexTangentEdges = (1 &lt;&lt;  9) =   512  </c></item>
             <item><c>        RegionBoundaryCurves = (1 &lt;&lt; 11) =  2048  </c></item>
             <item><c>           OuterEdgesofFaces = (1 &lt;&lt; 13) =  8192  </c></item>
             <item><c>             RibTopFaceEdges = (1 &lt;&lt; 14) =  2^14  </c></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.CurveCollector.DefaultCurveRules">
            <summary>The Selection Intent option that will be pre-selected</summary>
            <remarks>
            <para>
            The integer value is one of the ones listed in the 
            <see cref= "P:Snap.UI.Block.CurveCollector.CurveRules">CurveRules</see> property. So, for example,
            if you want the "Tangent Curves" option to be the default, you should set <c>DefaultCurveRules = 4</c>.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.CurveCollector.CurveRules">CurveRules</seealso>
        </member>
        <member name="M:Snap.UI.Block.CurveCollector.#ctor">
            <summary>Construct a CurveCollector block</summary>
        </member>
        <member name="M:Snap.UI.Block.CurveCollector.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type CurveCollector in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The CurveCollector block object</returns>
        </member>
        <member name="T:Snap.UI.Block.FaceCollector">
            <summary>Allows the user to select a collection of faces via Selection Intent</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>      
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.Cue">
            <summary>Text to be displayed in the cue line. Accepts any text string.</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.AllowMultiple">
            <summary>If true, indicates selection of multiple objects is allowed</summary>
            <remarks>
            <para>
            If set to false, only a single object can be selected at a time, and the 
            focus then moves to the next block on the dialog if the AutomaticProgression property is True. 
            If set to true, multiple objects can be selected using rectangular or lasso selection, 
            in addition to single selection. In case of rectangular or lasso selection, the focus 
            remains on this block until focus is shifted manually to another block. 
            In other words, this option doesn't honor the AutomaticProgression property if objects are 
            selected using rectangular or lasso selection
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.Bitmap">
            <summary>The name of a bitmap image used to label this block</summary>
            <remarks>
            <para>
            The name may be either the pathname of a bitmap file, like "C:\images\pic.bmp",
            or the name of a built-in NX icon bitmap, such as "cone". 
            If you use a bitmap file, it must be in the bmp format.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.LabelString">
            <summary>Text displayed before the object count on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.CreateInterpartLink">
            <summary>The state of the "Create Interpart Link" toggle on the Selection Bar</summary>
            <remarks>
            <para>
            Note that this toggle is only sensitive when working in-context and the InterpartSelection property 
            is set to "Controlled" (InterPartSelectionCopy.Controlled).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.EntityType">
            <summary>Specifies the entity type(s) that will be allowed for selection</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
                 <item> AllowFaces <c>  = (1 &lt;&lt; 4) = 2^4 = 16 = 0x10</c>  </item>
                 <item> AllowDatums <c> = (1 &lt;&lt; 5) = 2^5 = 32 = 0x20</c>  </item>
                 <item> AllowBodies <c> = (1 &lt;&lt; 6) = 2^6 = 64 = 0x40</c>  </item>
            </list>
            So, for example, if you want faces and bodies to be selectable, you
            should set <c>EntityType = 16 + 64 = 80</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.FaceRules">
            <summary>A bit-mask indicating which Selection Intent options should be shown on the Selection Bar.</summary>
            <remarks>
            <para>
            The integer value is a bit-mask. The i-th bit in the integer indicates whether or not the
            i-th option is available. The integer value can be constructed by adding together the integer
            values for individual options, which are as follows:
            <list type="bullet">
             <item><c>             SingleFace = (1 &lt;&lt;  0) =    1  </c></item>
             <item><c>            RegionFaces = (1 &lt;&lt;  1) =    2  </c></item>
             <item><c>           TangentFaces = (1 &lt;&lt;  2) =    4  </c></item>
             <item><c>     TangentRegionFaces = (1 &lt;&lt;  3) =    8  </c></item>
             <item><c>              BodyFaces = (1 &lt;&lt;  4) =   16  </c></item>
             <item><c>           FeatureFaces = (1 &lt;&lt;  5) =   32  </c></item>
             <item><c>          AdjacentFaces = (1 &lt;&lt;  6) =   64  </c></item>
             <item><c>    ConnectedBlendFaces = (1 &lt;&lt;  7) =  128  </c></item>
             <item><c>          AllBlendFaces = (1 &lt;&lt;  8) =  256  </c></item>
             <item><c>               RibFaces = (1 &lt;&lt;  9) =  512  </c></item>
             <item><c>              SlotFaces = (1 &lt;&lt; 10) = 1024  </c></item>
             <item><c>     BossandPocketFaces = (1 &lt;&lt; 11) = 2048  </c></item>
             <item><c>         MergedRibFaces = (1 &lt;&lt; 12) = 4096  </c></item>
             <item><c>    RegionBoundaryFaces = (1 &lt;&lt; 13) = 8192  </c></item>
             <item><c>   FaceandAdjacentFaces = (1 &lt;&lt; 14) = 2^14  </c></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.FaceCollector.DefaultFaceRules">
            <summary>The Selection Intent option that will be pre-selected</summary>
            <remarks>
            <para>
            The integer value is one of the ones listed in the FaceRules property. So, for example,
            if you want the "Body Faces" option to be the default, you should set <c>DefaultFaceRules = 16</c>.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.FaceCollector.FaceRules">FaceRules</seealso>
        </member>
        <member name="M:Snap.UI.Block.FaceCollector.#ctor">
            <summary>Construct a FaceCollector block</summary>
        </member>
        <member name="M:Snap.UI.Block.FaceCollector.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type FaceCollector in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The FaceCollector block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SelectFeature">
            <summary>Allows the user to select a feature</summary>
            <remarks>
            <para>
            The object types selectable are Curve features, Sketches, Features, and Datums
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.Cue">
            <summary>Text to be displayed in the cue line. Accepts any text string.</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.AllowMultiple">
            <summary>If true, indicates selection of multiple objects is allowed</summary>
            <remarks>
            <para>
            If set to false, only a single object can be selected at a time, and the 
            focus then moves to the next block on the dialog if the AutomaticProgression property is True. 
            If set to true, multiple objects can be selected using rectangular or lasso selection, 
            in addition to single selection. In case of rectangular or lasso selection, the focus 
            remains on this block until focus is shifted manually to another block. 
            In other words, this option doesn't honor the AutomaticProgression property if objects are 
            selected using rectangular or lasso selection
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.LabelString">
            <summary>Text displayed before the object count on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.ToolTip">
            <summary>The tooltip text to be displayed when the user hovers the mouse pointer over the block</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectFeature.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectFeature.#ctor">
            <summary>Construct a SelectFeature block</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectFeature.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SelectFeature in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SelectFeature block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyPoint">
            <summary>Allows the user to specify a point (location)</summary>
            <remarks>
            <para>
            This block allows the user to specify a point using all the usual NX methods,
            and with all the usual "snap point" options. 
            </para>
            <para>
            Note that the Cue property of this block is not used. The cue text is displayed
            automatically, and depends on which method is being used to specify the point.</para>
            </remarks>
            <example> 
            This example shows how to use a SpecifyPoint block on a SNAP BlockForm: 
            <code title="A dialog with a SpecifyPoint block" lang="VB.NET" source="UI_Block_SphereCap_01.vb">
            </code>
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/SphereCap.PNG"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.Label">
            <summary>Explanatory text displayed above the block, if it begins a group</summary>
            <remarks>
            <para>
            If the block has <c>BeginGroup = False</c>, then this text is not displayed.
            </para>
            <para>
            The following picture shows where the Label is displayed,
            assuming that <c>BeginGroup = True</c>
            <img src="../Images/SpecifyPointLabels.PNG"/>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.LabelString">
            <summary>Prompt text displayed within the block </summary>
            <remarks>
            <para>
            The following picture shows where the LabelString is displayed
            <img src="../Images/SpecifyPointLabels2.PNG"/>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.SnapPointTypesEnabled">
            <summary>Specifies the list of snapping options that will be available on the snap point toolbar</summary>
            <remarks>
            <para>
            You will probably find it much easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyPoint.SnapPointStates">SnapPointStates</see> property, rather than this one.
            </para>
            <para>
            The integer value is a bit-mask representation of the options that are in the "shown"
            state (enabled). If the i-th bit of the integer is set to 1, this means that
            the i-th snap option is in the "shown" state. 
            <para>
            Since there are 17 snap options, only the least significant 17 bits of the integer are used.
            If all options are selected, the integer's bits will consist of 17 ones, which means
            that the integer value will be 2^(17) - 1 = 131071. So, any set of options can
            be represented by an integer that is less than or equal to 131071.
            </para>
            <para>
            The integer value returned by getting this property value will be at most 131071.
            </para>
            <para>
            When setting this property, if the input value is larger than 131071, only
            the low-order 17 bits will be used.
            </para>
            The options specified in SnapPointTypesOnByDefault should be a subset of those
            specified by SnapPointTypesEnabled, but there is nothing here to enforce this.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPoint.SnapPointStates">Snap.UI.Block.SpecifyPoint.SnapPointStates</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.SnapPointTypesOnByDefault">
            <summary>The list of snapping options that will be selected (enabled by default) on the snap point toolbar</summary>
            <remarks>
            <para>
            You will probably find it much easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyPoint.SnapPointStates">SnapPointStates</see> property, rather than this one.
            </para>
            <para>
            The integer value is a bit-mask representation of the options that are in the "selected"
            state (enabled by default). If the i-th bit of the integer is set to 1, this means that
            the i-th snap option is in the "selected" state. 
            <para>
            Since there are 17 snap options, only the least significant 17 bits of the integer are used.
            If all options are selected, the integer's bits will consist of 17 ones, which means
            that the integer value will be 2^(17) - 1 = 131071. So, any set of options can
            be represented by an integer that is less than or equal to 131071.
            </para>
            <para>
            The integer value returned by getting this property value will be at most 131071.
            </para>
            <para>
            When setting this property, if the input value is larger than 131071, only
            the low-order 17 bits will be used.
            </para>
            The options specified in SnapPointTypesOnByDefault should be a subset of those
            specified by SnapPointTypesEnabled, but there is nothing here to enforce this.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPoint.SnapPointStates">Snap.UI.Block.SpecifyPoint.SnapPointStates</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.SnapPointStates">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
            <example> 
            This example shows how to use the SnapPointStates property:
            <code title="Using the SnapPointStates property" lang="VB.NET" source="UI_Block_Washer_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.Position">
            <summary>The location of the specified point</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.SelectedObjects">
            <summary>An array containing a Point object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, which is actually a Snap.NX.Point object.
            It is far more convenient to access this point using the 
            <see cref= "P:Snap.UI.Block.SpecifyPoint.SpecifiedPoint">SpecifiedPoint</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPoint.SpecifiedPoint">Snap.UI.Block.SpecifyPoint.SpecifiedPoint</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.PrivateSelectedObjects">
            <summary>An array containing a Point object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, which is actually a Snap.NX.Point object.
            It is far more convenient to access this Point using the SpecifiedObject property.
            This is a private version, for internal use, to avoid deprecation warnings.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.SpecifiedPoint">
            <summary>A Snap.NX.Point object specified by the user</summary>
            <remarks>
            <para>
            You can use this property in two ways:
            <list type = "bullet">
            <item>If you set its value in the OnShow function of your dialog, then the point you provide
            will serve as a default value for the SpecifyPoint block. If this default value is satisfactory, 
            then the user may not need to modify it, so his work will be reduced.</item>
            <item>You can get its value in your OnUpdate or OnApply event handler, and use it to
            construct other geometry. However, it's usually easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyPoint.Position">Position</see> property for this purpose.
            </item>
            </list> 
            If you don't provide a value in your OnShow function, a new Snap.NX.Point object will 
            be created internally when the dialog is displayed. The enclosed NXOpen.Point object
            will be invisible, however.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPoint.Position">Snap.UI.Block.SpecifyPoint.Position</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPoint.EnableFacetSelection">
            <summary>If true, indicates that elements of a facetted body can be selected</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyPoint.#ctor">
            <summary>Construct a SpecifyPoint block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyPoint.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyPoint in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyPoint block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyVector">
            <summary>Allows the user to specify a vector</summary>
            <example> 
            This example shows how to use SpecifyVector block: 
            <code title="A dialog with a SpecifyVector block" lang="VB.NET" source="UI_Block_SphereCap_01.vb">
            </code>
            <para>
            The following picture shows the dialog that is produced:
            </para>
            <img src="../Images/SphereCap.PNG"/>
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.Label">
            <summary>Explanatory text displayed above the block, if it begins a group</summary>
            <remarks>
            <para>
            If the block has <c>BeginGroup = False</c>, then this text is not displayed.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.LabelString">
            <summary>Prompt text displayed within the block </summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.DoubleSide">
            <summary>If true, indicates that the vector is double-sided</summary>
            <remarks>
            <para>
            If the vector is double-sided, two arrow symbols are shown in the graphics window,
            pointing in opposite directions, and the Reverse Direction icon is not shown in the block
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.Direction">
            <summary>The vector direction</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.Origin">
            <summary>The vector origin</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.Is2DMode">
            <summary>If true, indicates that the vector will be specified in a 2D mode</summary> 
            <remarks>
            <para>
            This means that the ZC-axis and View Direction methods will not be shown in the block's type menu.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.SnapPointTypesOnByDefault">
            <summary>The list of snapping options that will be enabled by default on the snap point toolbar</summary>
            <remarks>
            <para>
            You will probably find it much easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyPoint.SnapPointStates">SnapPointStates</see> property, rather than this one.
            </para>
            <para>
            The integer value is a Hexadecimal representation of the Bits option. 
            Integer values are generated in the code template.
            The options specified in SnapPointTypesOnByDefault must be a subset of those
            specified by SnapPointTypesEnabled.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPoint.SnapPointStates">Snap.UI.Block.SpecifyPoint.SnapPointStates</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.SnapPointStates">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
            <remarks>
            <para>
            Only the "Hidden" and "Selected" states are supported in the SpecifyVector block. 
            If you try to set a snap point option to the "Shown" state it will be set to "Hidden", instead. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.AutomaticProgression">
            <summary>If true, indicates that focus should automatically progress to the next block</summary>
            <remarks>
            <para>
            The blocks in a dialog are ordered in a "focus pathway". If AutomaticProgression is set to "true",
            then focus will automatically move to the next block in this pathway after the required steps
            have been completed in this one. For example, in the Unite command, when a body has been selected for 
            the target, input selection focus automatically progresses to the tool input. If an input is the 
            last input in the pathway, then automatic progression should be set to "false", since there is no 
            logical next step in the pathway.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.EnableFacetSelection">
            <summary>If true, indicates that elements of a facetted body can be selected</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.SelectedObjects">
            <summary>An array containing a direction object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, so it is far more convenient to access it using the 
            <see cref= "P:Snap.UI.Block.SpecifyVector.SpecifiedVector">SpecifiedVector</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyVector.SpecifiedVector">Snap.UI.Block.SpecifyVector.SpecifiedVector</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.PrivateSelectedObjects">
            <summary>An array containing (indirectly) a direction object specified by the user</summary>
            <remarks>
            <para>
            This is a private version, for internal use, to avoid deprecation warnings.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyVector.SpecifiedVector">
            <summary>A direction object specified by the user</summary>
            <remarks>
            <para>
            This is a Snap.NX.NXObject that wraps an NXOpen.Direction object. Since SNAP
            currently has no knowledge of these types of objects, you have to use NX/Open
            functions to work with them.
            </para>
            <para>
            You can use this property in two ways:
            <list type = "bullet">
            <item>If you set its value in the OnShow function of your dialog, then the object you provide
            will serve as a default value for the SpecifyVector block. If this default value is satisfactory, 
            then the user may not need to modify it, so his work will be reduced.</item>
            <item>You can get its value in your OnUpdate or OnApply event handler, and use it to
            construct other geometry. However, it's usually easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyVector.Direction">Direction</see> and
            <see cref= "P:Snap.UI.Block.SpecifyVector.Origin">Origin</see> properties for this purpose.
            </item>
            </list> 
            </para>
            <para>
            If you don't provide a value in your OnShow function, a new Snap.NX.NXObject will 
            be created internally when the dialog is displayed. The enclosed NXOpen.Direction object
            will be invisible, however.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyVector.Direction">Snap.UI.Block.SpecifyVector.Direction</seealso>
            <seealso cref= "P:Snap.UI.Block.SpecifyVector.Origin">Snap.UI.Block.SpecifyVector.Origin</seealso>
        </member>
        <member name="M:Snap.UI.Block.SpecifyVector.#ctor">
            <summary>Construct a SpecifyVector block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyVector.#ctor(Snap.Position,Snap.Vector)">
            <summary>Construct a SpecifyVector block</summary>
            <param name="origin">Origin of the vector</param>
            <param name="direction">Direction of the vector</param>
        </member>
        <member name="M:Snap.UI.Block.SpecifyVector.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyVector in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyVector block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyAxis">
            <summary>Allows the user to specify an axis</summary>
            <remarks>
            <para>
            A SpecifyAxis block is a combination of a SpecifyPoint block and a SpecifyVector block.
            </para>
            </remarks>
            <example>
            The following picture shows the dialog item and graphical display that are produced:
            <para>
            <img src="../Images/specify_axis.PNG"/>
            </para>      
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.Label">
            <summary>Explanatory text displayed above the block, if it begins a group</summary>
            <remarks>
            <para>
            If the block has <c>BeginGroup = False</c>, then this text is not displayed.
            </para>
            <para>
            You can not control the prompts that appear within the SpecifyAxis block itself.
            These always say "Specify Point" and "Specify Vector".
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.SelectedObjects">
            <summary>An array containing an axis object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, so it is far more convenient to access it using the 
            <see cref= "P:Snap.UI.Block.SpecifyAxis.SpecifiedAxis">SpecifiedAxis</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyAxis.SpecifiedAxis">Snap.UI.Block.SpecifyAxis.SpecifiedAxis</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.PrivateSelectedObjects">
            <summary>An array containing (indirectly) an axis object specified by the user</summary>
            <remarks>
            <para>
            This is a private version, for internal use, to avoid deprecation warnings.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.SpecifiedAxis">
            <summary>An axis object specified by the user</summary>
            <remarks>
            <para>
            This is a Snap.NX.NXObject that wraps an NXOpen.Axis object. Since SNAP
            currently has no knowledge of these types of objects, you have to use NX/Open
            functions to work with them.
            </para>
            <para>
            You can use this property in two ways:
            <list type = "bullet">
            <item>If you set its value in the OnShow function of your dialog, then the object you provide
            will serve as a default value for the SpecifyAxis block. If this default value is satisfactory, 
            then the user may not need to modify it, so his work will be reduced.</item>
            <item>You can get its value in your OnUpdate or OnApply event handler, and use it to
            construct other geometry. However, it's usually easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyAxis.Direction">Direction</see> and
            <see cref= "P:Snap.UI.Block.SpecifyAxis.Origin">Origin</see> properties for this purpose.
            </item>
            </list> 
            </para>
            <para>
            If you don't provide a value in your OnShow function, a new Snap.NX.NXObject will 
            be created internally when the dialog is displayed. The enclosed NXOpen.Axis object
            will be invisible, however.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyAxis.Direction">Snap.UI.Block.SpecifyAxis.Direction</seealso>
            <seealso cref= "P:Snap.UI.Block.SpecifyAxis.Origin">Snap.UI.Block.SpecifyAxis.Origin</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.Origin">
            <summary>The origin of the specified axis</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyAxis.Direction">
            <summary>The direction vector of the specified axis</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyAxis.#ctor">
            <summary>Construct a SpecifyAxis block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyAxis.#ctor(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Creates a new block of type SpecifyAxis</summary>
            <param name="dialog">The dialog in which the block will be created</param>
            <param name="blockID">The name (ID) to be assigned to the SpecifyAxis block</param>
        </member>
        <member name="M:Snap.UI.Block.SpecifyAxis.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyAxis in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyAxis block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyPlane">
            <summary>Allows the user to specify a plane</summary>
            <example>
            The following picture shows the dialog item and graphical display that are produced:
            <para>
            <img src="../Images/specify_plane.PNG"/>
            </para>      
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.Label">
            <summary>Explanatory text displayed above the block, if it begins a group</summary>
            <remarks>
            <para>
            If the block has <c>BeginGroup = False</c>, then this text is not displayed.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.LabelString">
            <summary>Prompt text displayed within the block </summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.SelectedObjects">
            <summary>An array containing a plane object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, so it is far more convenient to access it using the 
            <see cref= "P:Snap.UI.Block.SpecifyPlane.SpecifiedPlane">SpecifiedPlane</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPlane.SpecifiedPlane">Snap.UI.Block.SpecifyPlane.SpecifiedPlane</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.PrivateSelectedObjects">
            <summary>An array containing (indirectly) a plane object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, which is actually a Snap.NX.Point object.
            It is far more convenient to access this Point using the SpecifiedObject property.
            This is a private version, for internal use, to avoid deprecation warnings.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.SpecifiedPlane">
            <summary>A plane object specified by the user</summary>
            <remarks>
            <para>
            This is a Snap.NX.NXObject that wraps an NXOpen.Plane object. Since SNAP
            currently has no knowledge of these types of objects, you have to use NX/Open
            functions to work with them.
            </para>
            <para>
            You can use this property in two ways:
            <list type = "bullet">
            <item>If you set its value in the OnShow function of your dialog, then the object you provide
            will serve as a default value for the SpecifyPlane block. If this default value is satisfactory, 
            then the user may not need to modify it, so his work will be reduced.</item>
            <item>You can get its value in your OnUpdate or OnApply event handler, and use it to
            construct other geometry. However, it's usually easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyPlane.Plane">Plane</see> property for this purpose.
            </item>
            </list> 
            </para>
            <para>
            If you don't provide a value in your OnShow function, a new Snap.NX.NXObject will 
            be created internally when the dialog is displayed. The enclosed NXOpen.Plane object
            will be invisible, however.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyPlane.Plane">Snap.UI.Block.SpecifyPlane.Plane</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyPlane.Plane">
            <summary>The geometry plane of the selected plane</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyPlane.#ctor">
            <summary>Construct a SpecifyPlane block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyPlane.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyPlane in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyPlane block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyCsys">
            <summary>Allows the user to specify a coordinate system (csys)</summary>
            <example>
            The following picture shows the dialog item and graphical display that are produced:
            <para>
            <img src="../Images/specify_csys.PNG"/>
            </para>      
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.Label">
            <summary>Explanatory text displayed above the block, if it begins a group</summary>
            <remarks>
            <para>
            If the block has <c>BeginGroup = False</c>, then this text is not displayed.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.LabelString">
            <summary>Prompt text displayed within the block </summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.CreateInterpartLink">
            <summary>The state of the "Create Interpart Link" toggle on the Selection Bar</summary>
            <remarks>
            <para>
            Note that this toggle is only sensitive when working in-context and the InterpartSelection property 
            is set to "Controlled" (InterPartSelectionCopy.Controlled).
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.InterpartSelection">
            <summary>Specifies the behavior of the block when selecting geometry outside of the work part</summary>
            <remarks>
            <para>
            Setting this property will allow the block to create on-the-fly copies in the work part of the selected geometry.
            These copies may be either associative or non-associative.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.SelectedObjects">
            <summary>An array containing a CoordinateSystem object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, which is actually a Snap.NX.CoordinateSystem object.
            It is far more convenient to access this object using the 
            <see cref= "P:Snap.UI.Block.SpecifyCsys.SpecifiedCsys">SpecifiedCsys</see> property.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyCsys.SpecifiedCsys">Snap.UI.Block.SpecifyCsys.SpecifiedCsys</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.PrivateSelectedObjects">
            <summary>An array containing a CoordinateSystem object specified by the user</summary>
            <remarks>
            <para>
            The array has only a single member, which is actually a Snap.NX.CoordinateSystem object.
            It is far more convenient to access this CoordinateSystem using the SpecifiedCsys property.
            This is a private version, for internal use, to avoid deprecation warnings.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.SpecifiedCsys">
            <summary>A Snap.NX.CoordinateSystem object specified by the user</summary>
            <remarks>
            <para>
            You can use this property in two ways:
            <list type = "bullet">
            <item>If you set its value in the OnShow function of your dialog, then the coordinate system object you provide
            will serve as a default value for the SpecifyCsys block. If this default value is satisfactory, 
            then the user may not need to modify it, so his work will be reduced.</item>
            <item>You can get its value in your OnUpdate or OnApply event handler, and use it to
            construct other geometry. However, it's usually easier to use the 
            <see cref= "P:Snap.UI.Block.SpecifyCsys.Origin">Origin</see> and
            <see cref= "P:Snap.UI.Block.SpecifyCsys.Orientation">Orientation</see> properties for this purpose.
            </item>
            </list> 
            If you don't provide a value in your OnShow function, a new Snap.NX.CoordinateSystem object will 
            be created internally when the dialog is displayed. The enclosed NXOpen.CoordinateSystem object
            will be invisible, however.
            </para>
            </remarks>
            <seealso cref= "P:Snap.UI.Block.SpecifyCsys.Origin">Snap.UI.Block.SpecifyCsys.Origin</seealso>
            <seealso cref= "P:Snap.UI.Block.SpecifyCsys.Orientation">Snap.UI.Block.SpecifyCsys.Orientation</seealso>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.Origin">
            <summary>The location of the origin of the selected coordinate system</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCsys.Orientation">
            <summary>Orientation of the selected coordinate system</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyCsys.#ctor">
            <summary>Construct a specify CSYS block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyCsys.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyCsys in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyCsys block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyCursorLocation">
            <summary>Allows the user to specify a cursor location (i.e. a "screen position")</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.LabelString">
            <summary>Prompt text displayed within the block </summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.StepStatus">
            <summary>Indicates whether a selection is required in order for OK and Apply to become available</summary>
            <remarks>
            <para>
            This property can not be set in the DialogShown callback of a Snap.UI.BlockDialog, 
            nor in the OnShow function of a Snap.UI.BlockForm.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.DisplayTemporaryPoint">
            <summary>If true, indicates that a temporary point (asterisk "splat") will be displayed at the specified location</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyCursorLocation.CursorLocation">
            <summary>The specified cursor location</summary>
            <remarks>
            <para>
            A "cursor location" is a 3D position. It is located on the Work Plane (the XC-YC plane)
            at a point that is "underneath" the screen cursor. In other words, it is calculated
            by firing a ray along the line of sight and intersecting this ray with the Work Plane.
            In a parallel view, the direction of the ray is along the view normal. In a perspective view,
            the computation is more complicated, but we again get a 3D position that appears to be
            "underneath" the screen cursor.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SpecifyCursorLocation.#ctor">
            <summary>Construct a SpecifyCursorLocation block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyCursorLocation.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyCursorLocation in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyCursorLocation block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SpecifyOrientation">
            <summary>Allows the user to specify an orientation</summary>
            <remarks>
            <para>
            The user specifies the orientation by using a "manipulator" that is displayed in 
            the graphics window, as in the WCS Dynamics function within interactive NX
            </para>
            </remarks>
            <example>
            The following picture shows the graphical display that is produced:
            <para>
            <img src="../Images/specify_orientation.PNG"/>
            </para>      
            </example>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.HasOriginGwif">
            <summary>If true, indicates that a GWIF will be displayed when this block has focus </summary>
            <remarks>
            <para>
            A "GWIF" is a Graphics Window Input Field -- a small form displayed in the graphics window
            that allows the user to enter numbers. In this case, the numbers are the coordinates of the
            manipulator origin, or the distance through which it was last moved.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.IsWCSCoordinates">
            <summary>If true, indicates that the numbers in the GWIF are WCS coordinates</summary>
            <remarks>
            <para>
            This setting only affects the meaning of numbers that are displayed in the GWIF.
            The Origin, AxisX and AxisY properties always use Absolute coordinates.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.SnapPointTypesOnByDefault">
            <summary>The list of SNAP Point options that will be enabled by default on the SNAP Point toolbar</summary>
            <remarks>
            <para>
            The integer value is a Hexadecimal representation of the Bits option. 
            Integer values are generated in the code template.
            The options specified in SnapPointTypesOnByDefault must be a subset of those
            specified by SnapPointTypesEnabled.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.SnapPointStates">
            <summary>The list of Snap Point options that will be available on the snap point toolbar</summary>
            <remarks>
            <para>
            Only the "Hidden" and "Selected" states are supported in the SpecifyOrientation block. 
            If you try to set a snap point option to the "Shown" state it will be set to "Hidden", instead. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.EnableFacetSelection">
            <summary>If true, indicates that elements of a facetted body can be selected</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.Origin">
            <summary>The origin of the coordinate system</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.IsOriginSpecified">
            <summary>If true, indicates that the origin has been specified (which allows the block to be enabled)</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.AxisX">
            <summary>The X-Axis of the coordinate system -- must not be (0,0,0)</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.AxisY">
            <summary>The Y-Axis of the coordinate system -- must not be (0,0,0)</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.Orientation">
            <summary>The orientation of the coordinate system</summary>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.BalloonTooltipText">
            <summary>The text to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            You can specify multiple lines of text by using "\n" to indicate new-lines.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.BalloonTooltipImage">
            <summary>The pathname of the image file to be displayed in the balloon tooltip</summary>
            <remarks>
            <para>
            The image file must be in one of the following formats: TIFF, PNG, GIF, JPEG, or BMP. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SpecifyOrientation.BalloonTooltipLayout">
            <summary>The location of the text with respect to the image in the balloon tooltip</summary>
            <remarks>
            <para>
            This is applicable only when both text and image are specified. The two available options are:
            <list type="bullet">
            <item>Horizontal -- This is the default value. The text is placed to the right of the image.</item>
            <item>Vertical -- The text is placed below the image.</item> 
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SpecifyOrientation.#ctor">
            <summary>Construct a SpecifyOrientation block</summary>
        </member>
        <member name="M:Snap.UI.Block.SpecifyOrientation.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SpecifyOrientation in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SpecifyOrientation block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SelectPart">
            <summary>Allows the user to select a part</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectPart.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectPart.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectPart.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectPart.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectPart.SelectedParts">
            <summary>Array of parts selected by the user</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectPart.SelectedObjects">
            <summary>Array of NX objects selected by the user</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectPart.#ctor">
            <summary>Construct a SelectPart block</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectPart.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SelectPart in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SelectPart block object</returns>
        </member>
        <member name="M:Snap.UI.Block.SelectPart.GetSelectedParts">
            <summary>Get selected parts from a SelectPartFromList block</summary>
            <returns>An array of NX.NXObject objects</returns>
        </member>
        <member name="T:Snap.UI.Block.ReverseDirection">
            <summary>Provides a way for the user to reverse the direction of a vector</summary>
            <remarks>
            <para>
            This block synchronizes a "Reverse Direction" button on the dialog with an on-screen vector handle.  
            The sense of the vector can be reversed either by clicking the button on the dialog, or 
            by double clicking the handle in the graphics window.  
            Typical uses are reversing a surface normal, reversing the direction of a vector, reversing 
            the direction of a dimension, reversing the side of a plane, etc. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.Flip">
            <summary>If true, flips the direction handle, so that its sense is opposite to the "Direction" vector</summary>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.Origin">
            <summary>The origin of the vector handle</summary>
        </member>
        <member name="P:Snap.UI.Block.ReverseDirection.Direction">
            <summary>The direction of the vector handle</summary>
        </member>
        <member name="M:Snap.UI.Block.ReverseDirection.#ctor">
            <summary>Construct a ReverseDirection block</summary>
        </member>
        <member name="M:Snap.UI.Block.ReverseDirection.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type ReverseDirection in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The ReverseDirection block object</returns>
        </member>
        <member name="T:Snap.UI.Block.OrientXpress">
            <summary>Construct an OrientXpress block</summary>
            <remarks>
            <para>
            An OrientExpress block provides a quick way to specify either
            a principal axis or a principal plane.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowAxisSubBlock">
            <summary>If true, indicates that axis direction options will be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowPlaneSubBlock">
            <summary>If true, indicates that plane options will be displayed</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowReferenceSubBlock">
            <summary>If true, indicates that the reference options should be displayed</summary>
            <remarks>
            <para>
            The reference options allow the user to indicate which coordinate system
            should be used for reference when specifying a plane or axis.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ActiveAxis">
            <summary>The active axis (X, Y, or Z) of the OrientExpress gadget</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ActivePlane">
            <summary>The active plane (YZ, XZ, or XY) of the OrientExpress gadget</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.Reference">
            <summary>The value for the references options</summary>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowAxisX">
            <summary>If true, indicates that the X-axis option is available within the axis options</summary>
            <remarks>Accessing this property will raise an exception if ShowAxisSubBlock is false.</remarks>
            <seealso cref= "P:Snap.UI.Block.OrientXpress.ShowAxisSubBlock">ShowAxisBlock</seealso>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowAxisY">
            <summary>If true, indicates that the Y-axis option is available within the axis options</summary>
            <remarks>Accessing this property will raise an exception if ShowAxisSubBlock is false.</remarks>
            <seealso cref= "P:Snap.UI.Block.OrientXpress.ShowAxisSubBlock">ShowAxisBlock</seealso>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowAxisZ">
            <summary>If true, indicates that the Z-axis option is available within the axis options</summary>
            <remarks>Accessing this property will raise an exception if ShowAxisSubBlock is false.</remarks>
            <seealso cref= "P:Snap.UI.Block.OrientXpress.ShowAxisSubBlock">ShowAxisBlock</seealso>      
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowPlaneYZ">
            <summary>If true, indicates that the YZ-plane option is available within the plane options</summary>
            <remarks>Accessing this property will raise an exception if ShowPlaneSubBlock is false.</remarks>
            <seealso cref= "P:Snap.UI.Block.OrientXpress.ShowPlaneSubBlock">ShowPlaneBlock</seealso>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowPlaneXZ">
            <summary>If true, indicates that the XZ-plane option is available within the plane options</summary>
            <remarks>Accessing this property will raise an exception if ShowPlaneSubBlock is false.</remarks>
            <seealso cref= "P:Snap.UI.Block.OrientXpress.ShowPlaneSubBlock">ShowPlaneBlock</seealso>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowPlaneXY">
            <summary>If true, indicates that the XY-plane option is available within the plane options</summary>
            <remarks>Accessing this property will raise an exception if ShowPlaneSubBlock is false.</remarks>
            <seealso cref= "P:Snap.UI.Block.OrientXpress.ShowPlaneSubBlock">ShowPlaneBlock</seealso>
        </member>
        <member name="P:Snap.UI.Block.OrientXpress.ShowSceneControl">
            <summary>If true, indicates that the available planes and axes should be displayed</summary>
            <remarks>
            <para>
            If <c>ShowSceneControl = False</c>, then only the currently selected axis and plane are displayed.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.OrientXpress.#ctor">
            <summary>Construct an OrientXpress block</summary>
        </member>
        <member name="M:Snap.UI.Block.OrientXpress.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type OrientXPress in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The OrientXPress block object</returns>
        </member>
        <member name="T:Snap.UI.Block.SelectExpression">
            <summary>Allows the user to select an expression</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.Label">
            <summary>Explanatory text to label this block on the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.Enabled">
            <summary>If true, indicates that this block should be sensitive (not grayed out) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.Expanded">
            <summary>If true, indicates that this block should be expanded (not collapsed) in the dialog</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.BeginGroup">
            <summary>If true, indicates that a new group should be created to hold this block</summary>
            <remarks>
            <para>
            The new group will contain the current block and any subsequent ones that have
            <c>BeginGroup = False</c>.
            </para>
            <para>
            The BeginGroup property is not fully supported for blocks on a 
            <see cref = "T:Snap.UI.BlockForm">Snap.UI.BlockForm</see>.
            Please see the documentation for the
            <see cref = "T:Snap.UI.Block.Group">Group</see> block for further information.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.ExpressionType">
            <summary>The type of expressions to be listed for selection</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.ExpressionSortOrder">
            <summary>The sorting order of the list of expressions</summary>
        </member>
        <member name="P:Snap.UI.Block.SelectExpression.SelectedExpression">
            <summary>The selected expression</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectExpression.#ctor">
            <summary>Construct a SelectExpression block</summary>
        </member>
        <member name="M:Snap.UI.Block.SelectExpression.#ctor(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Creates a new block of type SelectExpression</summary>
            <param name="dialog">The dialog in which the block will be created</param>
            <param name="blockID">The name (ID) to be assigned to the SelectExpression block</param>
        </member>
        <member name="M:Snap.UI.Block.SelectExpression.GetBlock(NXOpen.BlockStyler.BlockDialog,System.String)">
            <summary>Finds and identifies a block of type SelectExpression in a dialog</summary>
            <param name="dialog">The dialog in which the block resides</param>
            <param name="name">The name (blockID) of the block</param>
            <returns>The SelectExpression block object</returns>
        </member>
        <member name="T:Snap.UI.Block.InterPartSelectionCopy">
            <summary>Controls on-the-fly copying of objects selected outside the work part</summary>
        </member>
        <member name="F:Snap.UI.Block.InterPartSelectionCopy.None">
            <summary>No geometry will be copied into the work part.</summary>
        </member>
        <member name="F:Snap.UI.Block.InterPartSelectionCopy.NoneAssociative">
            <summary>Creates non-associative copies in the work part of selected objects. 
            The setting of the "Create Interpart Link" toggle on the Selection Bar will be ignored.
            </summary>
        </member>
        <member name="F:Snap.UI.Block.InterPartSelectionCopy.Controlled">
            <summary>Copying of objects is controlled by the setting of the "Create Interpart Link" toggle on the Selection Bar.</summary>
        </member>
        <member name="F:Snap.UI.Block.InterPartSelectionCopy.Associative">
            <summary>Creates associative copies in the work part of selected objects. 
            The setting of the “Create Interpart Link” toggle on the Selection Bar will be ignored.
            </summary>
        </member>
        <member name="T:Snap.UI.Block.StepStatus">
            <summary>Determines how selection controls the availability of OK/Apply in the dialog</summary>
        </member>
        <member name="F:Snap.UI.Block.StepStatus.Required">
            <summary>A selection is required, and none has been provided, yet, so OK/Apply are unavailable</summary>
        </member>
        <member name="F:Snap.UI.Block.StepStatus.Optional">
            <summary>The selection is optional, so OK/Apply are available no matter what</summary>
        </member>
        <member name="F:Snap.UI.Block.StepStatus.Satisfied">
            <summary>A selection is required, and has been provided, so OK/Apply are available</summary>
        </member>
        <member name="T:Snap.UI.Block.SnapFocusOption">
            <summary>Controls the availability of the SNAP to Object option on MB3 during handle dragging</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapFocusOption.None">
            <summary>The SNAP To Object option is not available</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapFocusOption.OnClick">
            <summary>The SNAP To Object option is automatically activated  -- no need to explicitly request it</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapFocusOption.Explicit">
            <summary>The SNAP To Object option is activated only when requested via MB3</summary>
        </member>
        <member name="T:Snap.UI.Block.EnumPresentationStyle">
            <summary>Controls the presentation style (display) of an Enumeration block</summary>
            <remarks>
            <para>
            The OptionMenu presentation style produces a display like this:
            </para>
            <para>
            <img src="../Images/get_choice_dropdown.PNG"/>
            </para>
            The RadioBox presentation style produces a display like this:
            <para>
            <img src="../Images/get_choice_radio.PNG"/>
            </para>
            </remarks>
        </member>
        <member name="F:Snap.UI.Block.EnumPresentationStyle.OptionMenu">
            <summary>Values will be shown in drop down option menu</summary>
        </member>
        <member name="F:Snap.UI.Block.EnumPresentationStyle.RadioBox">
            <summary>Values will be shown in a box with radio buttons</summary>
        </member>
        <member name="T:Snap.UI.Block.NumberPresentationStyle">
            <summary>Controls the presentation style (display) of Integer and Double blocks</summary>
        </member>
        <member name="F:Snap.UI.Block.NumberPresentationStyle.KeyIn">
            <summary>User types the numerical value into the input field</summary>
        </member>
        <member name="F:Snap.UI.Block.NumberPresentationStyle.Spin">
            <summary>User inputs the value in increments using arrows next to the input field</summary>
        </member>
        <member name="F:Snap.UI.Block.NumberPresentationStyle.Scale">
            <summary>User inputs the value using a slider</summary>
        </member>
        <member name="F:Snap.UI.Block.NumberPresentationStyle.ScaleKeyIn">
            <summary>User has option of using the slider as well as input field</summary>
        </member>
        <member name="T:Snap.UI.Block.StringPresentationStyle">
            <summary>Controls the presentation style (display) of String blocks</summary>
        </member>
        <member name="F:Snap.UI.Block.StringPresentationStyle.KeyIn">
            <summary> String is displayed in a normal text box</summary>
        </member>
        <member name="F:Snap.UI.Block.StringPresentationStyle.Wide">
            <summary> String is displayed in a wide text box</summary>
        </member>
        <member name="F:Snap.UI.Block.StringPresentationStyle.List">
            <summary> String is displayed in a list box</summary>
        </member>
        <member name="F:Snap.UI.Block.StringPresentationStyle.Combo">
            <summary> String is displayed in a combo box</summary>
        </member>
        <member name="T:Snap.UI.Block.ExpressionType">
            <summary>The data type of an expression</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionType.Number">
            <summary>Expression of type Number</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionType.String">
            <summary>Expression of type String</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionType.Boolean">
            <summary>Expression of type Boolean</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionType.Integer">
            <summary>Expression of type Integer</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionType.Point">
            <summary>Expression of type Point</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionType.Vector">
            <summary>Expression of type Vector</summary>
        </member>
        <member name="T:Snap.UI.Block.ExpressionSortOrder">
            <summary>Controls how expressions are sorted when displayed in a list</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionSortOrder.Alphanumeric">
            <summary>Alphanumeric sorting order</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionSortOrder.TimeStampOrder">
            <summary>Timestamp sorting order</summary>
        </member>
        <member name="F:Snap.UI.Block.ExpressionSortOrder.ReverseTimeStampOrder">
            <summary>Reverse timestamp sorting order</summary>
        </member>
        <member name="T:Snap.UI.Block.SelectionScope">
            <summary>The scope for selecting objects</summary>
        </member>
        <member name="F:Snap.UI.Block.SelectionScope.UseDefault">
            <summary>Use the default selection scope</summary>
        </member>
        <member name="F:Snap.UI.Block.SelectionScope.WorkPart">
            <summary>Use the work part</summary>
        </member>
        <member name="F:Snap.UI.Block.SelectionScope.AnyInAssembly">
            <summary>Use any occurrence in the assembly</summary>
        </member>
        <member name="F:Snap.UI.Block.SelectionScope.WorkPartAndOccurrence">
            <summary>Use the work part or any occurrence</summary>
        </member>
        <member name="T:Snap.UI.Block.DimensionalityType">
            <summary>The dimensionality type of an expression</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.None">
            <summary>Dimensionality of type None</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.Length">
            <summary>Dimensionality of type Length</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.Area">
            <summary>Dimensionality of type Area</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.Volume">
            <summary>Dimensionality of type Volume</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.Mass">
            <summary>Dimensionality of type Mass</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.Angle">
            <summary>Dimensionality of type Angle</summary>
        </member>
        <member name="F:Snap.UI.Block.DimensionalityType.Force">
            <summary>Dimensionality of type Force</summary>
        </member>
        <member name="T:Snap.UI.Block.BalloonTooltipLayout">
            <summary>The location of text with respect to the image in the balloon tooltip. This is applicable only when both text and image are specified.</summary>
        </member>
        <member name="F:Snap.UI.Block.BalloonTooltipLayout.Horizontal">
            <summary>Horizontal -- This is the default value. The text is placed to the right of the image.</summary>
        </member>
        <member name="F:Snap.UI.Block.BalloonTooltipLayout.Vertical">
            <summary>Vertical -- The text is placed below the image.</summary>
        </member>
        <member name="T:Snap.UI.Block.Layout">
            <summary>The horizontal or vertical layout of options. This property is active only if property PresentationStyle is Radio Box.</summary>
        </member>
        <member name="F:Snap.UI.Block.Layout.Vertical">
            <summary>Vertical -- Options will be presented vertically.</summary>
        </member>
        <member name="F:Snap.UI.Block.Layout.Horizontal">
            <summary>Horizontal -- Options will be presented horizontally.</summary>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.GetPropertyValue(Snap.UI.Block.General,Snap.UI.Block.PropertyType,System.String)">
            <summary>An intelligent property get function; reads from NX/Open block if it exists, otherwise from block's Property Dictionary</summary>
            <param name="block">The block in which the property resides</param>
            <param name="propType">Type of property to read (which NX/Open propList access function to call)</param>
            <param name="propName">The property name (this is the NXOpen magic string)</param>
            <returns>The property value as an "object" variable</returns>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.SetPropertyValue(Snap.UI.Block.General,Snap.UI.Block.PropertyType,System.String,System.Object)">
            <summary>An intelligent property "set" function -- writes either to dictionary or NX/Open block, or both</summary>
            <param name="block">The block in which the property resides</param>
            <param name="propType">The type of the property we want to write (corresponds to NX/Open access function)</param>
            <param name="propName">The property name (this is the NXOpen magic string)</param>
            <param name="propValue">The property value we want to write</param>
            <remarks>
            <para>
            Allows writing of "null' to a property value. This is useful for clearing array properties.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.SetDictionaryValue(Snap.UI.Block.General,Snap.UI.Block.PropertyType,System.String,System.Object,System.Collections.Generic.Dictionary{Snap.UI.Block.PropertyKey,System.Object})">
            <summary>Sets a value in a Property Dictionary, with correct handling of reference types (arrays)</summary>
            <param name="block">The block in which the property resides</param>
            <param name="propType">The type of the property we want to write (corresponds to NX/Open access function)</param>
            <param name="propName">The property name (this is the NXOpen magic string)</param>
            <param name="propValue">The property value we want to write</param>
            <param name="dict">The dictionary into which we want to write</param>      
            <remarks>
            <para>
            Allows writing of "null' to a property value. This is useful for clearing array properties.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.AddProperty(Snap.UI.Block.General,Snap.UI.Block.PropertyKey,System.Object)">
            <summary>Adds a new property to the property dictionary of a block</summary>
            <param name="block">The block to add to</param>
            <param name="propKey">Property key</param>
            <param name="propValue">Property value</param>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.SetNxopenBlockValue(Snap.UI.Block.General,Snap.UI.Block.PropertyType,System.String,System.Object)">
            <summary>Writes a property value into an NX/Open block, which is assumed to exist already</summary>
            <param name="block">The Snap.UI.Block containing the NX/Open block</param>
            <param name="propType">Type of property to write (which NX/Open propList access function to call)</param>
            <param name="propName">Name of property to write (the NX/Open magic string)</param>
            <param name="propValue">The property value in an "object" variable</param>
            <remarks>
            <para>
            You can't write the "Type" property. And you shouldn't need to, because it's correct from the outset.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.GetNxopenBlockValue(Snap.UI.Block.General,Snap.UI.Block.PropertyType,System.String)">
            <summary>Reads a property value from an NX/Open block, which is assumed to exist already</summary>
            <param name="block">The Snap.UI.Block containing the NX/Open block</param>
            <param name="propType">Type of property to read (which NX/Open propList access function to call)</param>
            <param name="propName">Name of property to read (the NX/Open magic string)</param>
            <returns>The property value in an "object" variable</returns>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.DictionaryToBlock(Snap.UI.Block.General,Snap.UI.Block.PropertyKey)">
            <summary>Copies a property from the Dictionary into an NX/Open block, unconditionally</summary>
        </member>
        <member name="M:Snap.UI.Block.PropertyAccess.BlockToDictionary(Snap.UI.Block.General,Snap.UI.Block.PropertyKey)">
            <summary>Copies a property an NX/Open block back to the Property Dictionary</summary>
        </member>
        <member name="T:Snap.UI.Block.PropertyType">
            <summary>Types of properties</summary>
            <remarks>
            <para>
            The types correspond the NX/Open get/set functions. The type tells us which
            Get/Set functions to call. Note the complications with Enums.
            </para>
            </remarks>
        </member>
        <member name="T:Snap.UI.Block.PropertyKey">
            <summary>The key used in Property Dictionaries</summary>
            <remarks>
            <para>
            We can't use just the property name as a key because there are cases where 
            a given block has several properties with the same name (but different types)
            </para>
            </remarks>
        </member>
        <member name="T:Snap.UI.Block.SnapPointsStateSet">
            <summary>An object that records the states of various snap point options</summary>
            <example> 
            This example shows how to use a SnapPointsStateSet:
            <code title="Using snap-point states" lang="VB.NET" source="UI_Block_Washer_01.vb"> 
            </code> 
            </example>
        </member>
        <member name="F:Snap.UI.Block.SnapPointsStateSet.numOptions">
            <summary>The number of snap point options</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapPointsStateSet.OwnerBlock">
            <summary>The block that owns this StateSet</summary>
            <remarks>
            <para>
            The block must be of a type that has SnapPointsEnabled and SnapPointsOnByDefault properties
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.OptionArray">
            <summary>Array of option settings</summary>
            <remarks>
            <para>
            The correspondence between array positions and snap point options is as follows:
            <list type = "bullet">
            <item>array[0]  : UserDefined</item>
            <item>array[1]  : Inferred</item>
            <item>array[2]  : ScreenPosition</item>
            <item>array[3]  : EndPoint</item>
            <item>array[4]  : MidPoint</item>
            <item>array[5]  : ControlPoint</item>
            <item>array[6]  : Intersection</item>
            <item>array[7]  : ArcCenter</item>
            <item>array[8]  : QuadrantPoint</item>
            <item>array[9]  : ExistingPoint</item>
            <item>array[10] : PointOnCurve</item>
            <item>array[11] : PointOnSurface</item>
            <item>array[12] : PointConstructor</item>
            <item>array[13] : TwoCurveIntersection</item>
            <item>array[14] : TangentPoint</item>
            <item>array[15] : Pole</item>
            <item>array[16] : BoundedGridPoint</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SnapPointsStateSet.IntToBools(System.Int32,System.Int32)">
            <summary>Convert an integer bit-mask to an array of booleans</summary>
            <param name="mask">Integer bi-mask</param>
            <param name="bitCount">Number of bits to use from integer</param>
            <returns>Array of booleans; bool[i] = true iff bits[i] = 1</returns>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.UserDefined">
            <summary>Controls the use of the "User Defined" option for specifying positions</summary>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.Inferred">
            <summary>Controls the use of the "Inferred" option for specifying positions</summary>
            <remarks>This option allows positions to be specified by inferencing. In other words, the
            <para>
            </para>
            system will intelligently guess which option the user wants.
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.ScreenPosition">
            <summary>Controls the use of the "Screen Position" or "Cursor Location" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position on the Work Plane using the cursor.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.EndPoint">
            <summary>Controls the use of the "End Point" option for specifying points</summary>
            <remarks>This option allows the user to specify a point at the end of a curve or edge.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.MidPoint">
            <summary>Controls the use of the "Midpoint" option for specifying positions</summary>
            <remarks>
            <para>
            This option allows the user to specify a position halfway along a curve (or edge).
            Only linear and circular curves are supported. Closed curves are not supported. 
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.ControlPoint">
            <summary>Controls the use of the "Control Point" option for specifying positions</summary>
            <remarks>
            <para>
            This option is a combination of end-points, mid-points, existing points, and spline knot-points.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.Intersection">
            <summary>Controls the use of the "Intersection" option for specifying positions</summary>
            <remarks>
            <para>
            This option allows the user to specify a position at the intersection of two curves with a
            single click. The two curves must physically intersect in 3D space.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.ArcCenter">
            <summary>Controls the use of the "Arc Center" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position at the center of an arc or an ellipse.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.QuadrantPoint">
            <summary>Controls the use of the "Quadrant Point" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position at a quadrant point on an arc or an ellipse
            <para>
            </para>
            (a point at 0, 90, 180, or 270 degrees).
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.ExistingPoint">
            <summary>Controls the use of the "Existing Point" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position by selecting an existing point object.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.PointOnCurve">
            <summary>Controls the use of the "Point on Curve" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position on a curve with the cursor.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.PointOnSurface">
            <summary>Controls the use of the "Point on Face" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position on a face with the cursor.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.PointConstructor">
            <summary>Controls the use of the "Point Constructor" option for specifying positions</summary>
            <remarks>This option allows the user to specify a position using the Point Constructor dialog.</remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.TwoCurveIntersection">
            <summary>Controls the use of the "Two Curve Intersection" option for specifying positions</summary>
            <remarks>
            <para>
            This option allows the user to specify a position at the intersection of two curves, which are
            selected one at a time. The two curves do not need to physically intersect in 3D space. The second
            curve is swept parallel to the ZC-axis to obtain a "projected" intersection. So, the intersection
            will lie on the first curve, but not necessarily on the second one.
            </para>
            </remarks>         
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.TangentPoint">
            <summary>Controls the use of the "Tangent Point" option for specifying positions</summary>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.Pole">
            <summary>Controls the use of the "Pole" option for specifying positions</summary>
            <remarks>
            <para>
            This option allows the user to specify a position at a pole (control vertex)
            of a spline or a b-surface.
            </para>
            </remarks>
        </member>
        <member name="P:Snap.UI.Block.SnapPointsStateSet.BoundedGridPoint">
            <summary>Controls the use of the "Point on Bounded Grid" option for specifying positions</summary>
            <remarks>
            <para>
            This option allows the user to specify a position by snapping the cursor location to
            a datum plane grid or a view section grid.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SnapPointsStateSet.SetAllSnapPointStates(Snap.UI.Block.SnapPointState)">
            <summary>Set all snap point states to be hidden, shown, or selected</summary>
            <param name="state">Snap point state to be applied</param>
        </member>
        <member name="M:Snap.UI.Block.SnapPointsStateSet.SetAll(Snap.UI.Block.SnapPointState)">
            <summary>Set all snap point states to be hidden, shown, or selected</summary>
            <param name="state">Snap point state to be applied</param>
            <remarks>
            <para>
            This function does exactly the same thing as SetAllSnapPointStates.
            It's just easier to type and easier to read.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SnapPointsStateSet.DeselectAllShown">
            <summary>Change the state of all "Selected" options to "Shown"</summary>
            <remarks>
            <para>
            This function is useful in OnShow functions. You can use it there to deselect
            all selected options, and then individually select the ones you want.
            You can't do this conveniently with the SetAll function.
            </para>
            </remarks>
        </member>
        <member name="M:Snap.UI.Block.SnapPointsStateSet.SelectAllShown">
            <summary>Change the state of all "Shown" options to "Selected"</summary>
        </member>
        <member name="T:Snap.UI.Block.SnapPointState">
            <summary>The three possible states of a snap point option</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapPointState.Hidden">
            <summary>Not shown on toolbar, so not available.</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapPointState.Shown">
            <summary>Shown on toolbar. Available, but not chosen.</summary>
        </member>
        <member name="F:Snap.UI.Block.SnapPointState.Selected">
            <summary>Shown on toolbar, and depressed (selected for use)</summary>
        </member>
        <member name="T:Snap.UI.NamespaceDoc">
            <summary>
            Contains functions allowing you to create dialogs that communicate with the user.
            For example, your dialogs can ask the user to select objects or enter information.
            </summary> 
        </member>
        <member name="T:NXOpen.Tutor">
            <summary>Simple functions used in the "Getting Started with NX Open" guide</summary>
        </member>
        <member name="M:NXOpen.Tutor.InfoWrite(System.String)">
            <summary>Writes a string to the Info window (with no newline added)</summary>
            <param name="info">The string to write</param>      
        </member>
        <member name="M:NXOpen.Tutor.InfoWriteLine(System.String)">
            <summary>Writes a string to the Info window (with a newline added)</summary>
            <param name="info">The string to write</param>            
        </member>
        <member name="M:NXOpen.Tutor.CreatePoint(System.Double,System.Double,System.Double)">
            <summary>Creates an NXOpen.Point object</summary>
            <param name="x">x coordinate</param>
            <param name="y">y coordinate</param>
            <param name="z">z coordinate</param>
            <returns>An NX.Point object</returns>
        </member>
        <member name="M:NXOpen.Tutor.CreateLine(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates an NXOpen.Line object</summary>
            <param name="x0">X-coordinate of start point</param>
            <param name="y0">Y-coordinate of start point</param>
            <param name="z0">Z-coordinate of start point</param>
            <param name="x1">X-coordinate of end   point</param>
            <param name="y1">Y-coordinate of end   point</param>
            <param name="z1">Z-coordinate of end   point</param>
            <returns>An NXOpen.Line object</returns>
        </member>
        <member name="M:NXOpen.Tutor.CreateCircle(System.Double,System.Double,System.Double,System.Double)">
            <summary>Constructs a circle parallel to the XY-plane</summary>
            <param name="cx">X-coordinate of center point (in absolute coordinates)</param>
            <param name="cy">Y-coordinate of center point (in absolute coordinates)</param>
            <param name="cz">Z-coordinate of center point (in absolute coordinates)</param>
            <param name="radius">Radius</param>
            <returns>An NXOpen.Arc object</returns>
        </member>
        <member name="M:NXOpen.Tutor.CreateCircle(NXOpen.Point3d,NXOpen.Vector3d,System.Double)">
            <summary>Constructs a circle from center, normal, radius</summary>
            <param name="center">Center point (in absolute coordinates)</param>
            <param name="axisZ">Unit vector normal to plane of circle</param>
            <param name="radius">Radius</param>
            <returns>An NXOpen.Arc object</returns>
        </member>
        <member name="M:NXOpen.Tutor.CurvePoint(NXOpen.Curve,System.Double)">
            <summary>Calculate a point on a curve at a given parameter value</summary>
            <param name="curve">The curve</param>
            <param name="t">The parameter value</param>
            <returns>Position on curve</returns>
        </member>
        <member name="M:NXOpen.Tutor.CurveTangent(NXOpen.Curve,System.Double)">
            <summary>Calculate a unit tangent vector on a curve at a given parameter value</summary>
            <param name="curve">The curve</param>
            <param name="t">The parameter value</param>
            <returns>Unit tangent vector at location on curve</returns>
        </member>
        <member name="M:NXOpen.Tutor.CreateSphere(System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates a sphere feature, given center coordinates and diameter</summary>
            <param name="cx">X-coordinate of center point (in absolute coordinates)</param>
            <param name="cy">Y-coordinate of center point (in absolute coordinates)</param>
            <param name="cz">Z-coordinate of center point (in absolute coordinates)</param>
            <param name="diameter">Diameter</param>
            <returns>An NXOpen.Sphere object</returns>
        </member>
        <member name="M:NXOpen.Tutor.GetObjectFromTag(NXOpen.Tag)">
            <summary>Get an NXOpen.NXObject from a given NXOpen.Tag</summary>
            <param name="tag"></param>
            <returns>An NXOpen.NXObject, or null</returns>
            <remarks>
            Returns null if the given tag does not correspond to an NXOpen.NXObject.
            </remarks>
        </member>
        <member name="M:NXOpen.Tutor.GetAxes(NXOpen.Vector3d)">
            <summary>Constructor, given a Z-axis vector</summary>
            <param name="axisZ">Vector to be used as the Z-axis of the orientation (length doesn't matter)</param>
            <returns>Arbitrary X and Y axes orthogonal to give Z-axis</returns>
            <remarks>
            The X and Y axes are constructed arbitrarily, so use this constructor only
            when you don't care about these other axes.
            </remarks>      
        </member>
        <member name="M:NXOpen.Tutor.VectorCross(NXOpen.Vector3d,NXOpen.Vector3d)">
            <summary>Calculates the cross product (vector product) of two vectors</summary>
            <param name="u">First vector</param>
            <param name="v">Second vector</param>
            <returns>Cross product</returns>
        </member>
        <member name="M:NXOpen.Tutor.VectorUnit(NXOpen.Vector3d)">
            <summary>Unitizes a given vector</summary>
            <param name="u">Vector to be unitized</param>
            <returns>Unit vector in same direction</returns>
            <remarks>
            If the input is the zero vector is zero, then each component
            of the returned vector will be NaN (not a number).
            </remarks>
        </member>
    </members>
</doc>
