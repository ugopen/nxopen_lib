#ifndef NXOpen_ROUTING_MANUALROUTEBUILDER_HXX_INCLUDED
#define NXOpen_ROUTING_MANUALROUTEBUILDER_HXX_INCLUDED
//--------------------------------------------------------------------------
//  Header for C++ interface to JA API
//--------------------------------------------------------------------------
//
//  Source File:
//     Routing_ManualRouteBuilder.ja
//
//  Generated by:
//     apiwrap
//
//  WARNING:
//    This file is automatically generated - do not edit by hand
//
#ifdef _MSC_VER
#pragma once
#endif

#include <NXOpen/NXDeprecation.hxx>
#include <vector>
#include <NXOpen/NXString.hxx>
#include <NXOpen/Callback.hxx>
#include <NXOpen/Builder.hxx>
#include <NXOpen/ObjectList.hxx>
#include <NXOpen/Routing_ManualRouteBuilder.hxx>
#include <NXOpen/ugmath.hxx>
#include <NXOpen/libnxopencpp_exports.hxx>
namespace NXOpen
{
    namespace Routing
    {
        class ManualRouteBuilder;
    }
    class Builder;
    class Point;
    class PointList;
    namespace Routing
    {
        class Path;
    }
    namespace Routing
    {
        class _ManualRouteBuilderBuilder;
        class ManualRouteBuilderImpl;
        /**  <br> To create a new instance of this class, use @link Routing::RouteManager::CreateManualRouteBuilder Routing::RouteManager::CreateManualRouteBuilder@endlink  <br> */
        class NXOPENCPPEXPORT  ManualRouteBuilder : public Builder
        {
            private: ManualRouteBuilderImpl * m_manualroutebuilder_impl;
            private: friend class  _ManualRouteBuilderBuilder;
            protected: ManualRouteBuilder();
            public: ~ManualRouteBuilder();
            /**Returns  the point list  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: NXOpen::PointList * PointList
            (
            );
            /** Cycle paths through filter paths array to enable user select path for routing.  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void CyclePaths
            (
            );
            /** This function gets filter paths from builder. These paths are those which passes through selected points
                        in point list. @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: std::vector<NXOpen::Routing::Path *> GetFilterPaths
            (
            );
            /**   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void SetFilterPaths
            (
                const std::vector<NXOpen::Routing::Path *> & filterPaths /** filterpaths */ 
            );
            /** This function returns all possible paths for stockDevice stored in builder.  @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: std::vector<NXOpen::Routing::Path *> GetPaths
            (
            );
            /** This function updates the filter paths in builder, using the given selected point. 
                        It checks all the filter paths stored in builder, and finds paths passing through given point.
                        Then it updates filter paths accordingly in builder.  @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: bool UpdateFilterPaths
            (
                NXOpen::Point * point /** point */ 
            );
            /** This function returns all possible paths which are passing through all the given points.  @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: std::vector<NXOpen::Routing::Path *> FindPathsFromMultiplePoints
            (
                const std::vector<NXOpen::Point *> & points /** points */ ,
                bool* foundPath /** foundpath */ 
            );
            /** This function returns currently highlighted path stored in builder  @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: NXOpen::Routing::Path * GetHighlightPath
            (
            );
            /** This function sets highlight path amongst all paths, and this highlight path only
                         will be used for routing the stock device  <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: void SetHighlightPath
            (
                NXOpen::Routing::Path * path /** path */ 
            );
            /** This function will get all the paths stored in @link Routing::ManualRouteBuilder Routing::ManualRouteBuilder@endlink  and 
                        will create point for any location which lies on any of the paths. Newly created points will be returned
                        as result. It will also return the filter paths found using given locations.  @return   <br> License requirements : routing_combined ("Routing Combined") OR routing_electrical ("Routing Electrical") OR routing_mechanical ("Routing Mechanical") */
            public: std::vector<NXOpen::Routing::Path *> CreateValidPointsOnPaths
            (
                const std::vector<NXOpen::Point3d> & pointLocs /** pointlocs */ ,
                std::vector<NXOpen::Point *> & validPoints /** validpoints */ 
            );
        };
    }
}
#undef EXPORTLIBRARY
#endif
